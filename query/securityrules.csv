"ruleId","displayName","enabled","type","severity","category","source","queryFrequency","queryPeriod","description","body"
"045dcc54-da13-48b9-9c77-7b6346487951","Powershell Empire cmdlets seen in command line","true","Detection","Medium","SecurityEvents","SecurityEvent","1d","1d","Identifies instances of PowerShell Empire cmdlets in powershell process command line data.","let timeframe = 1d;
let regexEmpire = @""SetDelay|GetDelay|Set-LostLimit|Get-LostLimit|Set-Killdate|Get-Killdate|Set-WorkingHours|Get-WorkingHours|Get-Sysinfo|Add-Servers|Invoke-ShellCommand|Start-AgentJob|Update-Profile|Get-FilePart|Encrypt-Bytes|Decrypt-Bytes|Encode-Packet|Decode-Packet|Send-Message|Process-Packet|Process-Tasking|Get-Task|Start-Negotiate|Invoke-DllInjection|Invoke-ReflectivePEInjection|Invoke-Shellcode|Invoke-ShellcodeMSIL|Get-ChromeDump|Get-ClipboardContents|Get-IndexedItem|Get-Keystrokes|Invoke-Inveigh|Invoke-NetRipper|local:Invoke-PatchDll|Invoke-NinjaCopy|Get-Win32Types|Get-Win32Constants|Get-Win32Functions|Sub-SignedIntAsUnsigned|Add-SignedIntAsUnsigned|Compare-Val1GreaterThanVal2AsUInt|Convert-UIntToInt|Test-MemoryRangeValid|Write-BytesToMemory|Get-DelegateType|Get-ProcAddress|Enable-SeDebugPrivilege|Invoke-CreateRemoteThread|Get-ImageNtHeaders|Get-PEBasicInfo|Get-PEDetailedInfo|Import-DllInRemoteProcess|Get-RemoteProcAddress|Copy-Sections|Update-MemoryAddresses|Import-DllImports|Get-VirtualProtectValue|Update-MemoryProtectionFlags|Update-ExeFunctions|Copy-ArrayOfMemAddresses|Get-MemoryProcAddress|Invoke-MemoryLoadLibrary|Invoke-MemoryFreeLibrary|Out-Minidump|Get-VaultCredential|Invoke-DCSync|Translate-Name|Get-NetDomain|Get-NetForest|Get-NetForestDomain|Get-DomainSearcher|Get-NetComputer|Get-NetGroupMember|Get-NetUser|Invoke-Mimikatz|Invoke-PowerDump|Invoke-TokenManipulation|Exploit-JMXConsole|Exploit-JBoss|Invoke-Thunderstruck|Invoke-VoiceTroll|Set-WallPaper|Invoke-PsExec|Invoke-SSHCommand|Invoke-PSInject|Invoke-RunAs|Invoke-SendMail|Invoke-Rule|Get-OSVersion|Select-EmailItem|View-Email|Get-OutlookFolder|Get-EmailItems|Invoke-MailSearch|Get-SubFolders|Get-GlobalAddressList|Invoke-SearchGAL|Get-SMTPAddress|Disable-SecuritySettings|Reset-SecuritySettings|Get-OutlookInstance|New-HoneyHash|Set-MacAttribute|Invoke-PatchDll|Get-SecurityPackages|Install-SSP|Invoke-BackdoorLNK|New-ElevatedPersistenceOption|New-UserPersistenceOption|Add-Persistence|Invoke-CallbackIEX|Add-PSFirewallRules|Invoke-EventLoop|Invoke-PortBind|Invoke-DNSLoop|Invoke-PacketKnock|Invoke-CallbackLoop|Invoke-BypassUAC|Get-DecryptedCpassword|Get-GPPInnerFields|Invoke-WScriptBypassUAC|Get-ModifiableFile|Get-ServiceUnquoted|Get-ServiceFilePermission|Get-ServicePermission|Invoke-ServiceUserAdd|Invoke-ServiceCMD|Write-UserAddServiceBinary|Write-CMDServiceBinary|Write-ServiceEXE|Write-ServiceEXECMD|Restore-ServiceEXE|Invoke-ServiceStart|Invoke-ServiceStop|Invoke-ServiceEnable|Invoke-ServiceDisable|Get-ServiceDetail|Find-DLLHijack|Find-PathHijack|Write-HijackDll|Get-RegAlwaysInstallElevated|Get-RegAutoLogon|Get-VulnAutoRun|Get-VulnSchTask|Get-UnattendedInstallFile|Get-Webconfig|Get-ApplicationHost|Write-UserAddMSI|Invoke-AllChecks|Invoke-ThreadedFunction|Test-Login|Get-UserAgent|Test-Password|Get-ComputerDetails|Find-4648Logons|Find-4624Logons|Find-AppLockerLogs|Find-PSScriptsInPSAppLog|Find-RDPClientConnections|Get-SystemDNSServer|Invoke-Paranoia|Invoke-WinEnum{|Get-SPN|Invoke-ARPScan|Invoke-Portscan|Invoke-ReverseDNSLookup|Invoke-SMBScanner|New-InMemoryModule|Add-Win32Type|Export-PowerViewCSV|Get-MacAttribute|Copy-ClonedFile|Get-IPAddress|Convert-NameToSid|Convert-SidToName|Convert-NT4toCanonical|Get-Proxy|Get-PathAcl|Get-NameField|Convert-LDAPProperty|Get-NetDomainController|Add-NetUser|Add-NetGroupUser|Get-UserProperty|Find-UserField|Get-UserEvent|Get-ObjectAcl|Add-ObjectAcl|Invoke-ACLScanner|Get-GUIDMap|Get-ADObject|Set-ADObject|Get-ComputerProperty|Find-ComputerField|Get-NetOU|Get-NetSite|Get-NetSubnet|Get-DomainSID|Get-NetGroup|Get-NetFileServer|SplitPath|Get-DFSshare|Get-DFSshareV1|Get-DFSshareV2|Get-GptTmpl|Get-GroupsXML|Get-NetGPO|Get-NetGPOGroup|Find-GPOLocation|Find-GPOComputerAdmin|Get-DomainPolicy|Get-NetLocalGroup|Get-NetShare|Get-NetLoggedon|Get-NetSession|Get-NetRDPSession|Invoke-CheckLocalAdminAccess|Get-LastLoggedOn|Get-NetProcess|Find-InterestingFile|Invoke-CheckWrite|Invoke-UserHunter|Invoke-StealthUserHunter|Invoke-ProcessHunter|Invoke-EventHunter|Invoke-ShareFinder|Invoke-FileFinder|Find-LocalAdminAccess|Get-ExploitableSystem|Invoke-EnumerateLocalAdmin|Get-NetDomainTrust|Get-NetForestTrust|Find-ForeignUser|Find-ForeignGroup|Invoke-MapDomainTrust|Get-Hex|Create-RemoteThread|Get-FoxDump|Decrypt-CipherText|Get-Screenshot|Start-HTTP-Server|Local:Invoke-CreateRemoteThread|Local:Get-Win32Functions|Local:Inject-NetRipper|GetCommandLine|ElevatePrivs|Get-RegKeyClass|Get-BootKey|Get-HBootKey|Get-UserName|Get-UserHashes|DecryptHashes|DecryptSingleHash|Get-UserKeys|DumpHashes|Enable-SeAssignPrimaryTokenPrivilege|Enable-Privilege|Set-DesktopACLs|Set-DesktopACLToAllowEveryone|Get-PrimaryToken|Get-ThreadToken|Get-TokenInformation|Get-UniqueTokens|Find-GPOLocation|Find-GPOComputerAdmin|Get-DomainPolicy|Get-NetLocalGroup|Get-NetShare|Get-NetLoggedon|Get-NetSession|Get-NetRDPSession|Invoke-CheckLocalAdminAccess|Get-LastLoggedOn|Get-NetProcess|Find-InterestingFile|Invoke-CheckWrite|Invoke-UserHunter|Invoke-StealthUserHunter|Invoke-ProcessHunter|Invoke-EventHunter|Invoke-ShareFinder|Invoke-FileFinder|Find-LocalAdminAccess|Get-ExploitableSystem|Invoke-EnumerateLocalAdmin|Get-NetDomainTrust|Get-NetForestTrust|Find-ForeignUser|Find-ForeignGroup|Invoke-MapDomainTrust|Get-Hex|Create-RemoteThread|Get-FoxDump|Decrypt-CipherText|Get-Screenshot|Start-HTTP-Server|Local:Invoke-CreateRemoteThread|Local:Get-Win32Functions|Local:Inject-NetRipper|GetCommandLine|ElevatePrivs|Get-RegKeyClass|Get-BootKey|Get-HBootKey|Get-UserName|Get-UserHashes|DecryptHashes|DecryptSingleHash|Get-UserKeys|DumpHashes|Enable-SeAssignPrimaryTokenPrivilege|Enable-Privilege|Set-DesktopACLs|Set-DesktopACLToAllowEveryone|Get-PrimaryToken|Get-ThreadToken|Get-TokenInformation|Get-UniqueTokens|Invoke-ImpersonateUser|Create-ProcessWithToken|Free-AllTokens|Enum-AllTokens|Invoke-RevertToSelf|Set-Speaker(\$Volume){\$wshShell|Local:Get-RandomString|Local:Invoke-PsExecCmd|Get-GPPPassword|Local:Inject-BypassStuff|Local:Invoke-CopyFile\(\$sSource,|ind-Fruit|New-IPv4Range|New-IPv4RangeFromCIDR|Parse-Hosts|Parse-ILHosts|Exclude-Hosts|Get-TopPort|Parse-Ports|Parse-IpPorts|Remove-Ports|Write-PortscanOut|Convert-SwitchtoBool|Get-ForeignUser|Get-ForeignGroup"";
let ProcessCreationEvents=() {
let processEvents=SecurityEvent
| where EventID==4688
| where isnotempty(CommandLine)
| project TimeGenerated, Computer, Account = SubjectUserName, AccountDomain = SubjectDomainName, FileName = Process, CommandLine, ParentProcessName;
processEvents};
let decodedPS = ProcessCreationEvents
| where TimeGenerated >= ago(timeframe) 
| where CommandLine contains "" -encodedCommand""
| parse kind=regex flags=i CommandLine with * ""-EncodedCommand "" encodedCommand
| project StartTimeUtc = TimeGenerated, encodedCommand = tostring(split(encodedCommand, ' ')[0]), CommandLine
// Note: currently the base64_decodestring function is limited to supporting UTF8
| extend decodedCommand = translate('\0','', base64_decodestring(substring(encodedCommand, 0, strlen(encodedCommand) -  (strlen(encodedCommand) %8)))), encodedCommand, CommandLine , strlen(encodedCommand);
(decodedPS
| union 
(ProcessCreationEvents
| where TimeGenerated >= ago(timeframe)
| where FileName in~ (""powershell.exe"",""powershell_ise.exe"")
| where CommandLine !contains ""-encodedcommand"")
| extend StartTimeUtc = TimeGenerated
)
| where CommandLine matches regex regexEmpire
| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = Computer"
"f7620f0b-5d3c-4914-87a7-70ca0c65c251","ADFS Database Named Pipe Connection","false","Detection","Medium","SecurityEvents","SecurityEvent","1d","1d","此检测使用 Sysmon 遥测通过命名管道检测到 AD FS 配置数据库（Windows 内部数据库）的可疑本地连接。 
为了使用此查询，您需要收集 Sysmon EventIdD 18 (Pipe Connected)。如果您的工作区中没有 Sysmon 数据，此查询将引发错误说明：
无法解析名为 '[@Name 的标量表达式 ]''
 ","// Adjust this to use a longer timeframe to identify ADFS servers
//let lookback = 6d;
// Adjust this to adjust the key export detection  timeframe
//let timeframe = 1d;
// Start be identifying ADFS servers to reduce FP chance
let ADFS_Servers = (
Event
//| where TimeGenerated > ago(timeframe+lookback)
| where Source == ""Microsoft-Windows-Sysmon""
| where EventID == 18
| extend EventData = parse_xml(EventData).DataItem.EventData.Data
| mv-expand bagexpansion=array EventData
| evaluate bag_unpack(EventData)
| extend Key = tostring(column_ifexists('@Name', """")), Value = column_ifexists('#text', """")
| evaluate pivot(Key, any(Value), TimeGenerated, Source, EventLog, Computer, EventLevel, EventLevelName, EventID, UserName, MG, ManagementGroupName, _ResourceId)
| extend Image = column_ifexists(""Image"", """")
| extend process = split(Image, '\\', -1)[-1]
| where process =~ ""Microsoft.IdentityServer.ServiceHost.exe""
| summarize by Computer);
// Look for ADFS servers where Named Pipes event are present
Event
//| where TimeGenerated > ago(timeframe)
| where Source == ""Microsoft-Windows-Sysmon""
| where EventID == 18
| where Computer in~ (ADFS_Servers)
| extend RenderedDescription = tostring(split(RenderedDescription, "":"")[0])
| extend EventData = parse_xml(EventData).DataItem.EventData.Data
| mv-expand bagexpansion=array EventData
| evaluate bag_unpack(EventData)
| extend Key = tostring(column_ifexists('@Name', """")), Value = column_ifexists('#text', """")
| evaluate pivot(Key, any(Value), TimeGenerated, Source, EventLog, Computer, EventLevel, EventLevelName, EventID, UserName, RenderedDescription, MG, ManagementGroupName, Type, _ResourceId)
| extend RuleName = column_ifexists(""RuleName"", """"),
    TechniqueId = column_ifexists(""TechniqueId"", """"),
    TechniqueName = column_ifexists(""TechniqueName"", """"),
    Image = column_ifexists(""Image"", """"),
    PipeName = column_ifexists(""PipeName"", """")
| parse RuleName with * 'technique_id=' TechniqueId ',' * 'technique_name=' TechniqueName
// Look for Pipe related to querying the WID
| where PipeName == ""\\MICROSOFT##WID\\tsql\\query""
| extend process = split(Image, '\\', -1)[-1]
// Exclude expected processes
| where process !in (""Microsoft.IdentityServer.ServiceHost.exe"", ""Microsoft.Identity.Health.Adfs.PshSurrogate.exe"", ""AzureADConnect.exe"", ""Microsoft.Tri.Sensor.exe"", ""wsmprovhost.exe"",""mmc.exe"", ""sqlservr.exe"")
| extend Operation = RenderedDescription
| project-reorder TimeGenerated, EventType, Operation, process, Image, Computer, UserName
| extend HostCustomEntity = Computer, AccountCustomEntity = UserName"
"ab56ba7d-8d7b-4f97-95cd-b68ef07249cd","SUPERNOVA webshell","true","Detection","high","AzureMonitor(IIS)","W3CIISLog","1d","1d","Identifies SUPERNOVA webshell based on W3CIISLog data.
 References:
 - https://unit42.paloaltonetworks.com/solarstorm-supernova/'
","W3CIISLog
| where csMethod == 'GET'
| where isnotempty(csUriStem) and isnotempty(csUriQuery)
| where csUriStem contains ""logoimagehandler.ashx""
| where csUriQuery contains ""codes"" and csUriQuery contains ""clazz"" and csUriQuery contains ""method"" and csUriQuery contains ""args""
| extend timestamp = TimeGenerated, IPCustomEntity = cIP, HostCustomEntity = Computer, AccountCustomEntity = csUserName"
"0a429f9e-341a-4769-878a-bf40e4505600","NOBELIUM - Script payload stored in Registry","true","Detection","Medium","SecurityEvents","SecurityEvent","1d","1d","此查询标识进程执行命令行指示写入注册表值以允许稍后执行恶意脚本的时间。
 参考：https://www.microsoft.com/security/blog/2021/03/04/goldmax-goldfinder-sibot-analyzing-nobelium-malware","let cmdTokens0 = dynamic(['vbscript','jscript']);
let cmdTokens1 = dynamic(['mshtml','RunHTMLApplication']);
let cmdTokens2 = dynamic(['Execute','CreateObject','RegRead','window.close']);
SecurityEvent
| where TimeGenerated >= ago(14d)
| where EventID == 4688
| where CommandLine has @'\Microsoft\Windows\CurrentVersion'
| where not(CommandLine has_any (@'\Software\Microsoft\Windows\CurrentVersion\Run', @'\Software\Microsoft\Windows\CurrentVersion\RunOnce'))
// If you are receiving false positives, then it may help to make the query more strict by uncommenting one or both of the lines below to refine the matches
//| where CommandLine has_any (cmdTokens0)
//| where CommandLine has_all (cmdTokens1)
| where CommandLine has_all (cmdTokens2)
| project TimeGenerated, Computer, Account, Process, NewProcessName, CommandLine, ParentProcessName, _ResourceId
| extend timestamp = TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account"
"7fb8c95e-0483-4133-97c7-b1b413f86e7d","Web shell Detection","true","Hunting","none","AzureMonitor(IIS)","W3CIISLog","none","none","Web shells are script that when uploaded to a web server can be used for remote administration. 
Attackers often use web shells to obtain unauthorized access, escalate //privilege as well as further compromise the environment. 
The query detects web shells that use GET requests by keyword searches in URL strings. 
This is based out of sigma rules described //here (https://github.com/Neo23x0/sigma/blob/master/rules/web/web_webshell_keyword.yml). 
There could be some web sites like wikis with articles on os commands and pages that include the os //commands in the URLs that might cause FP.","let timeframe = ago(1d);
let command = ""(?i)net(1)?(.exe)?(%20){1,}user|cmd(.exe)?(%20){1,}/c(%20){1,}"";
W3CIISLog
| where TimeGenerated >= timeframe
| where csMethod == ""GET"" 
| where ( csUriQuery has ""whoami"" or csUriQuery matches regex command ) or 
        ( csUriStem has ""whoami"" or csUriStem matches regex command ) or
        ( csReferer has ""whoami"" or csReferer matches regex command )
| summarize StartTimeUtc = max(TimeGenerated), EndTimeUtc = min(TimeGenerated), ConnectionCount = count() 
by Computer, sSiteName, sIP, cIP, csUserName, csUriQuery, csMethod, scStatus, scSubStatus, scWin32Status
| extend timestamp = StartTimeUtc, IPCustomEntity = cIP, HostCustomEntity = Computer, AccountCustomEntity = csUserName"
"aba1642f-92b6-431f-b418-be47818f04be","Least Common Processes by Command Line","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","Looks across your environment for least common Process Command Lines, may be noisy and require allowlisting.  By ZanCo","let Allowlist = dynamic (['foo.exe', 'baz.exe']);
let Sensitivity = 5;
let StartDate = ago(7d);
let Duration = 7d;
SecurityEvent
| where EventID == 4688 and TimeGenerated > StartDate and TimeGenerated < (StartDate + Duration) and NewProcessName !endswith 'conhost.exe'
| extend ProcArray = split(NewProcessName, '\\')
// ProcArrayLength is Folder Depth
| extend ProcArrayLength = arraylength(ProcArray)
| extend LastIndex = ProcArrayLength - 1
| extend Proc = ProcArray[LastIndex]
| where Proc !in (Allowlist)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), TimesSeen = count(), HostCount = dcount(Computer), Hosts = makeset(Computer), UserCount = dcount(SubjectUserName), Users = makeset(SubjectUserName) by CommandLine
| where TimesSeen < Sensitivity
| extend timestamp = StartTimeUtc"
"0aedeb6f-274f-4488-8863-2646a52a350a","Azure Sentinel Analytics Rules Administrative Operations","true","Hunting","none","AzureActivity","AzureActivity","none","none","Identifies Azure Sentinel Analytics Rules administrative operations'
","let opValues = dynamic([""Microsoft.SecurityInsights/alertRules/write"", ""Microsoft.SecurityInsights/alertRules/delete""]);
// Azure Sentinel Analytics - Rule Create / Update / Delete
AzureActivity
| where Category == ""Administrative""
| where OperationNameValue in (opValues)
| where ActivitySubstatusValue in (""Created"", ""OK"")
| sort by TimeGenerated desc
| extend timestamp = TimeGenerated, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress"
"ebebfd68-9512-46e9-bf0e-b6b3cf4e9d80","Azure Active Directory signins from new locations","true","Hunting","none","AzureActiveDirectory","SigninLogs","none","none","本规则将识别所有在新的位置发起的AAD登录请求。 在密码喷射或暴力攻击的情况下，您可能会看到许多来自新地理位置的身份验证尝试","let starttime = 14d;
let endtime = 1d;
let countThreshold = 1;
SigninLogs
| where TimeGenerated >= ago(endtime)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), perIdentityAuthCount = count() 
by Identity, locationString = strcat(tostring(LocationDetails[""countryOrRegion""]), ""/"", tostring(LocationDetails[""state""]), ""/"", 
tostring(LocationDetails[""city""]), "";"" , tostring(LocationDetails[""geoCoordinates""]))
| summarize StartTimeUtc = min(StartTimeUtc), EndTimeUtc = max(EndTimeUtc), distinctAccountCount = count(), identityList=makeset(Identity) by locationString
| extend identityList = iff(distinctAccountCount<10, identityList, ""multiple (>10)"")
| join kind= anti (
SigninLogs
  | where TimeGenerated >= ago(starttime) and TimeGenerated < ago(endtime)
  | project locationString= strcat(tostring(LocationDetails[""countryOrRegion""]), ""/"", tostring(LocationDetails[""state""]), ""/"", 
  tostring(LocationDetails[""city""]), "";"" , tostring(LocationDetails[""geoCoordinates""]))
  | summarize priorCount = count() by locationString
) 
on locationString
// select threshold above which #new accounts from a new location is deemed suspicious
| where distinctAccountCount > countThreshold
| extend timestamp = StartTimeUtc"
"1a83c2e1-70f3-4373-9c41-4c268c002f60","Least Common Parent And Child Process Pairs","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","本规则在Windows安全日志中查找最不常见的父/子进程组合。可能会发现一些伪装成众所周知的进程名称的恶意活动","let Allowlist = dynamic (['foo.exe', 'baz.exe']);
let Sensitivity = 5;
let StartDate = ago(7d);
let Duration = 7d;
SecurityEvent
| where EventID == 4688 and TimeGenerated > StartDate and TimeGenerated < (StartDate + Duration) and isnotnull(ParentProcessName)
| extend ProcArray = split(NewProcessName, '\\'), ParentProcArray = split(ParentProcessName, '\\')
// ProcArrayLength is Folder Depth
| extend ProcArrayLength = arraylength(ProcArray), ParentProcArrayLength = arraylength(ParentProcArray)
| extend LastIndex = ProcArrayLength - 1, ParentLastIndex = ParentProcArrayLength - 1
| extend Proc = ProcArray[LastIndex], ParentProc = ParentProcArray[ParentLastIndex]
| where Proc !in (Allowlist)
| extend ParentChildPair = strcat(ParentProc , ' > ', Proc)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), TimesSeen = count(), HostCount = dcount(Computer), Hosts = makeset(Computer), UserCount = dcount(SubjectUserName), Users = makeset(SubjectUserName) by ParentChildPair
| where TimesSeen < Sensitivity
| extend timestamp = StartTimeUtc"
"1665261d-5dea-4dcc-bf71-930fe1ae9400","Modified domain federation trust settings","true","Detection","High","AzureActiveDirectory","AuditLogs","1d","1d","这将在用户或应用程序修改域上的联合设置或将域身份验证从托管更新为联合时发出警报。
例如，当出现新的 Active Directory 联合服务 (ADFS) TrustedRealm 对象（例如签名证书）时，将触发此警报, 被添加到域中。
对域联合设置的修改应该很少见。确认添加或修改的目标域/URL 是合法的管理员行为。
要了解授权用户为何可以更新 Office 365、Azure 或 Intune 中联合域的设置，请参阅：https://docs.microsoft.com/office365/troubleshoot/active-directory/update-federated-domain-office-365。
有关接受安全令牌的安全领域的详细信息，请参阅 ADFS 代理协议 (MS-ADFSPP) 规范：https://docs.microsoft.com/ openspecs/windows_protocols/ms-adfspp/e7b9ea73-1980-4318-96a6-da559486664b。
有关审计日志的更多信息，请参阅 https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities","(union isfuzzy=true
(
AuditLogs
| where OperationName =~ ""Set federation settings on domain""
//| where Result =~ ""success""   // commenting out, as it may be interesting to capture failed attempts
| mv-expand TargetResources
| extend modifiedProperties = parse_json(TargetResources).modifiedProperties
| mv-expand modifiedProperties
| extend targetDisplayName = tostring(parse_json(modifiedProperties).displayName)
| mv-expand AdditionalDetails
),
(
AuditLogs
| where OperationName =~ ""Set domain authentication""
//| where Result =~ ""success""   // commenting out, as it may be interesting to capture failed attempts
| mv-expand TargetResources
| extend modifiedProperties = parse_json(TargetResources).modifiedProperties
| mv-expand modifiedProperties
| extend targetDisplayName = tostring(parse_json(modifiedProperties).displayName), NewDomainValue=tostring(parse_json(modifiedProperties).newValue)
| where NewDomainValue has ""Federated""
)
)
| extend UserAgent = iff(AdditionalDetails.key == ""User-Agent"",tostring(AdditionalDetails.value),"""")
| extend InitiatingUserOrApp = iff(isnotempty(InitiatedBy.user.userPrincipalName),tostring(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.app.displayName))
| extend InitiatingIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), tostring(InitiatedBy.user.ipAddress), tostring(InitiatedBy.app.ipAddress))
| project-reorder TimeGenerated, OperationName, InitiatingUserOrApp, AADOperationType, targetDisplayName, Result, InitiatingIpAddress, UserAgent, CorrelationId, TenantId, AADTenantId
| extend timestamp = TimeGenerated, AccountCustomEntity = InitiatingUserOrApp, IPCustomEntity = InitiatingIpAddress"
"0ea1e387-a44f-4439-98f5-5c087b9fddf0","Azure Virtual Network Subnets Administrative Operations","true","Hunting","none","AzureActivity","AzureActivity","none","none","本规则将返回所有Azure 虚拟网络子网管理操作","let timeframe = 1d;
let opValues = dynamic([""Microsoft.Network/virtualNetworks/subnets/write""]);
// Creating Virtual Network Subnets
AzureActivity
| where TimeGenerated >= ago(timeframe)
| where Category == ""Administrative""
| where OperationNameValue in (opValues)
| where ActivitySubstatusValue == ""Created""
| sort by TimeGenerated desc
| extend AccountCustomEntity = Caller
| extend IPCustomEntity = CallerIpAddress"
"0f51284b-0154-41a3-9683-a1c44b832431","Azure Active Directory Hybrid Health AD FS Suspicious Application","true","Detection","Medium","AzureActivity","AzureActivity","1d","1d","此检测将 Azure 活动日志（管理类别）用于向 Azure AD 混合运行状况 AD FS 服务添加服务器实例或删除 AD FS 服务实例的可疑应用程序。
通常是 ID 为 cf6d7e68-f018-4e0a-a7b3-126e053fb88d  的 Azure AD Connect Health Agent 应用程序用于执行这些操作。","// Azure AD Connect Health Agent - cf6d7e68-f018-4e0a-a7b3-126e053fb88d
// Azure Active Directory Connect - cb1056e2-e479-49de-ae31-7812af012ed8
let appList = dynamic(['cf6d7e68-f018-4e0a-a7b3-126e053fb88d','cb1056e2-e479-49de-ae31-7812af012ed8']);
let operationNamesList = dynamic(['Microsoft.ADHybridHealthService/services/servicemembers/action','Microsoft.ADHybridHealthService/services/delete']);
AzureActivity
| where CategoryValue == 'Administrative'
| where ResourceProviderValue =~ 'Microsoft.ADHybridHealthService'
| where _ResourceId contains 'AdFederationService'
| where OperationNameValue in~ (operationNamesList)
| extend claimsJson = parse_json(Claims)
| extend AppId = tostring(claimsJson.appid)
| extend AccountName = tostring(claimsJson.name)
| where AppId !in (appList)
| project-away claimsJson
| extend timestamp = TimeGenerated, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress"
"136f5f7a-96ee-4039-93f9-ec170a5ebe35","Cscript script daily summary breakdown","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","本规则将返回虚拟机中运行的脚本的详细记录","let timeframe = 1d;
let ProcessCreationEvents=() {
let processEvents=SecurityEvent
| where EventID==4688
| project EventTime=TimeGenerated, ComputerName=Computer,AccountName=SubjectUserName, AccountDomain=SubjectDomainName,
FileName=tostring(split(NewProcessName, '\\')[-1]),  ProcessCommandLine = CommandLine, 
InitiatingProcessFileName=ParentProcessName,InitiatingProcessCommandLine="""",InitiatingProcessParentFileName="""";
processEvents;
};
// Daily summary of cscript activity ? extracting script name and parameters from commandline:
ProcessCreationEvents 
| where EventTime >= ago(timeframe)
| where FileName =~ ""cscript.exe""
// remove commandline switches
| project EventTime, ComputerName, AccountName, removeSwitches = replace(@""/+[a-zA-Z0-9:]+"", """", ProcessCommandLine)
// remove the leading cscript.exe process name 
| project EventTime, ComputerName, AccountName, CommandLine = trim(@""[a-zA-Z0-9\\:""""]*cscript(.exe)?("""")?(\s)+"", removeSwitches)
// extract the script name:
| project EventTime, ComputerName, AccountName, 
// handle case where script name is enclosed in "" characters or is not enclosed in quotes 
ScriptName= iff(CommandLine startswith @"""""""", 
extract(@""([:\\a-zA-Z_\-\s0-9\.()]+)(""""?)"", 0, CommandLine), 
extract(@""([:\\a-zA-Z_\-0-9\.()]+)(""""?)"", 0, CommandLine)), CommandLine 
| project EventTime, ComputerName, AccountName, ScriptName=trim(@"""""""", ScriptName) , ScriptNameLength=strlen(ScriptName), CommandLine 
// extract remainder of commandline as script parameters: 
| project EventTime, ComputerName, AccountName, ScriptName, ScriptParams = iff(ScriptNameLength < strlen(CommandLine), substring(CommandLine, ScriptNameLength +1), """")
| summarize min(EventTime), count() by ComputerName, AccountName, ScriptName, ScriptParams
| order by count_ asc nulls last 
| extend timestamp = min_EventTime, HostCustomEntity = ComputerName, AccountCustomEntity = AccountName"
"952d68a9-66f8-4f02-b8e5-67f62ebb90e0","New user created and added to the built-in administrators group","true","Detection","Low","SecurityEvents","SecurityEvent","1d","1d","Identifies when a user account was created and then added to the builtin Administrators group in the same day.
This should be monitored closely and all additions reviewed.","let timeframe = 1d;
SecurityEvent
| where TimeGenerated > ago(timeframe) 
| where EventID == 4720
| where AccountType == ""User""
| project CreatedUserTime = TimeGenerated, CreatedUserEventID = EventID, CreatedUserActivity = Activity, Computer = toupper(Computer), 
CreatedUser = tolower(TargetUserName), Domain = toupper(TargetDomainName), CreatedUserSid = TargetSid, AccountUsedToCreateUser = SubjectUserName
|join (
SecurityEvent 
| where TimeGenerated > ago(timeframe) 
| where AccountType == ""User""
// 4732 - A member was added to a security-enabled local group
| where EventID == 4732
//TargetSid is the builin Admins group: S-1-5-32-544
| where TargetSid == ""S-1-5-32-544""
| project GroupAddTime = TimeGenerated, GroupAddEventID = EventID, GroupAddActivity = Activity, Computer = toupper(Computer), GroupName = TargetUserName, 
Domain = toupper(TargetDomainName), GroupSid = TargetSid, UserAdded = SubjectUserName, UserAddedSid = SubjectUserSid, CreatedUser = tolower(SubjectUserName), 
CreatedUserSid = MemberSid
)
on CreatedUserSid
//Create User first, then the add to the group.
| project Computer, CreatedUserTime, CreatedUserEventID, CreatedUserActivity, CreatedUser, CreatedUserSid, Domain, GroupAddTime, GroupAddEventID, 
GroupAddActivity, AccountUsedToCreateUser, GroupName, GroupSid, UserAdded, UserAddedSid 
| extend timestamp = CreatedUserTime, AccountCustomEntity = CreatedUser, HostCustomEntity = Computer"
"5832883c-02b8-4741-8af4-ada79e6a9ddb","Gain Code Execution on ADFS Server via Remote WMI Execution","false","Detection","Medium","SecurityEvents","MultipleDataSources","1d","7d","此查询检测攻击者已获得通过远程 WMI 执行在 ADFS 服务器上执行代码的能力的实例。 为了使用此查询，您需要收集 Sysmon EventID 19、20 和 21。
如果您的工作区中没有 Sysmon 数据，此查询将引发错误说明：无法解析名为 '[@Name] 的标量表达式 ' 
有关如何在 Solorigate 中使用 WMI 的更多信息，请参阅 https://www.microsoft.com/security/blog/2021/01/20/deep-dive-into-the-solorigate-second-stage-activation-from- sunburst-to-teardrop-and-raindrop/。
该查询包含以下检测中的一些功能，用于查找潜在的恶意 ADFS 活动。 有关更多详细信息，请参阅： 
 ADFS 密钥导出 (Sysmon)：https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/ADFSKeyExportSysmon.yaml 
 ADFS DKM 主密钥导出：https ://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/ADFS-DKM-MasterKey-Export.yaml","let timeframe = 1d;
// Adjust for a longer timeframe for identifying ADFS Servers
let lookback = 6d;
// Identify ADFS Servers
let ADFS_Servers = (
Event
| where TimeGenerated > ago(timeframe+lookback)
| where Source == ""Microsoft-Windows-Sysmon""
| where EventID == 1
| extend EventData = parse_xml(EventData).DataItem.EventData.Data
| mv-expand bagexpansion=array EventData
| evaluate bag_unpack(EventData)
| extend Key=tostring(['@Name']), Value=['#text']
| evaluate pivot(Key, any(Value), TimeGenerated, Source, EventLog, Computer, EventLevel, EventLevelName, UserName, RenderedDescription, MG, ManagementGroupName, Type, _ResourceId)
| extend process = split(Image, '\\', -1)[-1]
| where process =~ ""Microsoft.IdentityServer.ServiceHost.exe""
| distinct Computer
| union isfuzzy=true (
SecurityEvent
| where TimeGenerated > ago(timeframe+lookback)
| where EventID == 4688 and SubjectLogonId != ""0x3e4""
| where ProcessName has ""Microsoft.IdentityServer.ServiceHost.exe""
| distinct Computer
)
| distinct Computer);
(union isfuzzy=true
(
SecurityEvent
| where TimeGenerated > ago(timeframe)
| where Computer in~ (ADFS_Servers)
| where ParentProcessName has 'wmiprvse.exe'
// Looking for rundll32.exe is based on intel from the blog linked in the description
// This can be commented out or altered to filter out known internal uses
| where CommandLine has_any ('rundll32') 
| project TimeGenerated, TargetAccount, CommandLine, Computer, Account, TargetLogonId
| extend timestamp = TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account
// Search for recent logons to identify lateral movement
| join kind= inner
(SecurityEvent
| where TimeGenerated > ago(timeframe)
| where EventID == 4624 and LogonType == 3
| where Account !endswith ""$""
| project TargetLogonId
) on TargetLogonId
),
(
Event
| where TimeGenerated > ago(timeframe)
| where Source == ""Microsoft-Windows-Sysmon""
// Check for WMI Events
| where Computer in~ (ADFS_Servers) and EventID in (19, 20, 21)
| extend EventData = parse_xml(EventData).DataItem.EventData.Data
| mv-expand bagexpansion=array EventData
| evaluate bag_unpack(EventData)
| extend Key=tostring(['@Name']), Value=['#text']
| evaluate pivot(Key, any(Value), TimeGenerated, Source, EventLog, Computer, EventLevel, EventLevelName, UserName, RenderedDescription, MG, ManagementGroupName, Type, _ResourceId)
| project TimeGenerated, EventType, Image, Computer, UserName
| extend timestamp = TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = UserName
)
)"
"10ae2e0a-f9d2-4112-896d-83ad10d36162","AD account with Don't Expire Password","true","Detection","Low","SecurityEvents","SecurityEvent","1d","1d","标识用户帐户何时在用户帐户属性中选择了“密码永不过期”设置。
这在标记为 UserAccountControl 的 EventData 项中的安全事件 4738 中指示，包含的值为 %%2089。%%2089 解析为 '不要使密码过期 - 已启用'","SecurityEvent
| where EventID == 4738
// 2089 value indicates the Don't Expire Password value has been set
| where UserAccountControl has ""%%2089"" 
| extend Value_2089 = iff(UserAccountControl has ""%%2089"",""'Don't Expire Password' - Enabled"", ""Not Changed"")
// 2050 indicates that the Password Not Required value is NOT set, this often shows up at the same time as a 2089 and is the recommended value.  This value may not be in the event. 
| extend Value_2050 = iff(UserAccountControl has ""%%2050"",""'Password Not Required' - Disabled"", ""Not Changed"")
// If value %%2082 is present in the 4738 event, this indicates the account has been configured to logon WITHOUT a password. Generally you should only see this value when an account is created and only in Event 4720: Account Creation Event.  
| extend Value_2082 = iff(UserAccountControl has ""%%2082"",""'Password Not Required' - Enabled"", ""Not Changed"")
| project StartTime = TimeGenerated, EventID, Activity, Computer, TargetAccount, TargetSid, AccountType, UserAccountControl, Value_2089, Value_2050, Value_2082, SubjectAccount
| extend timestamp = StartTime, AccountCustomEntity = TargetAccount, HostCustomEntity = Computer"
"ca7ee181-543d-4013-950c-e0cba5922850","Network endpoint to host executable correlation","true","Detection","Medium","TrendMicro","MultipleDataSources","1d","1d","Correlates blocked URLs hosting [malicious] executables with host endpoint data
to identify potential instances of executables of the same name having been recently run.","let timeframe = 1d;
let endpointData = 
(SecurityEvent
  | where TimeGenerated >= ago(timeframe) 
  | where EventID == 4688
  | extend shortFileName = tostring(split(NewProcessName, '\\')[-1])
  );
// Correlate suspect executables seen in TrendMicro rule updates with similar activity on endpoints
CommonSecurityLog
| where TimeGenerated >= ago(timeframe)
| where DeviceVendor =~ ""Trend Micro""
| where Activity =~ ""Deny List updated"" 
| where RequestURL endswith "".exe""
| project TimeGenerated, Activity , RequestURL , SourceIP, DestinationIP
| extend suspectExeName = tolower(tostring(split(RequestURL, '/')[-1]))
| join (endpointData) on $left.suspectExeName == $right.shortFileName 
| extend timestamp = TimeGenerated, IPCustomEntity = DestinationIP, AccountCustomEntity = TargetUserName, HostCustomEntity = Computer, URLCustomEntity = RequestURL"
"0b2ddc97-bdb4-48c2-a557-defbdfced653","Uncommon processes - bottom 5%","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","本规则将显示第一次运行的进程。 这些新进程可能是安装在主机上的良性新程序；但是，尤其是在通常稳定的环境中，这些新进程可能会提供已安装和运行的未经授权/恶意二文件。","let timeframe = 1d;
let ProcessCreationEvents=() {
let processEvents=SecurityEvent
| where EventID==4688
// filter out common randomly named files related to MSI installers and browsers
| where not(NewProcessName matches regex @""\\TRA[0-9A-Fa-f]{3}\.tmp"")
| where not(NewProcessName matches regex @""\\TRA[0-9A-Fa-f]{4}\.tmp"")
| where not(NewProcessName matches regex @""Installer\\MSI[0-9A-Fa-f]{3}\.tmp"")
| where not(NewProcessName matches regex @""Installer\\MSI[0-9A-Fa-f]{4}\.tmp"")
| project TimeGenerated, ComputerName=Computer, AccountName=SubjectUserName, AccountDomain=SubjectDomainName,
FileName=tostring(split(NewProcessName, '\\')[-1]), ProcessCommandLine = CommandLine, 
InitiatingProcessFileName=ParentProcessName, InitiatingProcessCommandLine="""", InitiatingProcessParentFileName="""";
processEvents;
};
let normalizedProcesses = ProcessCreationEvents 
| where TimeGenerated >= ago(timeframe)
// normalize guids
| project TimeGenerated, FileName = replace(""[0-9A-Fa-f]{8}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{12}"", ""<guid>"", FileName)
// normalize digits away
| project TimeGenerated, FileName=replace(@'\d', 'n', FileName); 
let freqs = normalizedProcesses
| summarize frequency=count() by FileName
| join kind= leftouter (
normalizedProcesses
| summarize Since=min(TimeGenerated), LastSeen=max(TimeGenerated) by FileName
) on FileName;
freqs 
| where frequency <= toscalar( freqs | serialize | project frequency | summarize percentiles(frequency, 5))
| order by frequency asc
| project FileName, frequency, Since, LastSeen 
// restrict results to unusual processes seen in last day 
| where LastSeen >= ago(1d)
| extend timestamp = LastSeen"
"5bc40748-0b0e-410e-854b-c4230d4fca79","Suspicious application consent for offline access","true","Detection","Low","AzureActiveDirectory","AuditLogs","1d","14d","本规则将在用户同意通过 OAuth 提供具有离线访问功能的以前未知的 Azure 应用程序时发出警报。脱机访问将为 Azure 应用程序提供对所列资源的访问权限，而无需进行双重身份验证","let detectionTime = 1d;
let joinLookback = 14d;
AuditLogs
| where TimeGenerated > ago(detectionTime)
| where LoggedByService =~ ""Core Directory""
| where Category =~ ""ApplicationManagement""
| where OperationName =~ ""Consent to application""
| where TargetResources has ""offline""
| extend AppDisplayName = TargetResources.[0].displayName
| extend AppClientId = tolower(TargetResources.[0].id)
//| where AppClientId !in ((externaldata(knownAppClientId:string, knownAppDisplayName:string)[@""https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/Microsoft.OAuth.KnownApplications.csv""] with (format=""csv"")))
| extend ConsentFull = TargetResources[0].modifiedProperties[4].newValue
| parse ConsentFull with * ""ConsentType: "" GrantConsentType "", Scope: "" GrantScope1 ""]"" *
| where ConsentFull contains ""offline_access"" and ConsentFull contains ""Files.Read"" or ConsentFull contains ""Mail.Read"" or ConsentFull contains ""Notes.Read"" or ConsentFull contains ""ChannelMessage.Read"" or ConsentFull contains ""Chat.Read"" or ConsentFull contains ""TeamsActivity.Read"" or ConsentFull contains ""Group.Read"" or ConsentFull contains ""EWS.AccessAsUser.All"" or ConsentFull contains ""EAS.AccessAsUser.All""
| where GrantConsentType != ""AllPrincipals"" // NOTE: we are ignoring if OAuth application was granted to all users via an admin - but admin due diligence should be audited occasionally
| extend GrantIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress)
| extend GrantInitiatedBy = iff(isnotempty(InitiatedBy.user.userPrincipalName),InitiatedBy.user.userPrincipalName, InitiatedBy.app.displayName)
| extend GrantUserAgent = iff(AdditionalDetails[0].key =~ ""User-Agent"", AdditionalDetails[0].value, """")
| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, GrantIpAddress, GrantUserAgent, AppClientId, OperationName, ConsentFull, CorrelationId
| join kind = leftouter (AuditLogs
| where TimeGenerated > ago(joinLookback)
| where LoggedByService =~ ""Core Directory""
| where Category =~ ""ApplicationManagement""
| where OperationName =~ ""Add service principal""
| extend AppClientId = tolower(TargetResources[0].id)
| extend AppReplyURLs = iff(TargetResources[0].modifiedProperties[1].newValue has ""AddressType"", TargetResources[0].modifiedProperties[1].newValue, """")
| distinct AppClientId, tostring(AppReplyURLs)
)
on AppClientId
| join kind = innerunique (AuditLogs
| where TimeGenerated > ago(joinLookback)
| where LoggedByService =~ ""Core Directory""
| where Category =~ ""ApplicationManagement""
| where OperationName =~ ""Add OAuth2PermissionGrant"" or OperationName =~ ""Add delegated permission grant""
| extend GrantAuthentication = tostring(TargetResources[0].displayName)
| extend GrantOperation = OperationName
| project GrantAuthentication, GrantOperation, CorrelationId
) on CorrelationId
| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, AppReplyURLs, GrantIpAddress, GrantUserAgent, AppClientId, GrantAuthentication, OperationName, GrantOperation, CorrelationId, ConsentFull"
"ef31e979-1ecb-4720-b28e-7f4c95e3443b","Solorigate Named Pipe","false","Detection","High","SecurityEvents","SecurityEvent","1d","1d","识别与 Solorigate 事件相关的命名管道 IOC 的各种数据馈送之间的匹配。对于此检测所需的 sysmon 事件，需要在 Sysmon 配置中配置命名管道事件的日志记录（事件 ID 17 和事件 ID 18）
 参考：https://techcommunity.microsoft.com/t5/azure-sentinel/solarwinds-post-compromise-hunting-with-azure-sentinel/ba-p/1995095","(union isfuzzy=true
(Event
| where Source == ""Microsoft-Windows-Sysmon""
| where EventID in (17,18)
| where EventData has '583da945-62af-10e8-4902-a8f205c72b2e'
| extend EventData = parse_xml(EventData).DataItem.EventData.Data
| mv-expand bagexpansion=array EventData
| evaluate bag_unpack(EventData)
| extend Key = tostring(column_ifexists('@Name', """")), Value = column_ifexists('#text', """")
| evaluate pivot(Key, any(Value), TimeGenerated, Source, EventLog, Computer, EventLevel, EventLevelName, EventID, UserName, MG, ManagementGroupName, _ResourceId)
| extend PipeName = column_ifexists(""PipeName"", """")
| extend Account = UserName
),
(
 SecurityEvent
| where EventID == '5145'
// %%4418 looks for presence of CreatePipeInstance value 
| where AccessList has '%%4418'     
| where RelativeTargetName has '583da945-62af-10e8-4902-a8f205c72b2e'
)
)
| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer"
"9a51d9d0-2441-48af-bbfb-1f8b7f9684be","Base64 encoded Windows process command-lines","true","Detection","Medium","SecurityEvents","SecurityEvent","1d","1d","Identifies instances of a base64 encoded PE file header seen in the process command line parameter.","let timeframe = 1d;
let ProcessCreationEvents=() {
let processEvents=SecurityEvent
| where EventID==4688
| where isnotempty(CommandLine)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count() by Computer, Account = SubjectUserName, AccountDomain = SubjectDomainName,
FileName = Process, CommandLine, ParentProcessName;
processEvents};
ProcessCreationEvents
| where CommandLine contains ""TVqQAAMAAAAEAAA""
| where StartTimeUtc >= ago(timeframe)
| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = Computer"
"a91f7aac-9876-409a-b235-7b387576fffb","Gain Code Execution on ADFS Server via SMB + Remote Service or Scheduled Task","true","Detection","Medium","SecurityEvents","SecurityEvent","1d","7d","此查询检测攻击者已获得通过 SMB 和远程服务或计划任务在 ADFS 服务器上执行代码的能力的实例。","let timeframe = 1d;
// Adjust for a longer timeframe for identifying ADFS Servers
let lookback = 6d;
// Identify ADFS Servers
let ADFS_Servers = (
SecurityEvent
| where TimeGenerated > ago(timeframe+lookback)
| where EventID == 4688 and SubjectLogonId != ""0x3e4""
| where ProcessName has ""Microsoft.IdentityServer.ServiceHost.exe""
| distinct Computer
);
SecurityEvent
| where TimeGenerated > ago(timeframe)
| where Computer in~ (ADFS_Servers)
| where Account !endswith ""$""
// Check for scheduled task events
| where EventID in (4697, 4698, 4699, 4700, 4701, 4702)
| extend EventDataParsed = parse_xml(EventData)
| extend SubjectLogonId = tostring(EventDataParsed.EventData.Data[3][""#text""])
// Check specifically for access to IPC$ share and PIPE\svcctl and PIPE\atsvc for Service Control Services and Schedule Control Services
| union ( 
    SecurityEvent
    | where TimeGenerated > ago(timeframe)
    | where Computer in~ (ADFS_Servers)
    | where Account !endswith ""$""
    | where EventID == 5145
    | where RelativeTargetName =~ ""svcctl"" or RelativeTargetName  =~ ""atsvc""
)
// Check for lateral movement
| join kind=inner
(SecurityEvent
| where TimeGenerated > ago(timeframe)
| where Account !endswith ""$""
| where EventID == 4624 and LogonType == 3
) on $left.SubjectLogonId == $right.TargetLogonId
| project TimeGenerated, Account, Computer, EventID, RelativeTargetName
| extend timestamp = TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account"
"31a3adea-b8be-4bbb-96eb-8561fbba69e9","AD user enabled and password not set within 48 hours","true","Detection","Low","SecurityEvents","SecurityEvent","1d","3d","标识何时使用默认密码启用帐户，并且密码未在 48 小时内由用户设置。
事件 4722 指示帐户已启用，并且在 48 小时内，没有发生事件 4723，表明有用户没有尝试设置密码。 
 这将显示48 小时后发生的任何尝试（成功或失败），这可能表明将密码设置过期时间太长。建议根据您的情况调整此时间段公司内部政策。","let starttime = 3d;
let SecEvents = materialize ( SecurityEvent | where TimeGenerated >= ago(starttime)
| where EventID in (4722,4723) | where TargetUserName !endswith ""$""
| project TimeGenerated, EventID, Activity, Computer, TargetAccount, TargetSid, SubjectAccount, SubjectUserSid);
let userEnable = SecEvents
| extend EventID4722Time = TimeGenerated
// 4722: User Account Enabled
| where EventID == 4722
| project Time_Event4722 = TimeGenerated, TargetAccount, TargetSid, SubjectAccount_Event4722 = SubjectAccount, SubjectUserSid_Event4722 = SubjectUserSid, Activity_4722 = Activity, Computer_4722 = Computer;
let userPwdSet = SecEvents
// 4723: Attempt made by user to set password
| where EventID == 4723
| project Time_Event4723 = TimeGenerated, TargetAccount, TargetSid, SubjectAccount_Event4723 = SubjectAccount, SubjectUserSid_Event4723 = SubjectUserSid, Activity_4723 = Activity, Computer_4723 = Computer;
userEnable | join kind=leftouter userPwdSet on TargetAccount, TargetSid
| extend PasswordSetAttemptDelta_Min = datetime_diff('minute', Time_Event4723, Time_Event4722)
| where PasswordSetAttemptDelta_Min > 2880 or isempty(PasswordSetAttemptDelta_Min)
| project-away TargetAccount1, TargetSid1
| extend Reason = @""User either has not yet attempted to set the initial password after account was enabled or it occurred after 48 hours""
| order by Time_Event4722 asc 
| extend timestamp = Time_Event4722, AccountCustomEntity = TargetAccount, HostCustomEntity = Computer_4722
| project-reorder Time_Event4722, Time_Event4723, PasswordSetAttemptDelta_Min, TargetAccount, TargetSid"
"6cf7d13d-c220-4f49-915d-418f398f5fd3","High count of connections by client IP on many ports","true","Detection","Medium","AzureMonitor(IIS)","W3CIISLog","1d","1d","Identifies when 30 or more ports are used for a given client IP in 10 minutes occurring on the IIS server.
This could be indicative of attempted port scanning or exploit attempt at internet facing web applications.  
This could also simply indicate a misconfigured service or device.
References:
IIS status code mapping - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0
Win32 Status code mapping - https://msdn.microsoft.com/library/cc231199.aspx","let timeframe = 1d;
let timeBin = 10m;
let portThreshold = 30;
W3CIISLog
| where TimeGenerated >= ago(timeframe)
| extend scStatusFull = strcat(scStatus, ""."",scSubStatus) 
// Map common IIS codes
| extend scStatusFull_Friendly = case(
scStatusFull == ""401.0"", ""Access denied."",
scStatusFull == ""401.1"", ""Logon failed."",
scStatusFull == ""401.2"", ""Logon failed due to server configuration."",
scStatusFull == ""401.3"", ""Unauthorized due to ACL on resource."",
scStatusFull == ""401.4"", ""Authorization failed by filter."",
scStatusFull == ""401.5"", ""Authorization failed by ISAPI/CGI application."",
scStatusFull == ""403.0"", ""Forbidden."",
scStatusFull == ""403.4"", ""SSL required."",
""See - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0"")
// Mapping to Hex so can be mapped using website in comments above
| extend scWin32Status_Hex = tohex(tolong(scWin32Status)) 
// Map common win32 codes
| extend scWin32Status_Friendly = case(
scWin32Status_Hex =~ ""775"", ""The referenced account is currently locked out and cannot be logged on to."",
scWin32Status_Hex =~ ""52e"", ""Logon failure: Unknown user name or bad password."",
scWin32Status_Hex =~ ""532"", ""Logon failure: The specified account password has expired."",
scWin32Status_Hex =~ ""533"", ""Logon failure: Account currently disabled."", 
scWin32Status_Hex =~ ""2ee2"", ""The request has timed out."", 
scWin32Status_Hex =~ ""0"", ""The operation completed successfully."", 
scWin32Status_Hex =~ ""1"", ""Incorrect function."", 
scWin32Status_Hex =~ ""2"", ""The system cannot find the file specified."", 
scWin32Status_Hex =~ ""3"", ""The system cannot find the path specified."", 
scWin32Status_Hex =~ ""4"", ""The system cannot open the file."", 
scWin32Status_Hex =~ ""5"", ""Access is denied."", 
scWin32Status_Hex =~ ""8009030e"", ""SEC_E_NO_CREDENTIALS"", 
scWin32Status_Hex =~ ""8009030C"", ""SEC_E_LOGON_DENIED"", 
""See - https://msdn.microsoft.com/library/cc231199.aspx"")
// decode URI when available
| extend decodedUriQuery = url_decode(csUriQuery)
// Count of attempts by client IP on many ports
| summarize makeset(sPort), makeset(decodedUriQuery), makeset(csUserName), makeset(sSiteName), makeset(sPort), makeset(csUserAgent), makeset(csMethod), makeset(csUriQuery), makeset(scStatusFull), makeset(scStatusFull_Friendly), makeset(scWin32Status_Hex), makeset(scWin32Status_Friendly), ConnectionsCount = count() by bin(TimeGenerated, timeBin), cIP, Computer, sIP
| extend portCount = arraylength(set_sPort)
| where portCount >= portThreshold
| project TimeGenerated, cIP, set_sPort, set_csUserName, set_decodedUriQuery, Computer, set_sSiteName, sIP, set_csUserAgent, set_csMethod, set_scStatusFull, set_scStatusFull_Friendly, set_scWin32Status_Hex, set_scWin32Status_Friendly, ConnectionsCount, portCount
| order by portCount
| extend timestamp = TimeGenerated, IPCustomEntity = cIP"
"bbf02e6d-76e2-4746-bd60-10bf8e3962bd","Rare processes run by Service accounts","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","本规则将识别出使用Windows 服务账号执行的罕见进程。","let timeframe = 1d;
let List1 = datatable(AccountName:string)[""MSSQLSERVER"", ""ReportServer"", ""MSDTSServer100"", ""IUSR""];         
// Provide a list of service account/ built-in accounts in an environment.
let List2 = SecurityEvent                                                                                   
// Self generating a list of Service account using event Id :4624
| where TimeGenerated >= ago(timeframe)
| where EventID == ""4624""
| where Account !contains ""$"" and Account !contains ""Local SYSTEM"" and Account !contains  ""Local SERVICE"" and Account !contains  ""Network SERVICE"" and Account !contains ""NT AUTHORITY"" and Account !contains ""NT-AUTORIT??T""
| where LogonType == ""5""                                                                                          
| extend AccountName = Account 
| distinct AccountName;
let Accounts = List1 | union (List2 | distinct AccountName);
let ProcessCreationEvents=() {
    let processEvents=SecurityEvent
	| where TimeGenerated >= ago(timeframe)
    | where EventID==4688
    // filter out common randomly named files related to MSI installers and browsers
    | where not(NewProcessName matches regex @""\\TRA[0-9A-Fa-f]{3}\.tmp"")
    | where not(NewProcessName matches regex @""\\TRA[0-9A-Fa-f]{4}\.tmp"")
    | where not(NewProcessName matches regex @""Installer\\MSI[0-9A-Fa-f]{3}\.tmp"")
    | where not(NewProcessName matches regex @""Installer\\MSI[0-9A-Fa-f]{4}\.tmp"")
    | project TimeGenerated, 
      ComputerName=Computer,
      AccountName=SubjectUserName, 
      AccountDomain=SubjectDomainName,
      FileName=tostring(split(NewProcessName, '\\')[-1]),
      ProcessCommandLine = CommandLine, 
      InitiatingProcessFileName=ParentProcessName,
      InitiatingProcessCommandLine="""",
      InitiatingProcessParentFileName="""";
    processEvents;
    };
    let normalizedProcesses = ProcessCreationEvents 
       // normalize guids
       | project TimeGenerated, AccountName, FileName = replace(""[0-9A-Fa-f]{8}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{12}"", ""<guid>"", FileName)
       // normalize digits away
       | project TimeGenerated, AccountName, FileName=replace(@'\d', 'n', FileName); 
let freqs = normalizedProcesses
    | summarize frequency = count() by FileName
    | join kind= leftouter (
       normalizedProcesses
       | summarize Since=min(TimeGenerated), LastSeen=max(TimeGenerated)  by FileName, AccountName
    ) on FileName;
   let Finalfreqs = freqs 
    | where frequency <= toscalar( freqs | serialize | project frequency | summarize percentiles(frequency, 10))
    | order by frequency asc
    | project FileName, frequency, Since, LastSeen , AccountName 
    // restrict results to unusual processes seen in last day 
    | where LastSeen >= ago(timeframe);
Accounts
    | join kind= inner (
        Finalfreqs
) on AccountName
| where frequency < 10
| project-away AccountName1
| extend AccountCustomEntity = AccountName"
"97867d7d-4891-454c-81ff-2fd6bcba9d87","Suspected LSASS Dump","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","Look for evidence of the LSASS process being dumped either using Procdump or comsvcs.dll. Often used by attackers to access credentials stored on a system.
Ref: https://risksense.com/blog/hidden-gems-in-windows-the-hunt-is-on/ & https://docs.microsoft.com/sysinternals/downloads/procdump'
","SecurityEvent 
| where EventID == 4688
| where CommandLine has_all (""procdump"", ""lsass"") or CommandLine has_all (""rundll32"", ""comsvcs"", ""MiniDump"")
| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer"
"1b72bd66-ad76-426e-9227-d76c20e01b94","New access credential added to Application or Service Principal","true","Detection","Medium","AzureActiveDirectory","AuditLogs","1h","1h","当管理员或应用程序所有者帐户向应用程序或服务主体添加新凭据时，该应用程序已存在验证 KeyCredential，这将发出警报。
如果威胁行为者获得对具有足够权限的帐户的访问权限并添加备用身份验证材料 触发此事件后，威胁行为者现在可以使用此凭据作为应用程序或服务主体进行身份验证。
有关 OAuth 凭据授予的其他信息可在 RFC 6749 第 4.4 节或 https://docs.microsoft.com/azure/active-directory/develop/v2-oauth2-client-creds-grant-flow
有关 AuditLogs 的更多信息，请参阅 https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities","AuditLogs
| where OperationName has_any (""Add service principal"", ""Certificates and secrets management"") // captures ""Add service principal"", ""Add service principal credentials"", and ""Update application - Certificates and secrets management"" events
| where Result =~ ""success""
| mv-expand target = TargetResources
| where tostring(InitiatedBy.user.userPrincipalName) has ""@"" or tostring(InitiatedBy.app.displayName) has ""@""
| extend targetDisplayName = tostring(TargetResources[0].displayName)
| extend targetId = tostring(TargetResources[0].id)
| extend targetType = tostring(TargetResources[0].type)
| extend keyEvents = TargetResources[0].modifiedProperties
| mv-expand keyEvents
| where keyEvents.displayName =~ ""KeyDescription""
| extend new_value_set = parse_json(tostring(keyEvents.newValue))
| extend old_value_set = parse_json(tostring(keyEvents.oldValue))
| where old_value_set != ""[]""
| extend diff = set_difference(new_value_set, old_value_set)
| where isnotempty(diff)
| parse diff with * ""KeyIdentifier="" keyIdentifier:string "",KeyType="" keyType:string "",KeyUsage="" keyUsage:string "",DisplayName="" keyDisplayName:string ""]"" *
| where keyUsage == ""Verify""  or keyUsage == """"
| extend UserAgent = iff(AdditionalDetails[0].key == ""User-Agent"",tostring(AdditionalDetails[0].value),"""")
| extend InitiatingUserOrApp = iff(isnotempty(InitiatedBy.user.userPrincipalName),tostring(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.app.displayName))
| extend InitiatingIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), tostring(InitiatedBy.user.ipAddress), tostring(InitiatedBy.app.ipAddress))
// The below line is currently commented out but Azure Sentinel users can modify this query to show only Application or only Service Principal events in their environment
//| where targetType =~ ""Application"" // or targetType =~ ""ServicePrincipal""
| project-away diff, new_value_set, old_value_set
| project-reorder TimeGenerated, OperationName, InitiatingUserOrApp, InitiatingIpAddress, UserAgent, targetDisplayName, targetId, targetType, keyDisplayName, keyType, keyUsage, keyIdentifier, CorrelationId, TenantId
| extend timestamp = TimeGenerated, AccountCustomEntity = InitiatingUserOrApp, IPCustomEntity = InitiatingIpAddress"
"6ffc0461-4884-4555-b6bb-2a8f27a16510","Alerts With This Process","true","Hunting","none","AzureSecurityCenter","SecurityAlert","none","none","本规则将返回来自给定进程相关的任何Azure安全中的的警报,默认查询区间是过去3天","let GetAllAlertsWithProcess = (suspiciousEventTime:datetime, v_Process:string){
let v_StartTime = suspiciousEventTime-1d;
let v_EndTime = suspiciousEventTime+1d;
SecurityAlert
| where TimeGenerated between (v_StartTime .. v_EndTime)
| where ExtendedProperties contains v_Process or Entities contains v_Process
| extend Extprop = parsejson(ExtendedProperties)
| extend ProcessName = parse_json(ExtendedProperties).[""Suspicious Process""]
| extend Computer = iff(isnotempty(toupper(tostring(Extprop[""Compromised Host""]))), toupper(tostring(Extprop[""Compromised Host""])), tostring(parse_json(Entities)[0].HostName))
| extend Account = iff(isnotempty(tolower(tostring(Extprop[""User Name""]))), tolower(tostring(Extprop[""User Name""])), tolower(tostring(Extprop[""user name""])))
| extend IpAddress = tostring(parse_json(ExtendedProperties).[""Client Address""]) 
| project TimeGenerated, AlertName, ProcessName, Computer, Account, IpAddress, ExtendedProperties 
| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress
| top 10 by TimeGenerated desc nulls last
};
// change datetime value and <processname> value below
GetAllAlertsWithProcess(now(), ""{processname}"")"
"2f52689e-477b-46ea-b2e0-8569ab141928","Failed host logons but success logon to AzureAD","true","Detection","Medium","AzureActiveDirectory","MultipleDataSources","1d","1d","本规则将对从同一个 IP 地址尝试多次虚拟机SSH 的失败登录尝（默认为 5）但同时出现该IP通过了AAD账号的成功登录","let timeframe = 1d;
//Adjust this threshold to fit environment
let signin_threshold = 5; 
//Make a list of IPs with failed Windows host logins above threshold
let win_fails = 
SecurityEvent
| where TimeGenerated >= ago(timeframe)
| where EventID == 4625
| where LogonType in (10, 7, 3)
| where IpAddress != ""-""
| summarize count() by IpAddress
| where count_ > signin_threshold
| summarize make_list(IpAddress);
//Make a list of IPs with failed *nix host logins above threshold
let nix_fails = 
Syslog
| where TimeGenerated > ago(timeframe)
| where Facility contains 'auth' and ProcessName != 'sudo'
| extend SourceIP = extract(""(([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.(([0-9]{1,3})))"",1,SyslogMessage)
| where SourceIP != """" and SourceIP != ""127.0.0.1""
| summarize count() by SourceIP
| where count_ > signin_threshold
| summarize make_list(SourceIP);
//See if any of the IPs with failed host logins hve had a sucessful Azure AD login
SigninLogs
| where TimeGenerated > ago(timeframe)
| where ResultType !in (""0"", ""50125"", ""50140"")
| where IPAddress in (win_fails) or IPAddress in (nix_fails)
| extend Reason=  ""Multiple failed host logins from IP address with successful Azure AD login""
| extend timstamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress"
"17683fc3-3d2c-4c6b-abf3-d1b074328549","HIDS weak password","true","Detection","Low","HIDS","Syslog","10m","10m","本规则检测HIDS弱密码风险日志","Syslog
| where Facility == 'local0'
| where ProcessName =~ 'qtAlert'
| where SyslogMessage contains 'weak_pwd'
| extend rawmesssage = iff(SyslogMessage contains 'message repeated', substring(SyslogMessage,indexof(SyslogMessage,'times: [')+8,strlen(SyslogMessage)-indexof(SyslogMessage,'times: [')-9),SyslogMessage)
| extend alertmessage = split(rawmesssage, ' ')
| mv-expand with_itemindex=Index alertmessage
| extend properties = split(alertmessage,'=')
| extend pname = tostring(properties[0])
| extend pvalue =  trim(@'""', tostring(properties[1]))
| extend AlertDetails = pack(pname, pvalue) 
| summarize alert_bag = make_bag(AlertDetails) by rawmesssage, Computer, EventTime
| extend log_type = tostring(alert_bag.log_type), risk_name=tostring(alert_bag.risk_name), host_name = tostring(alert_bag.host_name), group_name = tostring(alert_bag.group_name),  internal_ip = tostring(alert_bag.internal_ip), external_ip = tostring(alert_bag.external_ip),
comid = tostring(alert_bag.comid), group = tostring(alert_bag.group),  agent_id = tostring(alert_bag.agent_id), app = tostring(alert_bag.app), account = tostring(alert_bag.account), acct_type = tostring(alert_bag.acct_type), acct_status = tostring(alert_bag.acct_status), datatype = tostring(alert_bag.datatype)
| extend Alert_severity  = ""低""
| extend EventSource = 'HIDS'
| summarize Repeated = count(), arg_min(EventTime, *) by comid, group, agent_id
| project log_type,risk_name,event_type = datatype,EventTime,EventSource,Alert_severity,host_name,internal_ip,external_ip,app,account,acct_type,acct_status,group_name,comid,group,agent_id,alert_bag"
"f57ef5a7-4b21-4cec-bf8e-9555579eb0ce","HIDS security patch risk events","true","Detection","Low","HIDS","Syslog","10m","10m","本规则检测HIDS安全补丁风险日志","Syslog
| where Facility == 'local0'
| where ProcessName =~ 'qtAlert'
| where SyslogMessage contains 'security_patch'
| extend rawmesssage = iff(SyslogMessage contains 'message repeated', substring(SyslogMessage,indexof(SyslogMessage,'times: [')+8,strlen(SyslogMessage)-indexof(SyslogMessage,'times: [')-9),SyslogMessage)
| extend alertmessage = split(rawmesssage, ' ')
| mv-expand with_itemindex=Index alertmessage
| extend properties = split(alertmessage,'=')
| extend pname = tostring(properties[0])
| extend pvalue =  trim(@'""', tostring(properties[1]))
| extend AlertDetails = pack(pname, pvalue) 
| summarize alert_bag = make_bag(AlertDetails) by rawmesssage, Computer, EventTime
| extend log_type = tostring(alert_bag.log_type), risk_name=tostring(alert_bag.risk_name), host_name = tostring(alert_bag.host_name), group_name = tostring(alert_bag.group_name),  internal_ip = tostring(alert_bag.internal_ip), external_ip = tostring(alert_bag.external_ip),
comid = tostring(alert_bag.comid), group = tostring(alert_bag.group),  agent_id = tostring(alert_bag.agent_id), serv_impact = tostring(alert_bag.serv_impact), cves = tostring(alert_bag.cves), cvss_score = tostring(alert_bag.cvss_score), datatype = tostring(alert_bag.datatype)
| extend Alert_severity  = ""低""
| extend EventSource = 'HIDS'
| summarize Repeated = count(), arg_min(EventTime, *) by comid, group, agent_id
| project log_type,risk_name,event_type = datatype,EventTime,EventSource,Alert_severity,host_name,internal_ip,external_ip,serv_impact,cves,cvss_score,group_name,comid,group,agent_id,alert_bag"
"6e411fa4-ee81-41f4-ab64-ea9980ad6b4b","Granting permissions to account","true","Hunting","none","AzureActivity","AzureActivity","none","none","本规则将显示用户授予他人访问 azure 资源和每个帐户的权限的源IP地址。 如果实际操作不是来自该 IP 地址，则可能值得调查。","let timeframe = 7d;
let roleassingmentactions = dynamic([""Microsoft.Authorization/classicadministrators/write"",""Microsoft.Authorization/roleAssignments/write""]);
AzureActivity
| where TimeGenerated >= ago(timeframe)
| where OperationName in~ (roleassingmentactions)
| where ActivityStatus == ""Succeeded"" 
| project Caller, CallerIpAddress
| evaluate basket()
| extend AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress"
"5704fb7a-f2bc-4690-af98-224f4ec68dd7","Brute Force Attack against GitHub Account","true","Detection","Medium","AzureActiveDirectory","SigninLogs","1d","1d","本规则适用于使用SSO集成GitHub.com账号访问，检测到 Github用户登录尝试失败的突然增加会发出告警","let LearningPeriod = 7d; 
let BinTime = 1h; 
let RunTime = 1h; 
let StartTime = 1h; 
let NumberOfStds = 3; 
let MinThreshold = 10.0; 
let EndRunTime = StartTime - RunTime; 
let EndLearningTime = StartTime + LearningPeriod; 
let GitHubFailedSSOLogins = (SigninLogs 
| where AppDisplayName contains ""GitHub"" 
| where ResultType == 50056); 
GitHubFailedSSOLogins 
| where TimeGenerated between (ago(EndLearningTime) .. ago(StartTime)) 
| summarize FailedLoginsCountInBinTime = count() by User = Identity, bin(TimeGenerated, BinTime) 
| summarize AvgOfFailedLoginsInLearning = avg(FailedLoginsCountInBinTime), StdOfFailedLoginsInLearning = stdev(FailedLoginsCountInBinTime) by User 
| extend LearningThreshold = max_of(AvgOfFailedLoginsInLearning + StdOfFailedLoginsInLearning * NumberOfStds, MinThreshold) 
| join kind=innerunique ( 
  GitHubFailedSSOLogins 
  | where TimeGenerated between (ago(StartTime) .. ago(EndRunTime)) 
  | summarize FailedLoginsCountInRunTime = count() by User = Identity 
) on User 
| where FailedLoginsCountInRunTime > LearningThreshold
//| extend AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress"
"42fdfe16-bc43-4764-ad5a-919ff6f0277b","Potential Kerberoasting","true","Detection","Medium","SecurityEvents","SecurityEvent","1h","1d","A service principal name (SPN) is used to uniquely identify a service instance in a Windows environment. 
Each SPN is usually associated with a service account. Organizations may have used service accounts with weak passwords in their environment. 
An attacker can try requesting Kerberos ticket-granting service (TGS) service tickets for any SPN from a domain controller (DC) which contains 
a hash of the Service account. This can then be used for offline cracking. This hunting query looks for accounts that are generating excessive 
requests to different resources within the last hour compared with the previous 24 hours.  Normal users would not make an unusually large number 
of request within a small time window. This is based on 4769 events which can be very noisy so environment based tweaking might be needed.","let starttime = 1d;
let endtime = 1h;
let prev23hThreshold = 4;
let prev1hThreshold = 15;
let Kerbevent =
SecurityEvent
| where TimeGenerated >= ago(starttime)
| where EventID == 4769
| parse EventData with * 'TicketEncryptionType"">' TicketEncryptionType ""<"" *
| where TicketEncryptionType == '0x17'
| parse EventData with * 'TicketOptions"">' TicketOptions ""<"" *
| where TicketOptions == '0x40810000'
| parse EventData with * 'Status"">' Status ""<"" *
| where Status == '0x0'
| parse EventData with * 'ServiceName"">' ServiceName ""<"" *
| where ServiceName !contains ""$"" and ServiceName !contains ""krbtgt"" 
| parse EventData with * 'TargetUserName"">' TargetUserName ""<"" *
| where TargetUserName !contains ""$@"" and TargetUserName !contains ServiceName
| parse EventData with * 'IpAddress"">::ffff:' ClientIPAddress ""<"" *;
let Kerbevent23h = Kerbevent
| where TimeGenerated >= ago(starttime) and TimeGenerated < ago(endtime)
| summarize ServiceNameCountPrev23h = dcount(ServiceName), ServiceNameSet23h = makeset(ServiceName) 
by Computer, TargetUserName, ClientIPAddress, TicketOptions, TicketEncryptionType, Status
| where ServiceNameCountPrev23h < prev23hThreshold;
let Kerbevent1h = 
Kerbevent
| where TimeGenerated >= ago(endtime)
| summarize min(TimeGenerated), max(TimeGenerated), ServiceNameCountPrev1h = dcount(ServiceName), ServiceNameSet1h = makeset(ServiceName) 
by Computer, TargetUserName, ClientIPAddress, TicketOptions, TicketEncryptionType, Status;
Kerbevent1h 
| join kind=leftanti
(
Kerbevent23h
) on TargetUserName
// Threshold value set above is based on testing, this value may need to be changed for your environment.
| where ServiceNameCountPrev1h > prev1hThreshold
| project StartTimeUtc = min_TimeGenerated, EndTimeUtc = max_TimeGenerated, TargetUserName, Computer, ClientIPAddress, TicketOptions, 
TicketEncryptionType, Status, ServiceNameCountPrev1h, ServiceNameSet1h
| extend timestamp = StartTimeUtc, AccountCustomEntity = TargetUserName, HostCustomEntity = Computer, IPCustomEntity = ClientIPAddress"
"017a0ac1-285a-4b6a-9c3c-e9b265e8774c","Check critical ports opened to the entire internet","true","Hunting","none","WAF","AzureDiagnostics","none","none","本规则将扫描所有关键端口的WAF规则，列出不符合安全要求分WAF policy。例如： sourceIp 为'Any' (这意味着它们对所有人开放。 关键端口不应该对所有人开放，应该过滤)","//Check critical ports opened to the entire internet
AzureDiagnostics
| where Category == ""NetworkSecurityGroupEvent"" 
| where direction_s == ""In"" 
| where conditions_destinationPortRange_s in (
""22"",""22-22""          //SSH
,""3389"",""3389-3389""   //RDP
,""137"",""137-137""      //NetBIOS
,""138"",""138-138""      //NetBIOS
,""139"",""139-139""      //SMB
,""53"",""53-53""         //DNS
,""3020"",""3020-3020""   //CIFS
,""3306"",""3306-3306""   //MySQL
,""1521"",""1521-1521""   //Oracle Database
,""2483"",""2483-2483""   //Oracle Database
,""5432"",""5432-5432""   //PostgreSQL
,""389"",""389-389""      //LDAP
,""27017"",""27017-27017""//MongoDB
,""20"",""20-20""         //FTP
,""21"",""21-21""         //FTP
,""445"",""445-445""      //Active Directory
,""161"",""161-161""      //SNMP
,""25"",""25-25""         //SMTP
)
 or (conditions_destinationPortRange_s == ""0-65535"" and conditions_sourcePortRange_s == ""0-65535"")
| where priority_d < 65000    //Not to check the Azure defaults
| where conditions_sourceIP_s == ""0.0.0.0/0,0.0.0.0/0"" or conditions_sourceIP_s == ""0.0.0.0/0"" //With rules Any/Any
| where type_s !~ ""block""
| order by TimeGenerated desc
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count() by OperationName, systemId_g, vnetResourceGuid_g, subnetPrefix_s, macAddress_s, primaryIPv4Address_s, ruleName_s,
 direction_s, priority_d, type_s, conditions_destinationIP_s, conditions_destinationPortRange_s, conditions_sourceIP_s, conditions_sourcePortRange_s, ResourceId"
"2eba71bb-02c1-437c-9ca1-0155edc9d529","New internet-exposed SSH endpoints","true","Detection","Medium","Syslog","Syslog","1d","7d","本规则用于检查 Syslog，当发现虚拟机的登录行为是之前所有登录都是从私有网络发起。但突然出现了一个从共有网络发起的SSH登录，将发起告警","let PrivateIPregex = @'^127\.|^10\.|^172\.1[6-9]\.|^172\.2[0-9]\.|^172\.3[0-1]\.|^192\.168\.'; 
let avgthreshold = 0;
let probabilityLimit = 0.01;
let startime = 7d;
let ssh_logins = Syslog
| where TimeGenerated >= ago(startime)
| where Facility contains ""auth"" and ProcessName =~ ""sshd""
| where SyslogMessage has ""Accepted""
| extend SourceIP = extract(""(([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.(([0-9]{1,3})))"",1,SyslogMessage) 
| where isnotempty(SourceIP)
| extend ipType = iff(SourceIP matches regex PrivateIPregex,""private"" ,""public"");
ssh_logins 
| summarize privatecount=countif(ipType==""private""), publiccount=countif(ipType==""public"") by HostName, HostIP, bin(EventTime, 1d)
| summarize 
publicIPLoginHistory  = make_list(pack('IPCount', publiccount,  'logon_time', EventTime)),
privateIPLoginHistory = make_list(pack('IPCount', privatecount, 'logon_time', EventTime)) by HostName, HostIP
| mv-apply publicIPLoginHistory = publicIPLoginHistory on
(
    order by todatetime(publicIPLoginHistory['logon_time']) asc
    | summarize publicIPLoginCountList=make_list(toint(publicIPLoginHistory['IPCount'])), publicAverage=avg(toint(publicIPLoginHistory['IPCount'])), publicStd=stdev(toint(publicIPLoginHistory['IPCount'])), maxPublicLoginCount=max(toint(publicIPLoginHistory['IPCount']))
)
| mv-apply privateIPLoginHistory = privateIPLoginHistory on
(
    order by todatetime(privateIPLoginHistory['logon_time']) asc
    | summarize privateIPLoginCountList=make_list(toint(privateIPLoginHistory['IPCount'])), privateAverage=avg(toint(privateIPLoginHistory['IPCount'])), privateStd=stdev(toint(privateIPLoginHistory['IPCount']))
)
// Some logins from private IPs
| where privateAverage > avgthreshold
// There is a non-zero number of logins from public IPs
| where publicAverage > avgthreshold
// Approximate probability of seeing login from a public IP is < 1%
| extend probabilityPublic = publicAverage / (privateAverage + publicAverage)
| where probabilityPublic < probabilityLimit
// Today has the highest number of logins from public IPs that we've seen in the last week
| extend publicLoginCountToday = publicIPLoginCountList[-1]
| where publicLoginCountToday >= maxPublicLoginCount
| extend HostCustomEntity = HostName
// Optionally retrieve the original raw data for those logins that we've identified as potentially suspect
// | join kind=rightsemi (
//   ssh_logins
//  | where ipType == ""public""
//  ) on HostName"
"195b70a5-49dc-4bd8-8f32-7e8bcba39cf2","Rare RDP Connections","true","Detection","Medium","SecurityEvents","SecurityEvent","1d","14d","Identifies when an RDP connection is new or rare related to any logon type by a given account today based on comparison with the previous 14 days.
RDP connections are indicated by the EventID 4624 with LogonType = 10","let starttime = 14d;
let endtime = 1d;
SecurityEvent
| where TimeGenerated >= ago(endtime) 
| where EventID == 4624 and LogonType == 10
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), ConnectionCount = count() 
by Account = tolower(Account), Computer = toupper(Computer), IpAddress, AccountType, Activity, LogonTypeName, ProcessName
// use left anti to exclude anything from the previous 14 days that is not rare
| join kind=leftanti (
SecurityEvent
| where TimeGenerated between (ago(starttime) .. ago(endtime))
| where EventID == 4624
| summarize by Computer = toupper(Computer), IpAddress, Account = tolower(Account)
) on Account, Computer
| summarize StartTime = min(StartTime), EndTime = max(EndTime), ConnectionCount = sum(ConnectionCount)  
by Account, Computer, IpAddress, AccountType, Activity, LogonTypeName, ProcessName
| extend timestamp = StartTime, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress"
"d6be7bed-3a22-48e4-a9a4-ee029e4bcb26","New CloudShell User","false","Detection","Low","AzureActivity","AzureActivity","1d","1d","标识用户首次创建 Azure CloudShell 的时间。 监控此活动以确保只有预期用户在使用 CloudShell。","let match_window = 3m;
AzureActivity
| where ResourceGroup has ""cloud-shell""
| where (OperationNameValue =~ ""Microsoft.Storage/storageAccounts/listKeys/action"") 
| where ActivityStatusValue == ""Success""
| extend TimeKey = bin(TimeGenerated, match_window), AzureIP = CallerIpAddress
| join kind = inner
(AzureActivity
| where ResourceGroup has ""cloud-shell""
| where (OperationNameValue =~ ""Microsoft.Storage/storageAccounts/write"") 
| extend TimeKey = bin(TimeGenerated, match_window), UserIP = CallerIpAddress
) on Caller, TimeKey
| summarize count() by TimeKey, Caller, ResourceGroup, SubscriptionId, TenantId, AzureIP, UserIP, HTTPRequest, Type, Properties, CategoryValue, OperationList = strcat(OperationNameValue, ' , ', OperationNameValue1)"
"bbe3590c-c914-4180-91f0-52821dee195d","Anomalous User Agent connection attempt","true","Detection","Low","AzureMonitor(IIS)","W3CIISLog","1d","1d","Identifies connection attempts (success or fail) from clients with very short or very long User Agent strings and with less than 100 connection attempts.","let timeframe = 1d;
let short_uaLength = 5;
let long_uaLength = 1000;
let c_threshold = 100;
W3CIISLog 
| where TimeGenerated >= ago(timeframe)
// Exclude local IPs as these create noise
| where cIP !startswith ""192.168."" and cIP != ""::1""
| where isnotempty(csUserAgent) and csUserAgent !in~ (""-"", ""MSRPC"") and (string_size(csUserAgent) <= short_uaLength or string_size(csUserAgent) >= long_uaLength)
| extend csUserAgent_size = string_size(csUserAgent)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ConnectionCount = count() by Computer, sSiteName, sPort, csUserAgent, csUserAgent_size, csUserName , csMethod, csUriStem, sIP, cIP, scStatus, scSubStatus, scWin32Status
| where ConnectionCount < c_threshold
| extend timestamp = StartTimeUtc, AccountCustomEntity = csUserName, HostCustomEntity = Computer, IPCustomEntity = cIP"
"e3537b78-8bb8-4bd7-b006-dec67d4708ee","Process executed from binary hidden in Base64 encoded file","true","Detection","Medium","SecurityEvents","SecurityEvent","1d","1d","Encoding malicious software is a technique used to obfuscate files from detection. 
The first CommandLine component is looking for Python decoding base64. 
The second CommandLine component is looking for Bash/sh command line base64 decoding.
The third one is looking for Ruby decoding base64.","let timeframe = 1d;
let ProcessCreationEvents=() {
let processEvents=SecurityEvent
| where EventID==4688
| where isnotempty(CommandLine)
| project TimeGenerated, Computer, Account = SubjectUserName, AccountDomain = SubjectDomainName, FileName = Process, CommandLine, ParentProcessName;
processEvents;
};
ProcessCreationEvents 
| where TimeGenerated > ago(timeframe) 
| where CommandLine contains "".decode('base64')""
        or CommandLine contains ""base64 --decode""
        or CommandLine contains "".decode64("" 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), CountToday = count() by Computer, Account, AccountDomain, FileName, CommandLine, ParentProcessName 
| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = Computer"
"61f20930-c228-4801-bdc4-88ab2f35c969","Malware in the recycle bin","true","Detection","Medium","SecurityEvents","SecurityEvent","1d","1d","Identifies malware that has been hidden in the recycle bin.
References: https://azure.microsoft.com/blog/how-azure-security-center-helps-reveal-a-cyberattack/.","let timeframe = 1d;
let procList = dynamic([""cmd.exe"",""ftp.exe"",""schtasks.exe"",""powershell.exe"",""rundll32.exe"",""regsvr32.exe"",""msiexec.exe""]);
let ProcessCreationEvents=() {
let processEvents=SecurityEvent
| where EventID==4688
| where isnotempty(CommandLine)
| project TimeGenerated, Computer, Account = SubjectUserName, AccountDomain = SubjectDomainName, NewProcessName,
FileName = Process, CommandLine,  ParentProcessName;
processEvents};
ProcessCreationEvents 
| where TimeGenerated >= ago(timeframe)
| where FileName in~ (procList)
| where CommandLine contains "":\\recycler""
| project StartTimeUtc = TimeGenerated, Computer, Account, NewProcessName, FileName, CommandLine, ParentProcessName
| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = Computer"
"226ef21b-14c9-482b-a7ae-294828053e1c","Squid malformed requests","true","Hunting","none","Syslog","Syslog","none","none","本规则将标识出最近14天内进程名包含'squid'的可疑进程","let timeframe = 14d;
Syslog
| where TimeGenerated >= ago(timeframe) 
| where ProcessName contains ""squid""
| extend URL = extract(""(([A-Z]+ [a-z]{4,5}:\\/\\/)|[A-Z]+ )([^ :]*)"",3,SyslogMessage), 
         SourceIP = extract(""([0-9]+ )(([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3}))"",2,SyslogMessage), 
         Status = extract(""(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))"",1,SyslogMessage), 
         HTTP_Status_Code = extract(""(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))/([0-9]{3})"",8,SyslogMessage),
         User = extract(""(CONNECT |GET )([^ ]* )([^ ]+)"",3,SyslogMessage),
         RemotePort = extract(""(CONNECT |GET )([^ ]*)(:)([0-9]*)"",4,SyslogMessage),
         Domain = extract(""(([A-Z]+ [a-z]{4,5}:\\/\\/)|[A-Z]+ )([^ :\\/]*)"",3,SyslogMessage),
         Bytes = toint(extract(""([A-Z]+\\/[0-9]{3} )([0-9]+)"",2,SyslogMessage)),
         contentType = extract(""([a-z/]+$)"",1,SyslogMessage)
| extend TLD = extract(""\\.[a-z]*$"",0,Domain)
| where Domain !contains '.' and isnotempty(Domain)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), badRequestCount = count() by Domain, SourceIP, User, URL
| order by badRequestCount desc
| extend timestamp = StartTimeUtc, AccountCustomEntity = User, IPCustomEntity = SourceIP, URLCustomEntity = URL"
"89c2f27c-f99f-49c4-a456-b6e616715ba3","Failed logon attempts in authpriv","true","Detection","Medium","Syslog","Syslog","1h","1h","本规则将检查 Syslog authpriv 日志，如果出现来自未知用户的失败登录尝试超过阈值（默认阈值为 15）将产生 报警。 表明存在就可能的暴力破解","let startdate = 1h;
let threshold = 15;
// Below pulls messages from syslog-authpriv logs where there was an authentication failure with an unknown user.
// IP address of system attempting logon is also extracted from the SyslogMessage field. Some of these messages
// are aggregated.
let authfail = Syslog
| where TimeGenerated >= ago(startdate)     
| where Facility =~ ""authpriv""   // looks at authpriv messages
| where SyslogMessage contains ""authentication failure"" and SyslogMessage contains "" uid=0""
| parse SyslogMessage with * ""rhost="" ExternalIP
| project TimeGenerated, Computer, ProcessName, HostIP, ExternalIP, ProcessID;  
// Below pulls messages from syslog-authpriv logs that show each instance an unknown user tried to logon. 
let userfail = Syslog 
| where TimeGenerated >= ago(startdate)
| where Facility =~ ""authpriv"" 
| where SyslogMessage contains ""user unknown""
| project TimeGenerated, Computer, HostIP, ProcessID;
// Join the two log messages above
let userauthfail = authfail | join (userfail) on Computer, HostIP, ProcessID
| project TimeGenerated, Computer, HostIP, ExternalIP, ProcessID ;
// Extract the EventTime of the first logon attempt
let firstfail = userauthfail
| summarize arg_min(TimeGenerated, *) by Computer, ExternalIP
| project Computer, ExternalIP, FirstLogonAttempt = TimeGenerated;
// Extract the EventTime of the last logon attempt
let lastfail = userauthfail
| summarize arg_max(TimeGenerated, *) by Computer, ExternalIP
| project Computer, ExternalIP, LatestLogonAttempt = TimeGenerated;
// Join first and last logon attempt data and calculate the time between them (AttemptPeriodLength).
let faildates = firstfail | join (lastfail) on Computer, ExternalIP
| project ExternalIP, Computer, FirstLogonAttempt, LatestLogonAttempt, TimeBetweenLogonAttempts = LatestLogonAttempt - FirstLogonAttempt;
// Count the number of failed logon attempts by External IP and internal machine
let totalfails = userauthfail
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), TotalLogonAttempts = count() by ExternalIP, Computer, HostIP
| project StartTimeUtc, EndTimeUtc, ExternalIP, Computer, HostIP, TotalLogonAttempts;
// Combine total attempts with timing data from above
let finalfails = totalfails | join (faildates) on Computer, ExternalIP
| project StartTimeUtc, EndTimeUtc, SourceAddress = ExternalIP, DestinationHost = Computer, DestinationIP = HostIP, TotalLogonAttempts, FirstLogonAttempt, LatestLogonAttempt, TimeBetweenLogonAttempts
| order by DestinationHost asc nulls last;
finalfails 
| where TotalLogonAttempts >= threshold
| extend timestamp = StartTimeUtc, HostCustomEntity = DestinationHost, IPCustomEntity = DestinationIP"
"436e7ba6-5122-4c2e-8a59-29cb4b49f0f7","Exchange SSRF Autodiscover ProxyShell - Detection","true","Detection","High","AzureMonitor(IIS)","W3CIISLog","12h","12h","This query looks for suspicious request patterns to Exchange servers that fit patterns recently
blogged about by PeterJson. This exploitation chain utilises an SSRF vulnerability in Exchange
which eventually allows the attacker to execute arbitrary Powershell on the server. In the example
powershell can be used to write an email to disk with an encoded attachment containing a shell.
Reference: https://peterjson.medium.com/reproducing-the-proxyshell-pwn2own-exploit-49743a4ea9a1'
","let successCodes = dynamic([200, 302, 401]);
W3CIISLog
| where scStatus has_any (successCodes)
| where ipv4_is_private(cIP) == False
| where csUriStem hasprefix ""/autodiscover/autodiscover.json""
| project TimeGenerated, cIP, sIP, sSiteName, csUriStem, csUriQuery, Computer, csUserName, _ResourceId, FileUri
| where (csUriQuery !has ""Protocol"" and isnotempty(csUriQuery))
or (csUriQuery has_any(""/mapi/"", ""powershell""))
or (csUriQuery contains ""@"" and csUriQuery matches regex @""\.[a-zA-Z]{2,4}?(?:[a-zA-Z]{2,4}\/)"")
or (csUriQuery contains "":"" and csUriQuery matches regex @""\:[0-9]{2,4}\/"")
| extend timestamp = TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = cIP, AccountCustomEntity = csUserName, ResourceCustomEntity = _ResourceId, FileCustomEntity = FileUri"
"f458adf6-2355-4769-b0f3-c097c8bee4f6","Successful logon from IP and failure from a different IP","true","Detection","Medium","AzureActiveDirectory","SigninLogs","1d","1d","本规则将对以下行为发出告警：用户帐户从一个 IP 成功登录到 Azure 应用程序，并且在 10 分钟内未能通过不同的 IP 登录到同一应用程序。这可能表明恶意尝试根据用户帐户的知识猜测密码。请检查登录IP和账号","let timeframe = 1d;
let logonDiff = 10m;
SigninLogs 
| where TimeGenerated >= ago(timeframe) 
| where ResultType == ""0"" 
| where AppDisplayName !in (""Office 365 Exchange Online"", ""Skype for Business Online"")
| project SuccessLogonTime = TimeGenerated, UserPrincipalName, SuccessIPAddress = IPAddress, AppDisplayName, SuccessIPBlock = strcat(split(IPAddress, ""."")[0], ""."", split(IPAddress, ""."")[1])
| join kind= inner (
    SigninLogs 
    | where TimeGenerated >= ago(timeframe) 
    | where ResultType !in (""0"", ""50140"") 
    | where ResultDescription !~ ""Other""  
    | where AppDisplayName !in (""Office 365 Exchange Online"", ""Skype for Business Online"")
    | project FailedLogonTime = TimeGenerated, UserPrincipalName, FailedIPAddress = IPAddress, AppDisplayName, ResultType, ResultDescription
) on UserPrincipalName, AppDisplayName 
| where SuccessLogonTime < FailedLogonTime and FailedLogonTime - SuccessLogonTime <= logonDiff and FailedIPAddress !startswith SuccessIPBlock
| summarize FailedLogonTime = max(FailedLogonTime), SuccessLogonTime = max(SuccessLogonTime) by UserPrincipalName, SuccessIPAddress, AppDisplayName, FailedIPAddress, ResultType, ResultDescription 
| extend timestamp = SuccessLogonTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = SuccessIPAddress"
"dd51fc91-be65-4233-8fd1-0a5aadcd8d81","Brute force attack against Azure Portal","true","Detection","Medium","AzureActiveDirectory","SigninLogs","1d","1d","本规则将检查AAD登录日志以发现针对AAD账号的暴力破解。 查询不强制执行任何顺序 - 例如，要求最后进行成功的身份验证。规则使用的默认失败计数为 5，默认成功计数为 1，默认时间窗口为 20 分钟。参考资料：https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes。","let failureCountThreshold = 5;
let successCountThreshold = 1;
let timeframe = 1d;
let authenticationWindow = 20m;
SigninLogs
| where TimeGenerated >= ago(timeframe)
| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser
| extend StatusCode = tostring(Status.errorCode), StatusDetails = tostring(Status.additionalDetails)
| extend State = tostring(LocationDetails.state), City = tostring(LocationDetails.city)
| where AppDisplayName contains ""Azure Portal""
// Split out failure versus non-failure types
| extend FailureOrSuccess = iff(ResultType in (""0"", ""50125"", ""50140"", ""70043"", ""70044""), ""Success"", ""Failure"")
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), IPAddress = makeset(IPAddress), makeset(OS), makeset(Browser), makeset(City), 
makeset(ResultType), FailureCount = countif(FailureOrSuccess==""Failure""), SuccessCount = countif(FailureOrSuccess==""Success"") 
by bin(TimeGenerated, authenticationWindow), UserDisplayName, UserPrincipalName, AppDisplayName
| where FailureCount >= failureCountThreshold and SuccessCount >= successCountThreshold
| mvexpand IPAddress
| extend IPAddress = tostring(IPAddress)
| extend timestamp = StartTimeUtc, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress"
"8e463002-8a64-40c7-946c-96387c30d0ee","HAFNIUM Suspicious Exchange Request","true","Detection","Medium","AzureMonitor(IIS)","W3CIISLog","1d","14d","This query looks for suspicious request patterns to Exchange servers that fit a pattern observed by HAFNIUM actors.
The same query can be run on HTTPProxy logs from on-premise hosted Exchange servers.
Reference: https://www.microsoft.com/security/blog/2021/03/02/hafnium-targeting-exchange-servers/'
","let exchange_servers = (
W3CIISLog
| where TimeGenerated > ago(14d)
| where sSiteName =~ ""Exchange Back End""
| summarize by Computer);
W3CIISLog
| where TimeGenerated > ago(1d)
| where Computer in (exchange_servers)
| where csUriQuery startswith ""t=""
| project-reorder TimeGenerated, Computer, csUriStem, csUriQuery, csUserName, csUserAgent, cIP
| extend timestamp = TimeGenerated, AccountCustomEntity = csUserName, HostCustomEntity = Computer, IPCustomEntity = cIP"
"40dc762f-b99b-49db-b48f-d67dbaa43553","Smart Lockouts","true","Hunting","none","AzureActiveDirectory","SigninLogs","none","none","Identifies accounts that have been locked out by smart lockout policies. Review this results for patterns that might suggest that a password spray is triggering these smart lockout events.
Ref : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-failed-unusual-sign-ins'
","SigninLogs
| where ResultType == 50053
| extend AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress"
"9a7b8123-78bd-4e11-86fb-11e459869ee8","Suspicious Resource deployment","true","Detection","Low","AzureActivity","AzureActivity","1d","14d","本规则将对从新位置(例如新用户或者service principal)发起Azure资源部署的时候发出告警","let szOperationNames = dynamic([""Microsoft.Compute/virtualMachines/write"", ""Microsoft.Resources/deployments/write""]);
let starttime = 14d;
let endtime = 1d;
let RareCaller = AzureActivity
| where TimeGenerated between (ago(starttime) .. ago(endtime))
| where OperationNameValue in~ (szOperationNames)
| project ResourceGroup, Caller, OperationNameValue, CallerIpAddress
| join kind=rightantisemi (
AzureActivity
| where TimeGenerated > ago(endtime)
| where OperationNameValue in~ (szOperationNames)
| extend Resource = tostring(Properties_d.resource), ResourceId = tostring(Properties_d.entity)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ActivityStatusValue = makeset(ActivityStatusValue), OperationIds = makeset(OperationId), CallerIpAddress = makeset(CallerIpAddress) 
by Caller, OperationNameValue, ResourceGroup, Resource, ResourceId
) on Caller, ResourceGroup 
| mvexpand CallerIpAddress
| where isnotempty(CallerIpAddress);
let Counts = RareCaller | summarize ActivityCountByCaller = count() by Caller;
RareCaller | join kind= inner (Counts) on Caller | project-away Caller1
| extend timestamp = StartTimeUtc, AccountCustomEntity = Caller, IPCustomEntity = tostring(CallerIpAddress)
| sort by ActivityCountByCaller desc nulls last"
"388018a0-a90c-4615-a9bd-15234ea3e09b","High count of failed attempts from same client IP","true","Detection","Medium","AzureMonitor(IIS)","W3CIISLog","1d","1d","Identifies when 20 or more failed attempts from a given client IP in 1 minute occur on the IIS server.
This could be indicative of an attempted brute force. This could also simply indicate a misconfigured service or device.
Recommendations: Validate that these are expected connections from the given Client IP.  If the client IP is not recognized, 
potentially block these connections at the edge device.
If these are expected connections, verify the credentials are properly configured on the system, service, application or device 
that is associated with the client IP.
References:
IIS status code mapping: https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0
Win32 Status code mapping: https://msdn.microsoft.com/library/cc231199.aspx","let timeframe = 1d;
let timeBin = 1m;
let failedThreshold = 20;
W3CIISLog
| where TimeGenerated >= ago(timeframe)
| where scStatus in (""401"",""403"")
| where csUserName != ""-""
| extend scStatusFull = strcat(scStatus, ""."",scSubStatus) 
// Map common IIS codes
| extend scStatusFull_Friendly = case(
scStatusFull == ""401.0"", ""Access denied."",
scStatusFull == ""401.1"", ""Logon failed."",
scStatusFull == ""401.2"", ""Logon failed due to server configuration."",
scStatusFull == ""401.3"", ""Unauthorized due to ACL on resource."",
scStatusFull == ""401.4"", ""Authorization failed by filter."",
scStatusFull == ""401.5"", ""Authorization failed by ISAPI/CGI application."",
scStatusFull == ""403.0"", ""Forbidden."",
scStatusFull == ""403.4"", ""SSL required."",
""See - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0"")
// Mapping to Hex so can be mapped using website in comments above
| extend scWin32Status_Hex = tohex(tolong(scWin32Status)) 
// Map common win32 codes
| extend scWin32Status_Friendly = case(
scWin32Status_Hex =~ ""775"", ""The referenced account is currently locked out and cannot be logged on to."",
scWin32Status_Hex =~ ""52e"", ""Logon failure: Unknown user name or bad password."",
scWin32Status_Hex =~ ""532"", ""Logon failure: The specified account password has expired."",
scWin32Status_Hex =~ ""533"", ""Logon failure: Account currently disabled."", 
scWin32Status_Hex =~ ""2ee2"", ""The request has timed out."", 
scWin32Status_Hex =~ ""0"", ""The operation completed successfully."", 
scWin32Status_Hex =~ ""1"", ""Incorrect function."", 
scWin32Status_Hex =~ ""2"", ""The system cannot find the file specified."", 
scWin32Status_Hex =~ ""3"", ""The system cannot find the path specified."", 
scWin32Status_Hex =~ ""4"", ""The system cannot open the file."", 
scWin32Status_Hex =~ ""5"", ""Access is denied."", 
scWin32Status_Hex =~ ""8009030e"", ""SEC_E_NO_CREDENTIALS"", 
scWin32Status_Hex =~ ""8009030C"", ""SEC_E_LOGON_DENIED"", 
""See - https://msdn.microsoft.com/library/cc231199.aspx"")
// decode URI when available
| extend decodedUriQuery = url_decode(csUriQuery)
// Count of failed attempts from same client IP
| summarize makeset(decodedUriQuery), makeset(csUserName), makeset(sSiteName), makeset(sPort), makeset(csUserAgent), makeset(csMethod), makeset(csUriQuery), makeset(scStatusFull), makeset(scStatusFull_Friendly), makeset(scWin32Status_Hex), makeset(scWin32Status_Friendly), FailedConnectionsCount = count() by bin(TimeGenerated, timeBin), cIP, Computer, sIP
| where FailedConnectionsCount >= failedThreshold
| project TimeGenerated, cIP, set_csUserName, set_decodedUriQuery, Computer, set_sSiteName, sIP, set_sPort, set_csUserAgent, set_csMethod, set_scStatusFull, set_scStatusFull_Friendly, set_scWin32Status_Hex, set_scWin32Status_Friendly, FailedConnectionsCount
| order by FailedConnectionsCount
| extend timestamp = TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = cIP"
"fbe1ecbf-f61d-4698-ac52-587d056fcdc3","Web shell file alert enrichment","true","Hunting","none","MicrosoftDefenderAdvancedThreatProtection","SecurityAlert","none","none","Extracts MDATP Alert for a web shell being placed on the server and then enriches this event with information from W3CIISLog to idnetigy the Attacker that placed the shell","let timeWindow = 3d;
let scriptExtensions = dynamic(["".php"", "".jsp"", "".js"", "".aspx"", "".asmx"", "".asax"", "".cfm"", "".shtml""]);  
SecurityAlert  
| where TimeGenerated > ago(timeWindow)  
| where ProviderName =~ ""MDATP"" 
| extend alertData = parse_json(Entities)  
| mvexpand alertData  
// Get only the file type from the JSON, this gives us the file name
| where alertData.Type =~ ""file""  
// This can be expanded to include other script extensions 
| where alertData.Name has_any(scriptExtensions)
| extend FileName = alertData.Name 
| project TimeGenerated, tostring(FileName), alertData.Directory 
| join (  
W3CIISLog  
| where TimeGenerated > ago(timeWindow)  
| where csUriStem has_any(scriptExtensions) 
| extend splitUriStem = split(csUriStem, ""/"")  
| extend FileName = splitUriStem[-1] 
| summarize StartTime=min(TimeGenerated), EndTime=max(TimeGenerated) by AttackerIP=cIP, AttackerUserAgent=csUserAgent, SiteName=sSiteName, ShellLocation=csUriStem, tostring(FileName)  
) on FileName 
| project StartTime, EndTime, AttackerIP, AttackerUserAgent, SiteName, ShellLocation
| extend timestamp = StartTime, IPCustomEntity = AttackerIP"
"36b54f05-54b5-4ab2-a308-65899608c3c0","Port opened for an Azure Resource","true","Hunting","none","AzureActivity","AzureActivity","none","none","本规则将查询Azure操作来列出为 Azure 资源打开了哪些端口。缺省回顾期为7天","let timeframe = 7d;
AzureActivity
| where TimeGenerated >= ago(timeframe)
| where OperationNameValue has_any (""write"", ""update"") and OperationNameValue has_any (""ip"", ""securityRules"")
// Choosing Accepted here because it has the Rule Attributes included
| where ActivityStatusValue =~ ""Accept""
// If there is publicIP info, include it
| extend publicIPAddress_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).ipAddress) 
| extend publicIPAddressVersion_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAddressVersion) 
| extend publicIPAllocationMethod_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAllocationMethod) 
// Include rule attributes for context
| extend access = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).access) 
| extend description = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).description) 
| extend destinationPortRange = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).destinationPortRange) 
| extend direction = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).direction) 
| extend protocol = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).protocol) 
| extend sourcePortRange = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).sourcePortRange) 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ResourceIds = makeset(ResourceId) by Caller, CallerIpAddress, Resource, ResourceGroup, 
ActivityStatus, ActivitySubstatus, SubscriptionId, access, description, destinationPortRange, direction, protocol, sourcePortRange
| extend timestamp = StartTimeUtc, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress"
"bc0d3f7c-020f-4339-919a-d64f8da8c03c","User Granted Access and Grants others Access","true","Hunting","none","AzureActiveDirectory","AuditLogs","none","none","本规则将标识何时授予新用户访问权限并开始授予其他用户访问权限。 这可以帮助您识别流氓或恶意用户行为","let auditLookback = 14d;
let opName = dynamic([""Add user"", ""Invite external user""]);
// Helper function to extract relevant fields from AuditLog events
let auditLogEvents = view (startTimeSpan:timespan, operation:dynamic)  {
    AuditLogs | where TimeGenerated >= ago(auditLookback)
    | where OperationName in~ (operation)
    | extend ModProps = iff(TargetResources.[0].modifiedProperties != ""[]"", TargetResources.[0].modifiedProperties, todynamic(""NoValues""))
    | extend IpAddress = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)), 
    tostring(parse_json(tostring(InitiatedBy.user)).ipAddress), tostring(parse_json(tostring(InitiatedBy.app)).ipAddress))
    | extend InitiatedByFull = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), 
    tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), tostring(parse_json(tostring(InitiatedBy.app)).displayName))
    | extend InitiatedBy = replace(""_"",""@"",tostring(split(InitiatedByFull, ""#"")[0]))
    | extend TargetUserPrincipalName = tostring(TargetResources[0].userPrincipalName)
    | extend TargetUserName = replace(""_"",""@"",tostring(split(TargetUserPrincipalName, ""#"")[0]))
    | extend TargetResourceName = case(
    isempty(tostring(TargetResources.[0].displayName)), TargetUserPrincipalName,
    isnotempty(tostring(TargetResources.[0].displayName)) and tostring(TargetResources.[0].displayName) startswith ""upn:"", tolower(tostring(TargetResources.[0].displayName)),
    tolower(tostring(TargetResources.[0].displayName))
    )
    | extend TargetUserName = replace(""_"",""@"",tostring(split(TargetUserPrincipalName, ""#"")[0]))
    | extend TargetUserName = iff(isempty(TargetUserName), tostring(split(split(TargetResourceName, "","")[0], "" "")[1]), TargetUserName ) 
    | mvexpand ModProps
    | extend PropertyName = tostring(ModProps.displayName), newValue = replace(""\"""","""",tostring(ModProps.newValue));
};
// Assigning time for First TargetUserName that was added
let FirstAdd = auditLogEvents(auditLookback, opName)  
| project FirstAddTimeUtc = TimeGenerated, Type, FirstInitiatedBy = InitiatedBy, IpAddress, FirstTargetUserName = TargetUserName, FirstTargetResourceName = TargetResourceName, 
FirstOperationName = OperationName, FirstPropertyName = PropertyName, FirstnewValue = newValue, FirstCorrelationId = CorrelationId, FirstId = Id;
// Assigning time for second TargetUserName that was added, which will allow us to see if a first TargetUserName added in is the Initiated by on the second in the later join
let SecondAdd = auditLogEvents(auditLookback, opName)  
| project SecondAddTimeUtc = TimeGenerated, Type, SecondInitiatedBy = InitiatedBy, IpAddress, SecondTargetUserName = TargetUserName, SecondTargetResourceName = TargetResourceName, 
SecondOperationName = OperationName, SecondPropertyName = PropertyName, SecondnewValue = newValue, SecondCorrelationId = CorrelationId, SecondId = Id;
//  Joining the FirstAdd with SecondAdd where the FirstAdd TargetUserName value matches the SecondAdd InitiatedBy.  This shows the new user adding a user.
let NewUserAddsUser = FirstAdd | join SecondAdd on $left.FirstTargetUserName == $right.SecondInitiatedBy
// we only want items where the FirstAddTimeUtc is before the SecondAddTimeUtc
| where FirstAddTimeUtc < SecondAddTimeUtc
;
// Build out some of the properties for context
NewUserAddsUser
| extend FirstnewValue = split(FirstnewValue, "";""), SecondnewValue = split(SecondnewValue, "";"")
| extend PropertyUpdate = pack(FirstPropertyName, FirstnewValue, SecondPropertyName, SecondnewValue, ""FirstCorrelationId"", FirstCorrelationId, ""FirstId"", FirstId, ""SecondCorrelationId"", SecondCorrelationId, ""SecondId"", SecondId)
| summarize PropertyUpdateSet = make_bag(PropertyUpdate) by FirstAddTimeUtc, FirstInitiatedBy, FirstTargetUserName, SecondAddTimeUtc, SecondInitiatedBy, SecondTargetUserName, 
IpAddress, FirstTargetResourceName, SecondTargetResourceName, FirstOperationName, SecondOperationName
| extend timestamp = FirstAddTimeUtc, AccountCustomEntity = FirstInitiatedBy, HostCustomEntity = FirstTargetResourceName, IPCustomEntity = IpAddress"
"7e19b38c-066c-463a-8780-ae6f6e8d1f8c","Azure Sentinel Workbooks Administrative Operations","true","Hunting","none","AzureActivity","AzureActivity","none","none","Identifies set of Azure Sentinel Workbooks administrative operational detection queries for hunting activites'
","let opValues = dynamic([""microsoft.insights/workbooks/write"", ""microsoft.insights/workbooks/delete""]);
// Azure Sentinel Workbook Create / Update / Delete
AzureActivity
| where Category == ""Administrative""
| where OperationNameValue in (opValues)
| where ActivitySubstatusValue in (""Created"", ""OK"")
| sort by TimeGenerated desc
| extend timestamp = TimeGenerated, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress"
"c0f313fe-d163-4437-9968-394062490b42","User Granted Access and associated audit activity","true","Hunting","none","AzureActiveDirectory","AuditLogs","none","none","本规则将返回所有用户授予的访问权限相关的审计活动","let auditLookback = 14d;
let opName = dynamic([""Add user"", ""Invite external user""]);
// Setting threshold to 3 as a default, change as needed.  Any operation that has been initiated by a user or app more than 3 times in the past 14 days will be excluded
let threshold = 3;
// Helper function to extract relevant fields from AuditLog events
let auditLogEvents = view (startTimeSpan:timespan)  {
    AuditLogs | where TimeGenerated >= ago(auditLookback)
    | extend ModProps = iff(TargetResources.[0].modifiedProperties != ""[]"", TargetResources.[0].modifiedProperties, todynamic(""NoValues""))
    | extend IpAddress = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)), 
    tostring(parse_json(tostring(InitiatedBy.user)).ipAddress), tostring(parse_json(tostring(InitiatedBy.app)).ipAddress))
    | extend InitiatedByFull = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), 
    tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), tostring(parse_json(tostring(InitiatedBy.app)).displayName))
    | extend InitiatedBy = replace(""_"",""@"",tostring(split(InitiatedByFull, ""#"")[0]))
    | extend TargetUserPrincipalName = tostring(TargetResources[0].userPrincipalName)
    | extend TargetUserName = replace(""_"",""@"",tostring(split(TargetUserPrincipalName, ""#"")[0]))
    | extend TargetResourceName = case(
    isempty(tostring(TargetResources.[0].displayName)), TargetUserPrincipalName,
    isnotempty(tostring(TargetResources.[0].displayName)) and tostring(TargetResources.[0].displayName) startswith ""upn:"", tolower(tostring(TargetResources.[0].displayName)),
    tolower(tostring(TargetResources.[0].displayName))
    )
    | extend TargetUserName = replace(""_"",""@"",tostring(split(TargetUserPrincipalName, ""#"")[0]))
    | extend TargetUserName = iff(isempty(TargetUserName), tostring(split(split(TargetResourceName, "","")[0], "" "")[1]), TargetUserName ) 
    | mvexpand ModProps
    | extend PropertyName = tostring(ModProps.displayName), newValue = replace(""\"""","""",tostring(ModProps.newValue));
};
let HistoricalAdd = auditLogEvents(auditLookback)
| where OperationName in~ (opName)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), OperationCount = count() 
by Type, InitiatedBy, IpAddress, TargetUserName, TargetResourceName, Category, OperationName, PropertyName, newValue, CorrelationId, Id
// Remove comment below to only include operations initiated by a user or app that is above the threshold for the last 14 days
| where OperationCount > threshold
;
// Get list of new added users to correlate with all other events
let Correlate = HistoricalAdd 
| summarize by InitiatedBy, TargetUserName, CorrelationId;
// Get all other events related to list of newly added users
let allOtherEvents = auditLogEvents(auditLookback);
// Join the new added user list to get the list of associated events
let CorrelatedEvents = Correlate 
| join allOtherEvents on InitiatedBy, TargetUserName
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) 
by Type, InitiatedBy, IpAddress, TargetUserName, TargetResourceName, Category, OperationName, PropertyName, newValue, CorrelationId, Id
;
// Union the results so we can see when the user was added and any associated events that occurred during the same time.
let Results = union isfuzzy=true HistoricalAdd,CorrelatedEvents;
// newValues that are simple semi-colon separated, make those dynamic for easy viewing and Aggregate into the PropertyUpdate set based on CorrelationId and Id(DirectoryId)
Results
| extend newValue = split(newValue, "";"")
| extend PropertyUpdate = pack(PropertyName, newValue, ""Id"", Id)
| summarize StartTimeUtc = min(StartTimeUtc), EndTimeUtc = max(EndTimeUtc), PropertyUpdateSet = make_bag(PropertyUpdate) 
by InitiatedBy, IpAddress, TargetUserName, TargetResourceName, OperationName, CorrelationId
| extend timestamp = StartTimeUtc, AccountCustomEntity = InitiatedBy, HostCustomEntity = TargetResourceName, IPCustomEntity = IpAddress"
"234210da-b9ea-4dcd-bc6f-26183b5529ad","Failed attempt to access Azure Portal","true","Hunting","none","AzureActiveDirectory","SigninLogs","none","none","本规则将识别所有未经授权的用户尝试访问 Azure 门户，相关登录失败错误为无效的密码或用户帐户不存在","let timeframe=ago(7d);
SigninLogs
| where TimeGenerated >= timeframe
| where AppDisplayName contains ""Azure Portal""
// 50126 - Invalid username or password, or invalid on-premises username or password.
// 50020? - The user doesn't exist in the tenant.
| where ResultType in ( ""50126"" , ""50020"")
| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser
| extend StatusCode = tostring(Status.errorCode), StatusDetails = tostring(Status.additionalDetails)
| extend State = tostring(LocationDetails.state), City = tostring(LocationDetails.city)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), IPAddresses = makeset(IPAddress), DistinctIPCount = dcount(IPAddress), 
makeset(OS), makeset(Browser), makeset(City), AttemptCount = count() 
by UserDisplayName, UserPrincipalName, AppDisplayName, ResultType, ResultDescription, StatusCode, StatusDetails, Location, State
| extend timestamp = StartTimeUtc, AccountCustomEntity = UserPrincipalName
| sort by AttemptCount"
"ebacd05b-ae33-4eb0-9630-e86d36844557","Long lookback User Account Created and Deleted within 10mins","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","本规则将识别出 10 分钟内创建并删除了的用户帐户。回顾时间是14天","// timeframe is the number of lookback days, default is last 14 days
let timeframe = 14d;
// TimeDelta is the difference between when the account was created and when it was deleted, default is set to 10min or less
let timedelta = 10m;
SecurityEvent 
| where TimeGenerated > ago(timeframe) 
// A user account was created
| where EventID == ""4720""
| where AccountType == ""User""
| project creationTime = TimeGenerated, CreateEventID = EventID, Activity, Computer, TargetUserName, UserPrincipalName, 
AccountUsedToCreate = SubjectUserName, TargetSid, SubjectUserSid 
| join kind= inner (
   SecurityEvent
   | where TimeGenerated > ago(timeframe) 
   // A user account was deleted 
   | where EventID == ""4726"" 
| where AccountType == ""User""
| project deletionTime = TimeGenerated, DeleteEventID = EventID, Activity, Computer, TargetUserName, UserPrincipalName, 
AccountUsedToDelete = SubjectUserName, TargetSid, SubjectUserSid 
) on Computer, TargetUserName
| where deletionTime - creationTime < timedelta
| extend TimeDelta = deletionTime - creationTime
| where tolong(TimeDelta) >= 0
| project TimeDelta, creationTime, CreateEventID, Computer, TargetUserName, UserPrincipalName, AccountUsedToCreate, 
deletionTime, DeleteEventID, AccountUsedToDelete
| extend timestamp = creationTime, HostCustomEntity = Computer, AccountCustomEntity = UserPrincipalName"
"b5e6de91-6931-4cdf-badd-4e57a40be116","Exchange Server Suspicious URIs Visited","true","Hunting","none","AzureMonitor(IIS)","W3CIISLog","none","none","This query will detect paths suspicious associated with ProxyLogon exploitation, it will then calculate the percentage of suspicious URIs
the user had visited in relation to the total number of URIs the user has visited. This query will assist in the detection of automated
ProxyLogon exploitation.'
","//Calculate number of suspicious URI stems visited by user
W3CIISLog 
| where not(ipv4_is_private(cIP))
| where (csUriStem matches regex @""\/owa\/auth\/[A-Za-z0-9]{1,30}\.js"") or (csUriStem matches regex @""\/ecp\/[A-Za-z0-9]{1,30}\.(js|flt|css)"") or (csUriStem =~ ""/ews/exchange.asmx"")
| extend userHash = hash_md5(strcat(cIP, csUserAgent))
| summarize susCount=dcount(csUriStem), make_list(csUriStem), min(TimeGenerated), max(TimeGenerated) by userHash, cIP, csUserAgent
| join kind=leftouter  (
  //Calculate unique URI stems visited by each user
  W3CIISLog
  | where not(ipv4_is_private(cIP))
  | extend userHash = hash_md5(strcat(cIP, csUserAgent))
  | summarize allCount=dcount(csUriStem) by userHash
) on userHash
//Find instances where only a common endpoint was seen
| extend containsDefault = iff(list_csUriStem contains ""/ews/exchange.asmx"", 1, 0)
//If we only see the common endpoint and nothing else dump it
| extend result = iff(containsDefault == 1, containsDefault+susCount, 0)
| where result != 2
| extend susPercentage = susCount / allCount * 100
| where susPercentage > 90
| project StartTime=min_TimeGenerated, EndTime=max_TimeGenerated, AttackerIP=cIP, AttackerUA=csUserAgent, URIsVisited=list_csUriStem, suspiciousPercentage=susPercentage, allUriCount=allCount, suspiciousUriCount=susCount
| extend timestamp = StartTime"
"77364b00-2b0a-4832-8f63-d8c0a005a9f7","Suspicious application consent similar to O365 Attack Toolkit","true","Detection","High","AzureActiveDirectory","AuditLogs","1d","14d","当用户同意向以前未知的 Azure 应用程序提供与 MDSec O365 攻击工具包 (https://github.com/mdsecactivebreach/o365-attack-toolkit) 使用的相同 OAuth 权限时，这将发出警报。
默认权限/ MDSec O365 攻击工具包的范围是contacts.read、user.read、mail.read、notes.read.all、mailboxsettings.readwrite 和files.readwrite.all。
对具有这些权限的应用程序的同意应该很少见，尤其是当 knownApplications 列表被扩展，特别是当 knownApplications 列表被扩展时。 
有关 AuditLogs 的更多信息，请参阅 https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities","let detectionTime = 1d;
let joinLookback = 14d;
AuditLogs
| where TimeGenerated > ago(detectionTime)
| where LoggedByService =~ ""Core Directory""
| where Category =~ ""ApplicationManagement""
| where OperationName =~ ""Consent to application""
| where TargetResources has ""mailboxsettings""
| extend AppDisplayName = TargetResources.[0].displayName
| extend AppClientId = tolower(TargetResources.[0].id)
| where AppClientId !in ((externaldata(knownAppClientId:string, knownAppDisplayName:string)[@""https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/Microsoft.OAuth.KnownApplications.csv""] with (format=""csv"")))
| extend ConsentFull = TargetResources[0].modifiedProperties[4].newValue
| parse ConsentFull with * ""ConsentType: "" GrantConsentType "", Scope: "" GrantScope1 ""]"" *
| where ConsentFull contains ""contacts.read"" and ConsentFull contains ""user.read"" and ConsentFull contains ""mail.read"" and ConsentFull contains ""notes.read.all"" and ConsentFull contains ""mailboxsettings.readwrite"" and ConsentFull contains ""Files.ReadWrite.All""
| where GrantConsentType != ""AllPrincipals"" // NOTE: we are ignoring if OAuth application was granted to all users via an admin - but admin due diligence should be audited occasionally
| extend GrantIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), tostring(InitiatedBy.user.ipAddress), tostring(InitiatedBy.app.ipAddress))
| extend GrantInitiatedBy = iff(isnotempty(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.app.displayName))
| extend GrantUserAgent = iff(AdditionalDetails[0].key =~ ""User-Agent"", tostring(AdditionalDetails[0].value), """")
| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, GrantIpAddress, GrantUserAgent, AppClientId, OperationName, ConsentFull, CorrelationId
| join kind = leftouter (AuditLogs
| where TimeGenerated > ago(joinLookback)
| where LoggedByService =~ ""Core Directory""
| where Category =~ ""ApplicationManagement""
| where OperationName =~ ""Add service principal""
| extend AppClientId = tolower(TargetResources[0].id)
| extend AppReplyURLs = iff(TargetResources[0].modifiedProperties[1].newValue has ""AddressType"", TargetResources[0].modifiedProperties[1].newValue, """")
| distinct AppClientId, tostring(AppReplyURLs)
)
on AppClientId
| join kind = innerunique (AuditLogs
| where TimeGenerated > ago(joinLookback)
| where LoggedByService =~ ""Core Directory""
| where Category =~ ""ApplicationManagement""
| where OperationName =~ ""Add OAuth2PermissionGrant"" or OperationName =~ ""Add delegated permission grant""
| extend GrantAuthentication = tostring(TargetResources[0].displayName)
| extend GrantOperation = OperationName
| project GrantAuthentication, GrantOperation, CorrelationId
) on CorrelationId
| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, AppReplyURLs, GrantIpAddress, GrantUserAgent, AppClientId, GrantAuthentication, OperationName, GrantOperation, CorrelationId, ConsentFull
| extend timestamp = TimeGenerated, AccountCustomEntity = GrantInitiatedBy, IPCustomEntity = GrantIpAddress"
"8cfa63ea-859c-450d-bfc3-67de8b5d4e1e","Inactive or new account signins","true","Hunting","none","AzureActiveDirectory","SigninLogs","none","none","本规则将查询首次登录的帐户，这些账号 不是7 天内创建的用户帐户。 这些账号可能是应该被删除但没有的的陈旧/不活动帐户","//Inactive accounts that sign in - first-time logins for accounts created in last 7 days are filtered out
let starttime = 14d;
let midtime = 7d;
let endtime = 1d;
SigninLogs
| where TimeGenerated >= ago(endtime)
// successful sign-in
| where ResultType == 0
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), loginCountToday=count() by UserPrincipalName, Identity
| join kind=leftanti (
   SigninLogs
   // historical successful sign-in
   | where TimeGenerated < ago(endtime)
   | where TimeGenerated >= ago(starttime)
   | where ResultType == 0
   | summarize by UserPrincipalName, Identity
) on UserPrincipalName 
| join kind= leftanti (
   // filter out newly created user accounts
   AuditLogs
   | where TimeGenerated >= ago(midtime)
   | where OperationName == ""Add user"" 
   // Normalize to lower case in order to match against equivalent UPN in Signin logs
   | extend NewUserPrincipalName = tolower(extractjson(""$.userPrincipalName"", tostring(TargetResources[0]), typeof(string)))
) on $left.UserPrincipalName == $right.NewUserPrincipalName 
| extend timestamp = StartTimeUtc, AccountCustomEntity = UserPrincipalName"
"b06f7fc2-6cd5-4ead-a4f6-8a13617530c1","NOBELIUM - suspicious rundll32.exe execution of vbscript","true","Detection","Medium","SecurityEvents","SecurityEvent","1d","1d","此查询标识 rundll32.exe 何时执行一组特定的内联 VBScript 命令。
 参考资料：https://www.microsoft.com/security/blog/2021/03/04/goldmax-goldfinder-sibot-analyzing-nobelium-malware","SecurityEvent
| where EventID == 4688
| where Process =~ 'rundll32.exe' 
| where CommandLine has_all ('Execute','RegRead','window.close')
| project TimeGenerated, Computer, Account, Process, NewProcessName, CommandLine, ParentProcessName, _ResourceId
| extend timestamp = TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account"
"ac241225-9305-4596-a871-bf0457729a62","Powercat Download","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","Powercat is a PowerShell implementation of netcat. Whilst it can be used as a legitimate administrative tool it can be abused by attackers to exfiltrate data. This query looks for command line activity downloading PowerCat.'
","SecurityEvent
| where EventID == 4688
| where Process has_any (""cmd.exe"", ""powershell.exe"", ""PowerShell_ISE.exe"")
| where CommandLine hassuffix ""powercat.ps1""
| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer"
"6023f684-01d8-4f74-98b7-1ef9cae2109f","Persisting Via IFEO Registry Key","true","Hunting","none","SecurityEvents","MultipleDataSources","none","none","This query detects instances where IFEO registry keys were created and deleted frequently within a short period of time.'
","(union isfuzzy=true
(
SecurityEvent
| where EventID == 4657
| where ObjectName has_all (""\\REGISTRY\\MACHINE"", ""Image File Execution Options"")
| where ObjectName !endswith ""Image File Execution Options""
| summarize Count=count() by Computer, Account, ObjectName
| top 10 by Count desc 
| extend AccountCustomEntity = Account, HostCustomEntity = Computer
),
(
Event
| where Source == ""Microsoft-Windows-Sysmon""
| where EventID in (12, 13)
| extend EventData = parse_xml(EventData).DataItem.EventData.Data
| mv-expand bagexpansion=array EventData
| evaluate bag_unpack(EventData)
| extend Key=tostring(['@Name']), Value=['#text']
| evaluate pivot(Key, any(Value), TimeGenerated, Source, EventLog, Computer, EventLevel, EventLevelName, EventID, UserName, RenderedDescription, MG, ManagementGroupName, Type, _ResourceId)
| where TargetObject has_all (""HKLM"", ""Image File Execution Options"")
| summarize Count=count() by Computer, UserName, tostring(TargetObject)
| top 10 by Count desc
| extend AccountCustomEntity = UserName, HostCustomEntity = Computer
),
(
imRegistry
| where RegistryKey has_all (""HKEY_LOCAL_MACHINE"", ""Image File Execution Options"")
| summarize Count=count() by Dvc, Username, RegistryKey
| top 10 by Count desc
| extend AccountCustomEntity = Username, HostCustomEntity = Dvc
)
)
)"
"08096df1-80d8-4e85-a24d-646a0fd257e2","Azure Active Directory Hybrid Health AD FS Service Delete","true","Detection","Medium","AzureActivity","AzureActivity","1d","1d","此检测使用 AzureActivity 日志（管理类别）来识别租户中 Azure AD 混合运行状况 AD FS 服务实例的删除。 威胁参与者可以创建新的 AD Health ADFS 服务并创建假服务器来欺骗 AD FS 签名日志。 在不再需要健康 AD FS 服务后，可以通过对 Azure 的 HTTP 请求将其删除。 
参考：https://o365blog.com/post/hybridhealthagent。","AzureActivity
| where CategoryValue == 'Administrative'
| where ResourceProviderValue =~ 'Microsoft.ADHybridHealthService'
| where _ResourceId contains 'AdFederationService'
| where OperationNameValue =~ 'Microsoft.ADHybridHealthService/services/delete'
| extend claimsJson = parse_json(Claims)
| extend AppId = tostring(claimsJson.appid)
| extend AccountName = tostring(claimsJson.name)
| project-away claimsJson
| extend timestamp = TimeGenerated, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress"
"eac28af1-e220-4de7-b694-123a8a9f529a","Alerts related to IP","true","Hunting","none","AzureSecurityCenter","SecurityAlert","none","none","本规则将返回来自给定 IpAddress 相关的任何Azure安全中的的警报， 默认查询区间是过去3天","let GetAllAlertsWithIp = (suspiciousEventTime:datetime, v_ipAddress:string){
//-3d and +6h as some alerts fire after accumulation of events
let v_StartTime = suspiciousEventTime-3d;
let v_EndTime = suspiciousEventTime+6h;
SecurityAlert
| where TimeGenerated between (v_StartTime .. v_EndTime)
// expand JSON properties
| where ExtendedProperties contains v_ipAddress or Entities contains v_ipAddress
| extend Extprop = parsejson(ExtendedProperties)
| extend Computer = iff(isnotempty(toupper(tostring(Extprop[""Compromised Host""]))), toupper(tostring(Extprop[""Compromised Host""])), tostring(parse_json(Entities)[0].HostName))
| extend Account = iff(isnotempty(tolower(tostring(Extprop[""User Name""]))), tolower(tostring(Extprop[""User Name""])), tolower(tostring(Extprop[""user name""])))
| extend IpAddress = tostring(parse_json(ExtendedProperties).[""Client Address""]) 
| project StartTimeUtc = StartTime, EndTimeUtc = EndTime, AlertName, Computer, Account, IpAddress, ExtendedProperties, Entities
| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress
};
// change datetime value and <ipaddress> value below
GetAllAlertsWithIp(datetime(now(), ""{ipaddress}"")"
"610f5502-564c-4df0-9e99-fb29ae87cd34","First access credential added to Application or Service Principal where no credential was present","true","Detection","High","AzureActiveDirectory","AuditLogs","1h","1h","这将在管理员或应用程序所有者帐户向应用程序或服务主体添加新凭据,而之前没有关联的验证 KeyCredential时发出警报。
如果威胁行为者获得对具有足够权限的帐户的访问权限并添加触发此操作的备用身份验证材料事件，威胁参与者现在可以使用此凭据作为应用程序或服务主体进行身份验证。
有关 OAuth 凭据授予的其他信息可以在 RFC 6749 第 4.4 节或 https://docs.microsoft.com/azure/active-directory/development/v2-oauth2-client-creds-grant-flow 中找到。
有关审核日志的更多信息，请参阅 https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities","AuditLogs
| where OperationName has_any (""Add service principal"", ""Certificates and secrets management"") // captures ""Add service principal"", ""Add service principal credentials"", and ""Update application - Certificates and secrets management"" events
| where Result =~ ""success""
| mv-expand target = TargetResources
| where tostring(InitiatedBy.user.userPrincipalName) has ""@"" or tostring(InitiatedBy.app.displayName) has ""@""
| extend targetDisplayName = tostring(TargetResources[0].displayName)
| extend targetId = tostring(TargetResources[0].id)
| extend targetType = tostring(TargetResources[0].type)
| extend keyEvents = TargetResources[0].modifiedProperties
| mv-expand keyEvents
| where keyEvents.displayName =~ ""KeyDescription""
| extend new_value_set = parse_json(tostring(keyEvents.newValue))
| extend old_value_set = parse_json(tostring(keyEvents.oldValue))
| where old_value_set == ""[]""
| parse new_value_set with * ""KeyIdentifier="" keyIdentifier:string "",KeyType="" keyType:string "",KeyUsage="" keyUsage:string "",DisplayName="" keyDisplayName:string ""]"" *
| where keyUsage == ""Verify""  or keyUsage == """"
| extend UserAgent = iff(AdditionalDetails[0].key == ""User-Agent"",tostring(AdditionalDetails[0].value),"""")
| extend InitiatingUserOrApp = iff(isnotempty(InitiatedBy.user.userPrincipalName),tostring(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.app.displayName))
| extend InitiatingIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), tostring(InitiatedBy.user.ipAddress), tostring(InitiatedBy.app.ipAddress))
// The below line is currently commented out but Azure Sentinel users can modify this query to show only Application or only Service Principal events in their environment
//| where targetType =~ ""Application"" // or targetType =~ ""ServicePrincipal""
| project-away new_value_set, old_value_set
| project-reorder TimeGenerated, OperationName, InitiatingUserOrApp, InitiatingIpAddress, UserAgent, targetDisplayName, targetId, targetType, keyDisplayName, keyType, keyUsage, keyIdentifier, CorrelationId, TenantId
| extend timestamp = TimeGenerated, AccountCustomEntity = InitiatingUserOrApp, IPCustomEntity = InitiatingIpAddress"
"68f9b8d7-b7ba-4671-886f-b1812845a819","HIDS Security Event Alert","true","Detection","Medium","HIDS","Syslog","10m","10m","本规则将列举HIDS安全告警","let HIDS_Linux_Events = dynamic([""bounce_shell"",""privilege_escalation"",""backdoor_diagnose"",""malic_opera"",""web_command"", ""virus_detect""]);
let HIDS_Windows_Events = dynamic([""win_bounce_shell"",""backdoor_diagnose_win"",""web_command_win"",""virus_detect_win""]);
let HIDS_common_Events = dynamic([""bruteforce_ext"",""bruteforce_inter"",""excep_login"", ""webshell"",""honeypot"",""mem_backdoor""]);
Syslog
| where Facility == 'local0'
| where ProcessName =~ 'qtAlert'
| where SyslogMessage !contains 'access_log'
| extend rawmesssage = iff(SyslogMessage contains 'message repeated', substring(SyslogMessage,indexof(SyslogMessage,'times: [')+8,strlen(SyslogMessage)-indexof(SyslogMessage,'times: [')-9),SyslogMessage)
| extend alertmessage = split(rawmesssage, ' ')
| mv-expand with_itemindex=Index alertmessage
| extend properties = split(alertmessage,'=')
| extend pname = tostring(properties[0])
| extend pvalue =  trim(@'""', tostring(properties[1]))
| extend AlertDetails = pack(pname, pvalue) 
| summarize alert_bag = make_bag(AlertDetails) by rawmesssage, Computer, EventTime
| extend event_name = tostring(alert_bag.event_name), Alert_severity_value = alert_bag.event_level, event_type =  tostring(alert_bag.event_type), host_name = tostring(alert_bag.host_name), 
group_name = tostring(alert_bag.group_name), internal_ip = tostring(alert_bag.internal_ip), external_ip = tostring(alert_bag.external_ip),
comid = tostring(alert_bag.comid), group = tostring(alert_bag.group),  agent_id = tostring(alert_bag.agent_id), event_content = tostring(alert_bag.event_content), url =  tostring(alert_bag.url)
| extend Alert_severity  = case(Alert_severity_value =~ 'danger', ""高"", 
                                Alert_severity_value =~ 'alert', ""中"", 
                                Alert_severity_value =~ 'info', ""低"",
                                ""信息""
                                )
| where event_type in (HIDS_Linux_Events,HIDS_Windows_Events,HIDS_common_Events)                  
| extend EventSource = 'HIDS'
| extend OS = iff(event_type in (HIDS_Linux_Events),'Linux', iff(event_type in (HIDS_Windows_Events),'Windows', 'none'))
| extend OS = iff(OS in ('Windows,Linux'), OS, iff(event_type contains 'Linux','Linux', iff(event_name contains 'win','Windows','unknown')))
| summarize Repeated = count(), arg_min(EventTime, *) by comid, group, agent_id
| project event_name, Alert_severity, event_type, host_name, internal_ip, external_ip, OS, group_name, comid, group, agent_id, event_content,  url, Repeated, EventSource, rawmesssage"
"c65b1390-2cea-409b-af84-5d7934c7d62a","AzureActivity Administration From VPS Providers","true","Hunting","none","AzureActivity","AzureActivity","none","none","Looks for Administrative actions in AzureActivity from known VPS provider network ranges.
This is not an exhaustive list of VPS provider ranges but covers some of the most prevalent providers observed.'
","let IP_Data = (externaldata(network:string)
[@""https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/VPS_Networks.csv""] with (format=""csv""));
AzureActivity
| where CategoryValue =~ ""Administrative""
| evaluate ipv4_lookup(IP_Data, CallerIpAddress, network, return_unmatched = false)
| summarize Operations = make_set(OperationNameValue), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by CallerIpAddress, Caller
| extend timestamp = StartTime, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress"
"e77add10-9a4f-46d4-ba78-b1c7a2c63850","Squid proxy events for ToR proxies","true","Detection","Low","Syslog","Syslog","1d","1d","本规则用于检查 Syslog，当发现出现和常见洋葱网络(Tor)的 Squid 代理事件将发起告警","let timeframe = 1d;
let DomainList = dynamic([""tor2web.org"", ""tor2web.com"", ""torlink.co"", ""onion.to"", ""onion.ink"", ""onion.cab"", ""onion.nu"", ""onion.link"", 
""onion.it"", ""onion.city"", ""onion.direct"", ""onion.top"", ""onion.casa"", ""onion.plus"", ""onion.rip"", ""onion.dog"", ""tor2web.fi"", 
""tor2web.blutmagie.de"", ""onion.sh"", ""onion.lu"", ""onion.pet"", ""t2w.pw"", ""tor2web.ae.org"", ""tor2web.io"", ""tor2web.xyz"", ""onion.lt"", 
""s1.tor-gateways.de"", ""s2.tor-gateways.de"", ""s3.tor-gateways.de"", ""s4.tor-gateways.de"", ""s5.tor-gateways.de"", ""hiddenservice.net""]);
Syslog
| where TimeGenerated >= ago(timeframe)
| where ProcessName contains ""squid""
| extend URL = extract(""(([A-Z]+ [a-z]{4,5}:\\/\\/)|[A-Z]+ )([^ :]*)"",3,SyslogMessage), 
        SourceIP = extract(""([0-9]+ )(([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3}))"",2,SyslogMessage), 
        Status = extract(""(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))"",1,SyslogMessage), 
        HTTP_Status_Code = extract(""(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))/([0-9]{3})"",8,SyslogMessage),
        User = extract(""(CONNECT |GET )([^ ]* )([^ ]+)"",3,SyslogMessage),
        RemotePort = extract(""(CONNECT |GET )([^ ]*)(:)([0-9]*)"",4,SyslogMessage),
        Domain = extract(""(([A-Z]+ [a-z]{4,5}:\\/\\/)|[A-Z]+ )([^ :\\/]*)"",3,SyslogMessage),
        Bytes = toint(extract(""([A-Z]+\\/[0-9]{3} )([0-9]+)"",2,SyslogMessage)),
        contentType = extract(""([a-z/]+$)"",1,SyslogMessage)
| extend TLD = extract(""\\.[a-z]*$"",0,Domain)
| where HTTP_Status_Code == ""200""
| where Domain contains "".""
| where Domain has_any (DomainList)
| extend timestamp = TimeGenerated, URLCustomEntity = URL, IPCustomEntity = SourceIP, AccountCustomEntity = User"
"f4787b0d-a546-4df0-943d-3956bbbe1356","Detect malicious network flows","true","Detection","Low","Network","AzureNetworkAnalytics_CL","1h","1h","本规则讲查询是否存在从恶意网络IP对虚拟网络资源发起的网络连接,当过去一小时发起的恶意网络流量超过5次或者出现成功的连接的时候，发出告警。","let threshold = 5;
AzureNetworkAnalytics_CL
| where SubType_s == 'FlowLog'
    and FASchemaVersion_s == '2'
    and FlowType_s == 'MaliciousFlow'
| extend
    Subnet1 = iif(FlowType_s in ('InterVNet', 'IntraVNet'), Subnet1_s, iif(FlowDirection_s == 'O', Subnet_s, '')),
    Subnet2 = iif(FlowType_s in ('InterVNet', 'IntraVNet'), Subnet2_s, iif(FlowDirection_s == 'I', Subnet_s, ''))
| extend
    VM1 = iif(FlowType_s in ('InterVNet', 'IntraVNet'), VM1_s, iif(FlowDirection_s == 'O', VM_s, '')),
    VM2 = iif(FlowType_s in ('InterVNet', 'IntraVNet'), VM2_s, iif(FlowDirection_s == 'I', VM_s, ''))
| extend
    Subscription1 = iif(FlowType_s == 'InterVNet', Subscription1_g, iif(FlowType_s == 'IntraVNet' or FlowDirection_s == 'O', Subscription_g, '')),
    Subscription2 = iif(FlowType_s == 'InterVNet', Subscription2_g, iif(FlowType_s == 'IntraVNet' or FlowDirection_s == 'I', Subscription_g, ''))
| extend
    NIC1 = iif(FlowType_s in ('InterVNet', 'IntraVNet'), NIC1_s, iif(FlowDirection_s == 'O', NIC_s, '')),
    NIC2 = iif(FlowType_s in ('InterVNet', 'IntraVNet'), NIC2_s, iif(FlowDirection_s == 'I', NIC_s, ''))
| extend
    SrcIP = iif(isnotempty(SrcIP_s), SrcIP_s, iif(FlowDirection_s == 'O', VMIP_s, '')),
    DestIP = iif(isnotempty(DestIP_s), DestIP_s, iif(FlowDirection_s == 'I', VMIP_s, ''))
| extend CountryOrRegion = iif(FlowType_s == 'AzurePublic', AzureRegion_s, Country_s)
| extend FlowDirection_s = iif(FlowType_s in ('InterVNet', 'IntraVNet'), '', FlowDirection_s)
| extend MaliciousIP = iff(FlowDirection_s == ""I"", SrcIP , DestIP)
| extend TargetClientIP = iff(FlowDirection_s == ""I"", DestIP , SrcIP)
| summarize
    FlowCount = sum(FlowCount_d),
    AllowedInFlows = sum(AllowedInFlows_d),
    DeniedInFlows = sum(DeniedInFlows_d)
    by MaliciousIP,TargetClientIP,  VM=VM2, Subnet=Subnet2, Subscription=Subscription2, DestPort_d, L7Protocol_s
| sort by AllowedInFlows desc
| where AllowedInFlows > 0 or FlowCount > threshold
| project
    MaliciousIP,TargetClientIP,
    VM,
    VNet = strcat(split(Subnet, '/')[0], '/', split(Subnet, '/')[0]),
    Subscription,
    FlowCount,
    AllowedInFlows,
    DeniedInFlows,
    Port = DestPort_d, 
     Protocol = L7Protocol_s
| extend VM = strcat('/subscriptions/', Subscription, '/resourceGroups/', split(VM, '/')[0], '/providers/Microsoft.Compute/virtualMachines/', split(VM, '/')[1])
| extend VNet = strcat('/subscriptions/', Subscription, '/resourceGroups/', split(VNet, '/')[0], '/providers/Microsoft.Network/virtualNetworks/', split(VNet, '/')[1])
"
"e6e58211-ab6a-4d1b-acbe-da8d96d61e17","SSH - Potential Brute Force","true","Detection","Low","Syslog","Syslog","1h","1h","本规则将报告所有在 1 小时内尝试通过 SSH 登录失败 15 次及以上的 IP 地址, 此类行为通常表示为潜在的密码暴力破解。","let timeframe = 1h;
let threshold = 15;
Syslog
| where TimeGenerated >= ago(timeframe)
| where SyslogMessage contains ""Failed password for""
| where ProcessName =~ ""sshd"" 
| parse kind=relaxed SyslogMessage with * ""Failed password for "" user "" from "" ip "" port"" port "" ssh2""
| project user, ip, port, SyslogMessage, EventTime
| summarize EventTimes = make_list(EventTime), PerHourCount = count() by ip, bin(EventTime, 1h), user
| where PerHourCount > threshold
| mvexpand EventTimes
| extend EventTimes = tostring(EventTimes) 
| summarize StartTimeUtc = min(EventTimes), EndTimeUtc = max(EventTimes), UserList = makeset(user), sum(PerHourCount) by IPAddress = ip
| extend UserList = tostring(UserList) 
| extend timestamp = StartTimeUtc, IPCustomEntity = IPAddress, AccountCustomEntity = UserList"
"9bf29d44-868a-447d-a6d2-00ce37a142ee","User Login IP Address Teleportation","true","Hunting","none","AzureActiveDirectory","SigninLogs","none","none","This query over SiginLogs will identify user accounts that have logged in from two different countries
within a specified time window, by default this is a 10 minute window either side of the previous login.
This query will detect users roaming onto VPNs, it is possible to exclude known VPN IP address ranges.'
","let windowTime = 20min / 2; //Window to lookup anomalous logins within
let excludeKnownVPN = dynamic(['127.0.0.1', '0.0.0.0']); //Known VPN IP addresses to exclude
SigninLogs
| where ConditionalAccessStatus =~ ""success""
| extend country = LocationDetails['countryOrRegion']
| where country != """"
| summarize count() by tostring(country)
| join (
    //Get the total number of logins from any country and join it to the previous count in a single table
    SigninLogs
    | where ConditionalAccessStatus =~ ""success""
    | extend country = LocationDetails['countryOrRegion']
    | where country != """"
    | summarize count(), make_list(tostring(country))
    | mv-expand list_country
    | extend country = tostring(list_country)
) on country
| summarize by country, count_, count_1
//Now calculate each countries prevalence within login events
| extend prevalence = toreal(count_) / toreal(count_1) * 100
| project-away count_1
| where prevalence < 0.01
| join kind=rightsemi(
    SigninLogs
    //Enable to limit to o365 exchange logins
    //| where AppDisplayName =~ ""Office 365 Exchange Online""
    | where ConditionalAccessStatus =~ ""success""
    | where IPAddress != """"
    | extend country = tostring(LocationDetails['countryOrRegion'])
    | summarize count() by TimeGenerated, UserPrincipalName, country, IPAddress
) on country
| join kind=leftouter (
    SigninLogs
    //Enable to limit to o365 exchange logins
    //| where AppDisplayName =~ ""Office 365 Exchange Online""
    | where ConditionalAccessStatus =~ ""success""
    | extend country = tostring(LocationDetails['countryOrRegion'])
    | summarize by TimeGenerated, IPAddress, UserPrincipalName, country
) on UserPrincipalName
| where IPAddress != IPAddress1 and country != country1
| extend WindowStart = TimeGenerated1 - windowTime
| extend WindowEnd = TimeGenerated1 + windowTime
| where TimeGenerated between (WindowStart .. WindowEnd)
| project Account=UserPrincipalName, AnomalousIP=IPAddress, AnomalousLoginTime=TimeGenerated, AnomalousCountry=country, OtherLoginIP=IPAddress1, OtherLoginCountry=country1, OtherLoginWindowStart=WindowStart, OtherLoginWindowEnd=WindowEnd
| where AnomalousIP !in(excludeKnownVPN) and OtherLoginIP !in(excludeKnownVPN)
| extend timestamp = AnomalousLoginTime, AccountCustomEntity = Account, IPCustomEntity = AnomalousIP"
"2af6fd90-7274-49c4-84cb-abae41f9df2a","User account enabled and disabled within 10 mins","true","Detection","Medium","SecurityEvents","SecurityEvent","1d","2d","Identifies when a user account is enabled and then disabled within 10 minutes. This can be an indication of compromise and
an adversary attempting to hide in the noise.","let timeframe = 1d;
let spanoftime = 10m;
let threshold = 0;
SecurityEvent 
| where TimeGenerated > ago(2*timeframe) 
// A user account was enabled
| where EventID == 4722
| where AccountType =~ ""User""
| project creationTime = TimeGenerated, CreateEventID = EventID, Activity, Computer, TargetUserName, UserPrincipalName, 
AccountUsedToCreate = SubjectUserName, TargetSid, SubjectUserSid 
| join kind= inner (
  SecurityEvent
  | where TimeGenerated > ago(timeframe) 
  // A user account was disabled 
  | where EventID == 4725
| where AccountType == ""User""
| project deletionTime = TimeGenerated, DeleteEventID = EventID, Activity, Computer, TargetUserName, UserPrincipalName, 
AccountUsedToDelete = SubjectUserName, TargetSid, SubjectUserSid 
) on Computer, TargetUserName
| where deletionTime - creationTime < spanoftime
| extend TimeDelta = deletionTime - creationTime
| where tolong(TimeDelta) >= threshold
| project TimeDelta, creationTime, CreateEventID, Computer, TargetUserName, UserPrincipalName, AccountUsedToCreate, 
deletionTime, DeleteEventID, AccountUsedToDelete
| extend timestamp = creationTime, AccountCustomEntity = AccountUsedToCreate, HostCustomEntity = Computer"
"34ff61e5-5d2a-4a94-b46d-d1cb67311101","DSM Security Alert","true","Detection","Medium","DSM","Syslog","10m","10m","本规则将列举DSM安全告警","Syslog
| where ProcessName =~ 'LEEF'
| where Facility == 'local0'
| extend rawmesssage = iff(SyslogMessage contains 'message repeated', substring(SyslogMessage,indexof(SyslogMessage,'times: [')+8,strlen(SyslogMessage)-indexof(SyslogMessage,'times: [')-9),SyslogMessage)
| extend alertmessage = split(rawmesssage, '|')
| extend EventId = toint(alertmessage[4])
| where EventId >= 4000000 and EventId <= 4000030
| extend EventDetails = split(alertmessage[5],'#011')
| mv-expand with_itemindex=Index EventDetails
| extend properties = split(EventDetails,'=')
| extend pname = tostring(properties[0])
| extend pvalue =  trim(@'""', tostring(properties[1]))
| order by pname asc
| extend AlertDetails = pack(pname, pvalue)
| summarize alert_bag = make_bag(AlertDetails) by rawmesssage, Computer, EventTime
| extend Alert_Name ='DSM - 防恶意软件事件', Alert_severity_value = alert_bag.sev
| extend Alert_severity  = case(toint(Alert_severity_value) >= 7, ""高"", 
                                toint(Alert_severity_value) >= 4, ""中"",
                                ""低""
                                )
| extend cat = tostring(alert_bag.cat), name=tostring(alert_bag.name), msg=tostring(alert_bag.msg),  act=tostring(alert_bag.act),dvc=tostring(alert_bag.dvc), dvchost=tostring(alert_bag.dvchost), filePath=tostring(alert_bag.filePath), TrendMicroDsMalwareTarget=tostring(alert_bag.TrendMicroDsMalwareTarget),TrendMicroDsMalwareTargetType=(alert_bag.TrendMicroDsMalwareTargetType),TrendMicroDsDetectionConfidence=tostring(alert_bag.TrendMicroDsDetectionConfidence),TrendMicroDsRelevantDetectionNames=tostring(alert_bag.TrendMicroDsRelevantDetectionNames),description=tostring(alert_bag['desc']),TrendMicroDsFileMD5=tostring(alert_bag.TrendMicroDsFileMD5),TrendMicroDsFileSHA256=tostring(alert_bag.TrendMicroDsFileSHA256)
| extend EventSource = 'DSM'
| project Alert_Name, Alert_severity, cat, name, msg, act, dvc, dvchost,filePath,TrendMicroDsMalwareTarget, TrendMicroDsMalwareTargetType, TrendMicroDsDetectionConfidence, TrendMicroDsRelevantDetectionNames,description, TrendMicroDsFileMD5, TrendMicroDsFileSHA256, EventTime, EventSource, rawmesssage"
"1d52ecd7-9094-4b07-8585-78953060b8b0","Bulk Changes to Privileged Account Permissions","true","Detection","High","AzureActiveDirectory","AuditLogs","2h","2h","标识对多个用户权限的更改同时发生。 如果不是计划中的更改，请立即进行调查。 此设置可能使攻击者能够访问您环境中的 Azure 订阅。 参考：https://docs.microsoft.comazure/active-directory/fundamentals/security-operations-privileged-identity-management ","AuditLogs
| where Category =~ ""RoleManagement""
| where ActivityDisplayName has_any (""Add eligible member to role"", ""Add member to role"")
| mv-expand TargetResources
| mv-expand TargetResources.modifiedProperties
| extend displayName_ = tostring(TargetResources_modifiedProperties.displayName)
| where displayName_ =~ ""Role.DisplayName""
| extend RoleName = tostring(parse_json(tostring(TargetResources_modifiedProperties.newValue)))
| where RoleName contains ""Admin""
| extend Target = tostring(TargetResources.userPrincipalName)
| summarize dcount(Target) by bin(TimeGenerated, 1h)
| where dcount_Target > 9
| join kind=rightsemi  (AuditLogs
| where Category =~ ""RoleManagement""
| where ActivityDisplayName has_any (""Add eligible member to role"", ""Add member to role"")
| mv-expand TargetResources
| mv-expand TargetResources.modifiedProperties
| extend displayName_ = tostring(TargetResources_modifiedProperties.displayName)
| where displayName_ =~ ""Role.DisplayName""
| extend RoleName = tostring(parse_json(tostring(TargetResources_modifiedProperties.newValue)))
| where RoleName contains ""Admin""
| extend Target = tostring(TargetResources.userPrincipalName)
| extend TimeWindow = bin(TimeGenerated, 1h)) on $left.TimeGenerated == $right.TimeWindow
| extend AccountCustomEntity = Target"
"d8a04782-f14d-470a-be70-db9800df2f72","Azure Portal Signin from another Azure Tenant","true","Detection","Medium","AzureActiveDirectory","SigninLogs","1h","1h","此查询查找从另一个 Azure 租户登录的 Azure 门户的登录尝试，并且登录尝试的 IP 地址是 Azure IP。 威胁 Azure 租户的威胁参与者可能会转向以这种方式利用跨租户委派访问的其他租户。","// Get details of current Azure Ranges (note this URL updates regularly so will need to be manually updated over time)
let azure_ranges = externaldata(changeNumber: string, cloud: string, values: dynamic)
[""https://download.microsoft.com/download/9/D/0/9D03B7E2-4B80-4BF3-9B91-DA8C7D3EE9F9/ServiceTags_China_20211101.json""]
with(format='multijson')
| mv-expand values
| mv-expand values.properties.addressPrefixes
| mv-expand values_properties_addressPrefixes
| summarize by tostring(values_properties_addressPrefixes);
SigninLogs
// Limiting to Azure Portal really reduces false positives and helps focus on potential admin activity
| where AppDisplayName =~ ""Azure Portal""
// Only get logons where the IP address is in an Azure range
| evaluate ipv4_lookup(azure_ranges, IPAddress, values_properties_addressPrefixes)
// Limit to where the user is external to the tenant
| where HomeTenantId != ResourceTenantId
// Further limit it to just access to the current tenant (you can drop this if you wanted to look elsewhere as well but it helps reduce FPs)
| where ResourceTenantId == TenantId
| summarize FirstSeen = min(TimeGenerated), LastSeen = max(TimeGenerated), make_set(ResourceDisplayName) by UserPrincipalName, IPAddress, UserAgent, Location, HomeTenantId, ResourceTenantId
| extend AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress"
"e749151e-f516-4ae6-96c7-135774bc8432","Rare Process Path","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","本规则将识别出从新的目录中发起的进程。 回顾时间是7天","let end = startofday(now());
let start = end - 8d;
let processEvents=
SecurityEvent
| where TimeGenerated >= start and TimeGenerated <= end
| where EventID==4688
// excluding well known processes
| where NewProcessName !endswith ':\\Windows\\System32\\conhost.exe' and ParentProcessName !endswith ':\\Windows\\System32\\conhost.exe'
| where ParentProcessName !endswith "":\\Windows\\System32\\wuauclt.exe"" and NewProcessName !startswith ""C:\\Windows\\SoftwareDistribution\\Download\\Install\\AM_Delta_Patch_""
| where NewProcessName !has "":\\Windows\\WinSxS\\amd64_microsoft-windows-servicingstack_"" and ParentProcessName !has "":\\Windows\\WinSxS\\amd64_microsoft-windows-servicingstack_""
| where NewProcessName !endswith "":\\WindowsAzure\\SecAgent\\WaSecAgentProv.exe"" 
| where ParentProcessName !has "":\\WindowsAzure\\GuestAgent_"" and NewProcessName !has "":\\WindowsAzure\\GuestAgent_""
| where ParentProcessName !has "":\\WindowsAzure\\WindowsAzureNetAgent_"" and NewProcessName !has "":\\WindowsAzure\\WindowsAzureNetAgent_""
| where ParentProcessName !has "":\\ProgramData\\Microsoft\\Windows Defender\\platform\\"" and ParentProcessName !endswith ""\\MpCmdRun.exe"" 
| where NewProcessName !has "":\\ProgramData\\Microsoft\\Windows Defender\\platform\\"" and NewProcessName !endswith ""\\MpCmdRun.exe"" 
| where NewProcessName !has ':\\Program Files\\Microsoft Monitoring Agent\\Agent\\'
// filter out common randomly named paths and files
| where not(NewProcessName matches regex @""\\TRA[0-9A-Fa-f]{3}\.tmp"")
| where not(NewProcessName matches regex @""\\TRA[0-9A-Fa-f]{4}\.tmp"")
| where not(NewProcessName matches regex @""Installer\\MSI[0-9A-Fa-f]{3}\.tmp"")
| where not(NewProcessName matches regex @""Installer\\MSI[0-9A-Fa-f]{4}\.tmp"")
| where not(NewProcessName matches regex @""\\Windows\\Temp\\[0-9A-Za-z-]*\\DismHost\.exe"")
| where not(NewProcessName matches regex @""\\Users\\[0-9A-Za-z-_~\.]*\\AppData\\Local\\Temp\\[0-9A-Za-z-]*\\DismHost\.exe"")
| where not(NewProcessName matches regex @""\\Windows\\Temp\\[0-9A-Za-z-]*\\MpSigStub\.exe"")
| where not(NewProcessName matches regex @""\\[0-9A-Za-z]*\\amd64\\setup\.exe"") and (ParentProcessName !has "":\\Windows\\SoftwareDistribution\\Download\\Install\\"" 
or ParentProcessName !has ""\\AppData\\Local\\Temp\\mpam-"")
| where not(NewProcessName matches regex @""\\Windows\\Microsoft.NET\\(Framework|Framework64)\\v[0-9].[0-9].[0-9]*\\(csc\.exe|cvtres\.exe|mscorsvw\.exe|ngentask\.exe|ngen\.exe)"")
| where not(NewProcessName matches regex @""\\WindowsAzure\\GuestAgent_[0-9].[0-9].[0-9]*.[0-9]*_[0-9]*-[0-9]*-[0-9]*_[0-9]*\\"") 
and not(ParentProcessName matches regex @""\\WindowsAzure\\GuestAgent_[0-9].[0-9].[0-9]*.[0-9]*_[0-9]*-[0-9]*-[0-9]*_[0-9]*\\"")
| where not(NewProcessName matches regex @""\\[0-9A-Za-z]*\\epplauncher.exe"")
| where not(NewProcessName matches regex @""\\Packages\\Plugins\\Microsoft\."")
| extend path_parts = parse_path(NewProcessName)
| extend ProcessPath = tostring(path_parts.DirectoryPath)
;
let normalizedProcessPath = processEvents
| extend NormalizedProcessPath = ProcessPath
// normalize guids
| project TimeGenerated, Computer, Account, Process, ProcessPath, 
NormalizedProcessPath = replace(""[0-9A-Fa-f]{8}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{12}"", ""<guid>"", NormalizedProcessPath)
// normalize digits away
| project TimeGenerated, Computer, Account, Process, ProcessPath, NormalizedProcessPath = replace(@'\d', '#', NormalizedProcessPath)
; 
let freqs = normalizedProcessPath
| summarize makelist(Computer), makelist(Account), makelist(ProcessPath), frequency=count() by NormalizedProcessPath, Process
| join kind= leftouter (
normalizedProcessPath
| summarize StartTimeUtc=min(TimeGenerated), EndTimeUtc=max(TimeGenerated) by NormalizedProcessPath, Process
) on NormalizedProcessPath, Process;
freqs
| where frequency <= toscalar( freqs | serialize | project frequency | summarize percentiles(frequency, 5))
| order by frequency asc  
| mvexpand Computer = list_Computer, Account = list_Account, ProcessPath = list_ProcessPath
| project StartTimeUtc, EndTimeUtc, frequency, Process, NormalizedProcessPath, tostring(ProcessPath), tostring(Computer), tostring(Account)"
"69ed197c-cb92-4879-9040-794f43690b52","Anomalous Azure Active Directory apps based on authentication location","true","Hunting","none","AzureActiveDirectory","SigninLogs","none","none","本规则将扫描Azure AD 登录日志。并为 Azure AD 应用程序登录的地理位置与身份验证总数的比率做排序以找出可能的 Azure AD 应用程序泄露","let timeframe=ago(14d);
let azureSignIns = 
SigninLogs
| where TimeGenerated >= timeframe
| where SourceSystem == ""Azure AD""
| where OperationName == ""Sign-in activity""
| project TimeGenerated, OperationName, AppDisplayName , Identity, UserId, UserPrincipalName, Location, LocationDetails, 
ClientAppUsed, DeviceDetail, ConditionalAccessPolicies;
azureSignIns
| extend locationString = strcat(tostring(LocationDetails[""countryOrRegion""]), ""/"", 
tostring(LocationDetails[""state""]), ""/"", tostring(LocationDetails[""city""]), "";"" , tostring(LocationDetails[""geoCoordinates""]))
| summarize rawSigninCount = count(), countByAccount = dcount(UserId), locationCount = dcount(locationString) by AppDisplayName
// tail - pick a threshold to rule out the very-high volume Azure AD apps
| where rawSigninCount < 1000
// more locations than accounts
| where locationCount>countByAccount
// almost as many / more locations than sign-ins!
| where 1.0*rawSigninCount / locationCount > 0.8 
| order by rawSigninCount  desc
| join kind = leftouter (
   azureSignIns 
) on AppDisplayName 
| project AppDisplayName, TimeGenerated , Identity, rawSigninCount, countByAccount, locationCount,  
locationString = strcat(tostring(LocationDetails[""countryOrRegion""]), ""/"", tostring(LocationDetails[""state""]), ""/"", 
tostring(LocationDetails[""city""]), "";"" , tostring(LocationDetails[""geoCoordinates""])), UserPrincipalName
| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName 
| order by AppDisplayName, TimeGenerated desc"
"31a5b583-58a4-4b81-b692-80c139e696b7","Exchange PowerShell Snapin Added","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","The Exchange Powershell Snapin was loaded on a host, this allows for a Exchange server management via PowerShell. Whilst this is a legitimate administrative tool it is abused by attackers to performs actions on a compromised Exchange server. Hunt for unusual activity related to this Snapin including it being added on new hosts or by new accounts.'
","SecurityEvent
| where EventID == 4688
| where Process has_any (""cmd.exe"", ""powershell.exe"", ""PowerShell_ISE.exe"")
| where isnotempty(CommandLine)
| where CommandLine contains ""Add-PSSnapin Microsoft.Exchange.Management.Powershell.Snapin""
| summarize FirstSeen = min(TimeGenerated), LastSeen = max(TimeGenerated) by Computer, Account, CommandLine 
| extend timestamp = FirstSeen, AccountCustomEntity = Account, HostCustomEntity = Computer"
"c8305814-e736-4bfb-afbf-04dc398848ac","Linux scheduled task Aggregation","true","Hunting","none","Syslog","Syslog","none","none","本规则将统计Linux主机上的所有计划任务（Cron 作业）的信息，并在图表中显示数据","// Change startdate below if you want a different timespan
let startdate = 7d;
// Pull messages from Syslog-cron where the process name is ""CRON"" or ""CROND"", the severity level is info, and the SyslogMessage contains ""CMD"".
// It also parses out the user and commandline from the message.
let RawCommands = Syslog 
| where TimeGenerated >= ago(startdate)
| where Facility =~ ""cron"" 
| where SeverityLevel =~ ""info"" 
| where ProcessName =~ ""CRON"" or ProcessName =~ ""CROND""  
| where SyslogMessage contains ""CMD "" 
| project TenantId, TimeGenerated, Computer, SeverityLevel, ProcessName, SyslogMessage
| extend TrimmedSyslogMsg = trim_end(@""\)"", SyslogMessage)
| parse TrimmedSyslogMsg with * ""("" user  "") CMD ("" cmdline 
| project TenantId, TimeGenerated, Computer, user, cmdline; 
// Count how many times a particular commandline has been seen based on unique Computer, User, and cmdline sets
let CommandCount = RawCommands
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count(cmdline) by Computer, user, cmdline
| project StartTimeUtc, EndTimeUtc, Computer, user, cmdline, CmdlineCount = count_cmdline ; 
// Count how many computers have run a particular user and cmdline pair
let DistComputerCount = RawCommands
| summarize dcount(Computer) by TenantId, user, cmdline
| project TenantId, user, cmdline, ComputerCount = dcount_Computer ; 
// Join above counts based on user and commandline pair
let CommandSummary = CommandCount | join (DistComputerCount) on user, cmdline
| project StartTimeUtc, EndTimeUtc, TenantId, user, CmdlineCount, ComputerCount, cmdline ;
// Count the total number of computers reporting cron messages in the tenant
let TotalComputers = Syslog
| where Facility =~ ""cron""
| summarize dcount(Computer) by TenantId ;
// Join the previous counts with the total computers count. Calculate the percentage of total computers value.
let FinalSummary = CommandSummary | join kind= leftouter (TotalComputers) on TenantId
| project StartTimeUtc, EndTimeUtc, user, TimesCmdlineSeen = CmdlineCount, CompsThatHaveRunCmdline = ComputerCount, 
AsPercentOfTotalComps = round(100 * (toreal(ComputerCount)/toreal(dcount_Computer)),2), cmdline
| order by user asc, TimesCmdlineSeen desc;
FinalSummary 
| extend timestamp = StartTimeUtc, AccountCustomEntity = user"
"432f66c8-4fe1-44b5-a415-c7b5c0e565f1","Account created or deleted by non-approved user","false","Detection","Medium","AzureActiveDirectory","AuditLogs","1d","1d","标识由未批准的用户主体名称的定义列表创建或删除的帐户。 在运行查询之前需要修改查询语句，添加账号到nonapproved_users列表以获得准确的结果。 参考：https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts","// Add non-approved user principal names to the list below to search for their account creation/deletion activity
// ex: dynamic([""UPN1"", ""upn123""])
let nonapproved_users = dynamic([]);
AuditLogs
| where OperationName == ""Add user"" or OperationName == ""Delete user""
| where Result == ""success""
| extend InitiatingUser = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| where InitiatingUser has_any (nonapproved_users)
| project-reorder TimeGenerated, ResourceId, OperationName, InitiatingUser, TargetResources
| extend AccountCustomEntity = InitiatingUser, IPCustomEntity = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)"
"d04f74bc-1709-4739-8fbb-ebb2e381626f","Invoke-PowerShellTcpOneLine Usage.","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","Invoke-PowerShellTcpOneLine is a PowerShell script to create a simple and small reverse shell. It can be abused by attackers to exfiltrate data. This query looks for command line activity similar to Invoke-PowerShellTcpOneLine.'
","SecurityEvent
| where EventID == 4688
| where Process has_any (""powershell.exe"", ""PowerShell_ISE.exe"", ""cmd.exe"")
| where CommandLine has ""$client = New-Object System.Net.Sockets.TCPClient""
| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress"
"32ef4725-7bd6-4b12-a8a6-7e700101b35c","Suspected ProxyToken Exploitation","true","Hunting","none","AzureMonitor(IIS)","W3CIISLog","none","none","Looks for activity that might indicate exploitation of the ProxyToken vulnerability - CVE-2021-33766
Ref: https://www.zerodayinitiative.com/blog/2021/8/30/proxytoken-an-authentication-bypass-in-microsoft-exchange-server'
","W3CIISLog
| where not(ipv4_is_private(cIP))
| where csMethod =~ ""POST""
| where csUriStem has ""/ecp""
| where isnotempty(csCookie) and csCookie has ""SecurityToken""
| where csUriQuery has ""msExchEcpCanary""
| extend timestamp=TimeGenerated, HostCustomEntity=Computer, IPCustomEntity=cIP"
"103fdaad-003c-4b83-9f75-95777831749c","Malformed user agent","true","Detection","Medium","WAF","MultipleDataSources","1d","1d","本规则用于从AAD登录日志和WAF日志中找到存在用户代理字符串值硬编码的访问行为。报告显示有潜在的恶意软件攻击。恶意软件作者有时会在编写其恶意软件的网络通信组件时对用户代理字符串值进行硬编码。缺省告警条件是过去一小时内发生的恶意代码访问超过5次。","let timeframe=1h;
let threshold=5;
(union isfuzzy=true
(
AzureDiagnostics
| where TimeGenerated > ago(timeframe)
| where ResourceType =~ ""APPLICATIONGATEWAYS"" 
| where OperationName =~ ""ApplicationGatewayAccess"" 
| extend ClientIP = columnifexists(""clientIP_s"", ""None""), UserAgent = columnifexists(""userAgent_s"", ""None"")
| where UserAgent startswith ""User"" or UserAgent startswith '\""'
or (UserAgent startswith ""Mozilla"" and not(UserAgent containscs ""Mozilla""))
or UserAgent containscs  ""(Compatible;""
or UserAgent matches regex @""MSIE\s?;""
or UserAgent matches regex  @""MSIE(?:\d|.{1,5}?\d\s;)""
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), repeated = count() by UserAgent, SourceIP = ClientIP,   host_s, Type
| where repeated > threshold
),
//(
//union W3CIISLog
//| where isnotempty(csUserAgent)
//| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserAgent = csUserAgent, SourceIP = cIP, Account = csUserName, Type, sSiteName, csMethod, csUriStem
//),
(SigninLogs
| where isnotempty(UserAgent)
| where UserAgent startswith ""User"" or UserAgent startswith '\""'
or (UserAgent startswith ""Mozilla"" and not(UserAgent containscs ""Mozilla"")
)
or UserAgent containscs  ""(Compatible;""
or UserAgent matches regex @""MSIE\s?;""
or UserAgent matches regex  @""MSIE(?:\d|.{1,5}?\d\s;)""
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), repeated = count() by UserAgent, SourceIP = IPAddress, Account = UserPrincipalName, Type, tostring(LocationDetails), tostring(DeviceDetail), AppDisplayName, ClientAppUsed
| where repeated > threshold
)
)
| extend StartTime, EndTime,IPCustomEntity = SourceIP, AccountCustomEntity = Account"
"d485e408-9ec5-4ef4-b1ef-41c34af57059","Multiple RDP connections from Single System","true","Detection","Low","SecurityEvents","SecurityEvent","1d","8d","Identifies when an RDP connection is made to multiple systems and above the normal for the previous 7 days.  
Connections from the same system with the same account within the same day.
RDP connections are indicated by the EventID 4624 with LogonType = 10","let endtime = 1d;
let starttime = 8d;
let threshold = 2.0;
SecurityEvent
| where TimeGenerated >= ago(endtime) 
| where EventID == 4624 and LogonType == 10
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ComputerCountToday = dcount(Computer), ComputerSet = makeset(Computer), ProcessSet = makeset(ProcessName)  
by Account, IpAddress, AccountType, Activity, LogonTypeName
| join kind=inner (
SecurityEvent
| where TimeGenerated >= ago(starttime) and TimeGenerated < ago(endtime) 
| where EventID == 4624 and LogonType == 10
| summarize ComputerCountPrev7Days = dcount(Computer) by Account, IpAddress
) on Account, IpAddress
| extend Ratio = ComputerCountToday/(ComputerCountPrev7Days*1.0)
// Where the ratio of today to previous 7 days is more than double.
| where Ratio > threshold
| project StartTimeUtc, EndTimeUtc, Account, IpAddress, ComputerSet, ComputerCountToday, ComputerCountPrev7Days, Ratio, AccountType, Activity, LogonTypeName, ProcessSet
| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, IPCustomEntity = IpAddress"
"4c10b7e2-fb58-4502-a21a-b863ea8930aa","PowerShell downloads","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","本规则将扫描Windows安全日志以查找可能涉及下载的 PowerShell 执行事件","let timeframe = 1d;
let ProcessCreationEvents=() {
let processEvents=SecurityEvent
| where EventID==4688
| project  TimeGenerated, ComputerName=Computer,AccountName=SubjectUserName,        AccountDomain=SubjectDomainName,
  FileName=tostring(split(NewProcessName, '\\')[-1]),
ProcessCommandLine = CommandLine, 
InitiatingProcessFileName=ParentProcessName,InitiatingProcessCommandLine="""",InitiatingProcessParentFileName="""";
processEvents};
ProcessCreationEvents
| where TimeGenerated >= ago(timeframe) 
| where FileName in~ (""powershell.exe"", ""powershell_ise.exe"")
| where ProcessCommandLine has ""Net.WebClient""
   or ProcessCommandLine has ""DownloadFile""
   or ProcessCommandLine has ""Invoke-WebRequest""
   or ProcessCommandLine has ""Invoke-Shellcode""
   or ProcessCommandLine contains ""http:""
| project TimeGenerated, ComputerName, AccountName, InitiatingProcessFileName, FileName, ProcessCommandLine
| top 100 by TimeGenerated
| extend timestamp = TimeGenerated, HostCustomEntity = ComputerName, AccountCustomEntity = AccountName"
"139111b6-e1fb-4b98-b272-40bbfd77f5ef","Starting or Stopping HealthService to Avoid Detection","false","Detection","Medium","SecurityEvents","SecurityEvent","1d","1d","此查询检测参与者停止或启动 HealthService 以禁用来自代理的遥测收集/检测的事件。该查询需要 SACL 来审核对服务的访问请求。","SecurityEvent
| where EventID == 4656
| extend EventData = parse_xml(EventData).EventData.Data
| mv-expand bagexpansion=array EventData
| evaluate bag_unpack(EventData)
| extend Key=tostring(['@Name']), Value=['#text']
| evaluate pivot(Key, any(Value), TimeGenerated, TargetAccount, Computer, EventSourceName, Channel, Task, Level, EventID, Activity, TargetLogonId, SourceComputerId, EventOriginId, Type, _ResourceId, TenantId, SourceSystem, ManagementGroupName, IpAddress, Account)
| where ObjectServer =~ ""SC Manager"" and ObjectType =~ ""SERVICE OBJECT"" and ObjectName =~ ""HealthService""
// Comment out the join below if the SACL only audits users that are part of the Network logon users, i.e. with user/group target pointing to ""NU.""
| join kind=leftouter (
  SecurityEvent
  | where EventID == 4624
) on TargetLogonId
| project TimeGenerated, Computer, Account, TargetAccount, IpAddress
| extend timestamp = TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account, IPCustomEntity = IpAddress"
"14502f0b-86c5-4fc7-aa21-c02dbbe768b4","Storage Account Key Enumeration","true","Hunting","none","AzureActiveDirectory","MultipleDataSources","none","none","This query identifies attackers trying to enumerate the Storage keys as well as updating roles using AzureActivity,SigninLogs 
and  AuditLogs'
","SigninLogs 
 | where ResultType == ""0"" 
 | where AppDisplayName !in (""Office 365 Exchange Online"", ""Skype for Business Online"", ""Office 365 SharePoint Online"")
 | project  SuccessLogonTime = TimeGenerated,UserPrincipalName, IPAddress,SuccessAppDisplayName = AppDisplayName
 |  join kind=inner
 (
 AzureActivity
 | where tolower(OperationNameValue) endswith ""listkeys/action""
 | where ActivityStatus =~ ""Succeeded""
 | project CallerIpAddress, _ResourceId, _SubscriptionId, ActivityStatus, Category, Authorization,OperationName
 )
 on $left.IPAddress == $right. CallerIpAddress
 | project _SubscriptionId, ActivityStatus, IPAddress, OperationName, UserPrincipalName
 | join kind=inner 
 (
 AuditLogs
 | where LoggedByService =~ ""Core Directory""
 | where Category =~ ""RoleManagement""
 | extend IpAddress = case(
  isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)) and tostring(parse_json(tostring(InitiatedBy.user)).ipAddress) != 'null', tostring(parse_json(tostring(InitiatedBy.user)).ipAddress), 
 isnotempty(tostring(parse_json(tostring(InitiatedBy.app)).ipAddress)) and tostring(parse_json(tostring(InitiatedBy.app)).ipAddress) != 'null', tostring(parse_json(tostring(InitiatedBy.app)).ipAddress),'Not Available')
 | extend InitiatedBy = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), 
   tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), tostring(parse_json(tostring(InitiatedBy.app)).displayName)), UserRoles = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)
 | extend TargetResourceName = tolower(tostring(TargetResources.[0].displayName))  
 ) 
 on $left. IPAddress == $right. IpAddress
 | summarize count () by TimeGenerated,IPCustomEntity=IpAddress,UserRoles,AccountCustomEntity=InitiatedBy,TargetResourceName"
"8d381804-3af5-4774-bd25-5b2b436a27ee","Certutil (LOLBins and LOLScripts)","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","This detection uses Sysmon telemetry to hunt Certutil activities'
","Event
//This query uses sysmon data depending on table name used this may need updataing
| where Source == ""Microsoft-Windows-Sysmon""
| where EventID == 1
| extend RenderedDescription = tostring(split(RenderedDescription, "":"")[0])
| extend EventData = parse_xml(EventData).DataItem.EventData.Data
| mv-expand bagexpansion=array EventData
| evaluate bag_unpack(EventData)
| extend Key=tostring(['@Name']), Value=['#text']
| evaluate pivot(Key, any(Value), TimeGenerated, Source, EventLog, Computer, EventLevel, EventLevelName, EventID, UserName, RenderedDescription, MG, ManagementGroupName, Type, _ResourceId)
| extend RuleName = column_ifexists(""RuleName"", """"), TechniqueId = column_ifexists(""TechniqueId"", """"),  TechniqueName = column_ifexists(""TechniqueName"", """")
| parse RuleName with * 'technique_id=' TechniqueId ',' * 'technique_name=' TechniqueName
| where Image has ""certutil.exe""
// Uncomment the next line and add your commandLine Whitelisted/ignore terms.For example ""urlcache""
// | where CommandLine !contains (""urlcache"") 
| extend HostCustomEntity = Computer, AccountCustomEntity = UserName"
"12022d8f-3cbf-4867-9d30-750f91433c9e","Failed AzureAD logons but success logon to host","true","Detection","Medium","AzureActiveDirectory","MultipleDataSources","1d","1d","本规则将对从同一个 IP 地址尝试多次 Azure Active Directory 的失败登录尝（默认为 5）但同时出现该IP通过了对虚拟机的SSH远程登录。","let timeframe = 1d;
//Adjust this threshold to fit the environment
let signin_threshold = 5;
//Make a list of all IPs with failed signins to AAD above our threshold
let suspicious_signins =
SigninLogs
| where TimeGenerated >= ago(timeframe)
| where ResultType !in (""0"", ""50125"", ""50140"")
| where IPAddress != ""127.0.0.1""
| summarize count() by IPAddress
| where count_ > signin_threshold
| summarize make_list(IPAddress);
//See if any of these IPs have sucessfully logged into *nix hosts
let linux_logons =
Syslog
| where TimeGenerated >= ago(timeframe)
| where Facility contains ""auth"" and ProcessName != ""sudo""
| where SyslogMessage has ""Accepted""
| extend SourceIP = extract(""(([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.(([0-9]{1,3})))"",1,SyslogMessage)
| where SourceIP in (suspicious_signins)
| extend Reason = ""Multiple failed AAD logins from IP address""
| project TimeGenerated, Computer, HostIP, IpAddress = SourceIP, SyslogMessage, Facility, ProcessName, Reason;
//See if any of these IPs have sucessfully logged into Windows hosts
let win_logons =
SecurityEvent
| where TimeGenerated >= ago(timeframe)
| where EventID == 4624
| where LogonType in (10, 7, 3)
| where IpAddress != ""-""
| where IpAddress in (suspicious_signins)
| extend Reason = ""Multiple failed AAD logins from IP address""
| project TimeGenerated, Account, AccountType, Computer, Activity, EventID, LogonProcessName, IpAddress, LogonTypeName, TargetUserSid, Reason;
union isfuzzy=true linux_logons
| extend timestamp = TimeGenerated, AccountCustomEntity = column_ifexists('Account',''), IPCustomEntity = IpAddress, HostCustomEntity = Computer"
"706085b8-3d2b-4013-9ec8-61ff946f5bc3","Retrospective hunt for STRONTIUM IP IOCs","true","Hunting","none","CiscoASA","MultipleDataSources","none","none","Matches domain name IOCs related to Strontium group activity with CommonSecurityLog and SecurityAlert dataTypes.
The query is scoped in the time window that these IOCs were active.
References: https://blogs.microsoft.com/on-the-issues/2019/07/17/new-cyberthreats-require-new-ways-to-protect-democracy.","let STRONTIUM_IPS = dynamic([""82.118.242.171"" , ""167.114.153.55"" , ""94.237.37.28"", ""31.220.61.251"" , ""128.199.199.187"" ]);
(union isfuzzy=true
(CommonSecurityLog
| where TimeGenerated between (startofday(datetime(2019-02-01)) .. endofday(datetime(2019-08-05)))
| where SourceIP in (STRONTIUM_IPS) or DestinationIP in (STRONTIUM_IPS)
| extend IPCustomEntity = SourceIP
),
(SecurityAlert
| where TimeGenerated between (startofday(datetime(2019-02-01)) .. endofday(datetime(2019-08-05)))
| extend RemoteAddress = iff(ExtendedProperties has ""RemoteAddress"", tostring(parse_json(ExtendedProperties)[""RemoteAddress""]), ""None"")
| where RemoteAddress != ""None""
| where RemoteAddress in (STRONTIUM_IPS)
| extend IPCustomEntity = RemoteAddress
) 
)
| extend timestamp = TimeGenerated"
"3d56ea4a-e3bc-4581-be5f-47e17ad57357","Account added and removed from privileged groups","true","Detection","Low","SecurityEvents","SecurityEvent","1d","1d","Identifies accounts that are added to privileged group and then quickly removed, which could be a sign of compromise.","let timeframe = 1d;
let WellKnownLocalSID = ""S-1-5-32-5[0-9][0-9]$"";
let WellKnownGroupSID = ""S-1-5-21-[0-9]*-[0-9]*-[0-9]*-5[0-9][0-9]$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1102$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1103$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-498$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1000$"";
let AC_Add = 
SecurityEvent
| where TimeGenerated >= ago(timeframe)
// Event ID related to member addition.
| where EventID in (4728, 4732,4756) 
| where TargetSid matches regex WellKnownLocalSID or TargetSid matches regex WellKnownGroupSID  
| parse EventData with * '""MemberName"">' AccountAdded "",OU"" * 
| where isnotempty(AccountAdded)
| extend GroupAddedTo = TargetUserName, AddingAccount = Account 
| extend  AccountAdded_GroupAddedTo_AddingAccount = strcat(AccountAdded, ""||"", GroupAddedTo, ""||"", AddingAccount )
| project AccountAdded_GroupAddedTo_AddingAccount, AccountAddedTime = TimeGenerated;
let AC_Remove = 
SecurityEvent
| where TimeGenerated >= ago(timeframe)
// Event IDs related to member removal.
| where EventID in (4729,4733,4757)
| where TargetSid matches regex WellKnownLocalSID or TargetSid matches regex WellKnownGroupSID 
| parse EventData with * '""MemberName"">' AccountRemoved "",OU"" * 
| where isnotempty(AccountRemoved)
| extend GroupRemovedFrom = TargetUserName, RemovingAccount = Account
| extend AccountRemoved_GroupRemovedFrom_RemovingAccount = strcat(AccountRemoved, ""||"", GroupRemovedFrom, ""||"", RemovingAccount)
| project AccountRemoved_GroupRemovedFrom_RemovingAccount, AccountRemovedTime = TimeGenerated, Computer, RemovedAccountId = tolower(AccountRemoved), 
RemovedByUser = SubjectUserName, RemovedByUserLogonId = SubjectLogonId,  GroupRemovedFrom = TargetUserName, TargetDomainName; 
AC_Add 
| join kind= inner AC_Remove on $left.AccountAdded_GroupAddedTo_AddingAccount == $right.AccountRemoved_GroupRemovedFrom_RemovingAccount 
| extend DurationinSecondAfter_Removed = datetime_diff ('second', AccountRemovedTime, AccountAddedTime)
| where DurationinSecondAfter_Removed > 0
| project-away AccountRemoved_GroupRemovedFrom_RemovingAccount
| extend timestamp = AccountAddedTime, AccountCustomEntity = RemovedAccountId, HostCustomEntity = Computer"
"863097c5-088f-4cee-bca0-2f0301f0e102","Mail.Read Permissions Granted to Application","true","Detection","Medium","AzureActiveDirectory","AuditLogs","1d","1d","此查询查找已被授予（委托或应用程序/角色）读取邮件权限（权限字段为 Mail.Read）且随后已被同意的应用程序。 这有助于识别被滥用以访问邮箱的应用程序。","AuditLogs
| where Category =~ ""ApplicationManagement""
| where ActivityDisplayName has_any (""Add delegated permission grant"",""Add app role assignment to service principal"")
| where Result =~ ""success""
| where tostring(InitiatedBy.user.userPrincipalName) has ""@"" or tostring(InitiatedBy.app.displayName) has ""@""
| extend props = parse_json(tostring(TargetResources[0].modifiedProperties))
| mv-expand props
| extend UserAgent = tostring(AdditionalDetails[0].value)
| extend InitiatingUser = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| extend UserIPAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)
| extend DisplayName = tostring(props.displayName)
| extend Permissions = tostring(parse_json(tostring(props.newValue)))
| where Permissions has_any (""Mail.Read"", ""Mail.ReadWrite"")
| extend PermissionsAddedTo = tostring(TargetResources[0].displayName)
| extend Type = tostring(TargetResources[0].type)
| project-away props
| join kind=leftouter(
  AuditLogs
  | where ActivityDisplayName has ""Consent to application""
  | extend AppName = tostring(TargetResources[0].displayName)
  | extend AppId = tostring(TargetResources[0].id)
  | project AppName, AppId, CorrelationId) on CorrelationId
| project-reorder TimeGenerated, OperationName, InitiatingUser, UserIPAddress, UserAgent, PermissionsAddedTo, Permissions, AppName, AppId, CorrelationId
| extend timestamp = TimeGenerated, AccountCustomEntity = InitiatingUser, IPCustomEntity = UserIPAddress"
"82510eb3-4517-45eb-9743-ae3ef50b4525","Suspicious application consent similar to PwnAuth","true","Detection","Medium","AzureActiveDirectory","AuditLogs","1d","14d","本规则将在发现用户为应用程序申请权限包含 user.read、offline_access、mail.readwrite、mail.send 和 files.read.all的时候发出警告。请详细确认Application是否是安全可信的应用程序。 有关 AuditLogs 的更多信息，请参阅 https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities","let detectionTime = 1d;
let joinLookback = 14d;
AuditLogs
| where TimeGenerated > ago(detectionTime)
| where LoggedByService =~ ""Core Directory""
| where Category =~ ""ApplicationManagement""
| where OperationName =~ ""Consent to application""
| where TargetResources has ""offline""
| extend AppDisplayName = TargetResources.[0].displayName
| extend AppClientId = tolower(TargetResources.[0].id)
//| where AppClientId !in ((externaldata(knownAppClientId:string, knownAppDisplayName:string)[@""https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/Microsoft.OAuth.KnownApplications.csv""] with (format=""csv"")))
| extend ConsentFull = TargetResources[0].modifiedProperties[4].newValue
| parse ConsentFull with * ""ConsentType: "" GrantConsentType "", Scope: "" GrantScope1 ""]"" *
| where ConsentFull contains ""user.read"" and ConsentFull contains ""offline_access"" and ConsentFull contains ""mail.readwrite"" and ConsentFull contains ""mail.send"" and ConsentFull contains ""files.read.all""
| where GrantConsentType != ""AllPrincipals"" // NOTE: we are ignoring if OAuth application was granted to all users via an admin - but admin due diligence should be audited occasionally
| extend GrantIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress)
| extend GrantInitiatedBy = iff(isnotempty(InitiatedBy.user.userPrincipalName),InitiatedBy.user.userPrincipalName, InitiatedBy.app.displayName)
| extend GrantUserAgent = iff(AdditionalDetails[0].key =~ ""User-Agent"", AdditionalDetails[0].value, """")
| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, GrantIpAddress, GrantUserAgent, AppClientId, OperationName, ConsentFull, CorrelationId
| join kind = leftouter (AuditLogs
| where TimeGenerated > ago(joinLookback)
| where LoggedByService =~ ""Core Directory""
| where Category =~ ""ApplicationManagement""
| where OperationName =~ ""Add service principal""
| extend AppClientId = tolower(TargetResources[0].id)
| extend AppReplyURLs = iff(TargetResources[0].modifiedProperties[1].newValue has ""AddressType"", TargetResources[0].modifiedProperties[1].newValue, """")
| distinct AppClientId, tostring(AppReplyURLs)
)
on AppClientId
| join kind = innerunique (AuditLogs
| where TimeGenerated > ago(joinLookback)
| where LoggedByService =~ ""Core Directory""
| where Category =~ ""ApplicationManagement""
| where OperationName =~ ""Add OAuth2PermissionGrant"" or OperationName =~ ""Add delegated permission grant""
| extend GrantAuthentication = tostring(TargetResources[0].displayName)
| extend GrantOperation = OperationName
| project GrantAuthentication, GrantOperation, CorrelationId
) on CorrelationId
| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, AppReplyURLs, GrantIpAddress, GrantUserAgent, AppClientId, GrantAuthentication, OperationName, GrantOperation, CorrelationId, ConsentFull"
"5d5815ac-1aca-4bc5-93b2-f6fced64e26f","Anomalous sign-in location by user account and authenticating application - with sign-in details","true","Hunting","none","AzureActiveDirectory","SigninLogs","none","none","本规则将扫描 Azure Active Directory 登录日志。尝试找出最异常的变化个人申请以及具体的登录位置和时间信息。 目的是寻找用户帐户泄露的可能性","let timeframe = ago(14d);
SigninLogs 
// Forces Log Analytics to recognize that the query should be run over full time range
| where TimeGenerated >= timeframe
| extend  locationString= strcat(tostring(LocationDetails[""countryOrRegion""]), ""/"", 
tostring(LocationDetails[""state""]), ""/"", tostring(LocationDetails[""city""]), "";"") 
| project TimeGenerated, AppDisplayName , UserPrincipalName, locationString 
// Create time series 
| make-series dLocationCount = dcount(locationString) on TimeGenerated in range(timeframe,now(), 1d) 
by UserPrincipalName, AppDisplayName 
// Compute best fit line for each entry 
| extend (RSquare,Slope,Variance,RVariance,Interception,LineFit)=series_fit_line(dLocationCount) 
// Chart the 3 most interesting lines  
// A 0-value slope corresponds to an account being completely stable over time for a given Azure Active Directory application
| top 3 by Slope desc  
// Extract the set of locations for each top user:
| join kind=inner (SigninLogs
| where TimeGenerated >= timeframe
| extend  locationString= strcat(tostring(LocationDetails[""countryOrRegion""]), ""/"", 
tostring(LocationDetails[""state""]), ""/"", tostring(LocationDetails[""city""]), "";"")
| summarize locationList = makeset(locationString), threeDayWindowLocationCount=dcount(locationString) by AppDisplayName, UserPrincipalName, 
timeframe=bin(TimeGenerated, 3d)) on AppDisplayName, UserPrincipalName
| order by UserPrincipalName, timeframe asc
| project timeframe, AppDisplayName , UserPrincipalName, threeDayWindowLocationCount, locationList 
| order by AppDisplayName, UserPrincipalName, timeframe asc
| extend timestamp = timeframe, AccountCustomEntity = UserPrincipalName"
"92f3f605-880d-4df2-9833-ccd137ea3e8c","Distributed Password cracking attempts in AzureAD","true","Detection","Medium","AzureActiveDirectory","SigninLogs","1d","1d","本规则从 Azure Active Directory 登录日志识别分布式密码破解尝试。
参考资料：https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes
50053 帐户被锁定，因为用户尝试使用错误的用户 ID 或密码登录的次数过多。
50055 密码无效，输入的密码已过期。
50056 密码无效或为空 - 存储中不存在此用户的密码。
50126 无效的用户名或密码，或无效的本地用户名或密码","let timeframe = 1d;
let s_threshold = 30;
let l_threshold = 3;
SigninLogs
| where TimeGenerated >= ago(timeframe)
| where OperationName =~ ""Sign-in activity""
// Error codes that we want to look at as they are related to the use of incorrect password.
| where ResultType in (""50126"", ""50053"" , ""50055"", ""50056"")
| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser 
| extend LocationString= strcat(tostring(LocationDetails[""countryOrRegion""]), ""/"", tostring(LocationDetails[""state""]), ""/"", tostring(LocationDetails[""city""]))
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated),LocationCount=dcount(LocationString), Location = make_set(LocationString), 
IPAddress = make_set(IPAddress), IPAddressCount = dcount(IPAddress), AppDisplayName = make_set(AppDisplayName), ResultDescription = make_set(ResultDescription), 
Browser = make_set(Browser), OS = make_set(OS), SigninCount = count() by UserPrincipalName                               
// Setting a generic threshold - Can be different for different environment
| where SigninCount > s_threshold and LocationCount >= l_threshold
| extend tostring(Location), tostring(IPAddress), tostring(AppDisplayName), tostring(ResultDescription), tostring(Browser), tostring(OS)
| distinct *
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress"
"6fd710cc-a824-499d-b9a2-293a7d987667","SecurityEvent - Multiple authentication failures followed by a success","true","Detection","Low","SecurityEvents","SecurityEvent","6h","6h","Identifies accounts who have failed to logon to the domain multiple times in a row, followed by a successful authentication
within a short time frame. Multiple failed attempts followed by a success can be an indication of a brute force attempt or
possible mis-configuration of a service account within an environment.
The lookback is set to 6h and the authentication window and threshold are set to 1h and 5, meaning we need to see a minimum
of 5 failures followed by a success for an account within 1 hour to surface an alert.","let timeframe = 6h;
let authenticationWindow = 1h;
let authenticationThreshold = 5;
SecurityEvent
| where TimeGenerated > ago(timeframe)
| where EventID == 4624 or EventID == 4625
| where IpAddress != ""-"" and isnotempty(Account)
| extend Outcome = iff(EventID == 4624, ""Success"", ""Failure"")
// bin outcomes into 5 minute windows to reduce the volume of data
| summarize OutcomeCount=count() by Account, IpAddress, Computer, Outcome, bin(TimeGenerated, 5m)
| project TimeGenerated, Account, IpAddress, Computer, Outcome, OutcomeCount
// sort ready for sessionizing - by account and time of the authentication outcome
| sort by Account asc, TimeGenerated asc
| serialize 
// sessionize into failure groupings until either the account changes or there is a success
| extend SessionStartedUtc = row_window_session(TimeGenerated, timeframe, authenticationWindow, Account != prev(Account) or prev(Outcome) == ""Success"")
// count the failures in each session
| summarize FailureCountBeforeSuccess=sumif(OutcomeCount, Outcome == ""Failure""), StartTime=min(TimeGenerated), EndTime=max(TimeGenerated), makelist(Outcome), makeset(Computer), makeset(IpAddress) by SessionStartedUtc, Account
// the session must not start with a success, and must end with one
| where array_index_of(list_Outcome, ""Success"") != 0
| where array_index_of(list_Outcome, ""Success"") == array_length(list_Outcome) - 1
| project-away SessionStartedUtc, list_Outcome 
// where the number of failures before the success is above the threshold 
| where FailureCountBeforeSuccess >= authenticationThreshold
// expand out ip and computer for customer entity assignment
| mvexpand set_IpAddress, set_Computer
| extend IpAddress = tostring(set_IpAddress), Computer = tostring(set_Computer)
| extend timestamp=StartTime, AccountCustomEntity=Account, HostCustomEntity=Computer, IPCustomEntity=IpAddress"
"3492fe39-bc26-4349-8aa1-982beabca55b","Attempt to bypass conditional access rule in Azure AD","true","Detection","Low","AzureActiveDirectory","SigninLogs","1d","1d","本规则将检查绕过 Azure Active Directory 中的条件访问规则的尝试。ConditionalAccessStatus 列值详细说明是否尝试绕过条件访问或者如果不满足条件访问规则（ConditionalAccessStatus == 1). 参考：
https://docs.microsoft.com/azure/active-directory/conditional-access/overview
https://docs.microsoft.com/azure/active-directory/reports-monitoring/concept-sign-ins
https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes
ConditionalAccessStatus == 0 // 成功
ConditionalAccessStatus == 1 // 失败
ConditionalAccessStatus == 2 // 未应用
ConditionalAccessStatus == 3 // 未知","let timeframe = ago(1d);
let threshold = 1;
SigninLogs
| where TimeGenerated >= timeframe
| where ConditionalAccessStatus == 1 or ConditionalAccessStatus =~ ""failure""
| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser 
| extend StatusCode = tostring(Status.errorCode), StatusDetails = tostring(Status.additionalDetails)
| extend ConditionalAccessPol0Name = tostring(ConditionalAccessPolicies[0].displayName)
| extend ConditionalAccessPol1Name = tostring(ConditionalAccessPolicies[1].displayName)
| extend ConditionalAccessPol2Name = tostring(ConditionalAccessPolicies[2].displayName)
| extend Status = strcat(StatusCode, "": "", ResultDescription) 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Status = makelist(Status), StatusDetails = makelist(StatusDetails), IPAddresses = makelist(IPAddress), IPAddressCount = dcount(IPAddress) , CorrelationIds = makelist(CorrelationId) by UserPrincipalName, AppDisplayName, tostring(Browser), tostring(OS), Location, ConditionalAccessPol0Name, ConditionalAccessPol1Name, ConditionalAccessPol2Name
| where IPAddressCount > threshold and StatusDetails !has ""MFA successfully completed""
| mvexpand IPAddresses, Status, StatusDetails, CorrelationIds
| extend Status = strcat(Status, "" "", StatusDetails)
| summarize IPAddresses = makeset(IPAddresses), Status = makeset(Status), CorrelationIds = makeset(CorrelationIds) by StartTimeUtc, EndTimeUtc, UserPrincipalName, AppDisplayName, tostring(Browser), tostring(OS), Location, ConditionalAccessPol0Name, ConditionalAccessPol1Name, ConditionalAccessPol2Name, IPAddressCount
| extend timestamp = StartTimeUtc, AccountCustomEntity = UserPrincipalName, IPCustomEntity = tostring(IPAddresses)"
"8a8677bd-f892-435c-aa5c-0ccd4415241d","Nishang Reverse TCP Shell in Base64","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","Looks for Base64-encoded commands associated with the Nishang reverse TCP shell.
Ref: https://github.com/samratashok/nishang/blob/master/Shells/Invoke-PowerShellTcp.ps1'
","SecurityEvent
| where EventID == 4688
| where Process in(""powershell.exe"",""powershell_ise.exe"") and CommandLine contains ""-e"" 
| mvexpand SS = split(CommandLine, "" "") 
| where SS matches regex ""[A-Za-z0-9+/]{50,}[=]{0,2}"" 
| extend DecodeString = base64_decodestring(tostring(SS)) 
| extend FinalString = replace(""\\0"", """", DecodeString) 
| where FinalString has ""tcpclient"" and FinalString contains ""$"" and (FinalString contains ""invoke"" or FinalString contains ""iex"") 
| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer"
"58ba1343-9ac8-4907-8218-6c0834874d4a","Summary of failed user logons by reason of failure","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","本规则将对Windows 登录失败的记录做摘要总结。 以此来分析可能的横向攻击","let timeframe = 1d;
SecurityEvent
| where TimeGenerated >= ago(timeframe)
| where AccountType == 'User' and EventID == 4625
| extend Reason = case(
SubStatus == '0xc000005e', 'No logon servers available to service the logon request',
SubStatus == '0xc0000062', 'Account name is not properly formatted',
SubStatus == '0xc0000064', 'Account name does not exist',
SubStatus == '0xc000006a', 'Incorrect password',    SubStatus == '0xc000006d', 'Bad user name or password',
SubStatus == '0xc000006f', 'User logon blocked by account restriction',
SubStatus == '0xc000006f', 'User logon outside of restricted logon hours',
SubStatus == '0xc0000070', 'User logon blocked by workstation restriction',
SubStatus == '0xc0000071', 'Password has expired',
SubStatus == '0xc0000072', 'Account is disabled',
SubStatus == '0xc0000133', 'Clocks between DC and other computer too far out of sync',
SubStatus == '0xc000015b', 'The user has not been granted the requested logon right at this machine',
SubStatus == '0xc0000193', 'Account has expirated',
SubStatus == '0xc0000224', 'User is required to change password at next logon',
SubStatus == '0xc0000234', 'Account is currently locked out',
strcat('Unknown reason substatus: ', SubStatus))
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count() by Reason
| extend timestamp = StartTimeUtc"
"862dcb79-b513-4443-b30c-346ec2a1dfa3","honeypot security alert","true","Detection","Medium","honeypot","Syslog","10m","10m","本规则将检测蜜罐服务安全告警","Syslog
| where Facility =~ 'local0'
| where ProcessName =~ 'honeypot'
| extend rawmesssage = iff(SyslogMessage contains 'message repeated', substring(SyslogMessage,indexof(SyslogMessage,'times: [')+8,strlen(SyslogMessage)-indexof(SyslogMessage,'times: [')-9),SyslogMessage)
| extend id = extractjson( ""$['id']"" ,rawmesssage), event_type= extractjson(""$['event_type']"",rawmesssage), event_type_display_name = extractjson(""$['event_type_display_name']['cn']"",rawmesssage), src_ip = extractjson(""$['src_ip']"",rawmesssage), src_port = extractjson(""$['src_port']"",rawmesssage), dest_ip = extractjson(""$['dest_ip']"",rawmesssage), dest_port = extractjson(""$['dest_port']"",rawmesssage), extra = extractjson(""$['extra']"",rawmesssage), risk_level_value = toint(extractjson(""$['risk_level']"",rawmesssage)), source = extractjson(""$['source']"",rawmesssage)
| extend risk_level = case(risk_level_value == 4, ""高"", 
                           risk_level_value == 3, ""中"", 
                           risk_level_value == 2, ""低"", 
                           ""信息""
                        )
| project EventTime, source, event_type, event_type_display_name, src_ip,  src_port, dest_ip, dest_port, risk_level, extra ,rawmesssage"
"20a82d9f-2a3a-42be-9c77-b283491dc4e9","Alerts related to account","true","Hunting","none","AzureSecurityCenter","SecurityAlert","none","none","本规则将返回来自给定账号相关的任何Azure安全中的的警报,默认查询区间是过去3天","let GetAllAlertsForUser = (suspiciousEventTime:datetime, v_User:string){
//-3d and +6h as some alerts fire after accumulation of events
let v_StartTime = suspiciousEventTime-3d;
let v_EndTime = suspiciousEventTime+6h;
SecurityAlert
| where TimeGenerated between (v_StartTime .. v_EndTime)
// expand JSON properties
| extend Extprop = parsejson(ExtendedProperties)
| extend Computer = iff(isnotempty(toupper(tostring(Extprop[""Compromised Host""]))), toupper(tostring(Extprop[""Compromised Host""])), tostring(parse_json(Entities)[0].HostName))
| extend Account = iff(isnotempty(tolower(tostring(Extprop[""User Name""]))), tolower(tostring(Extprop[""User Name""])), tolower(tostring(Extprop[""user name""])))
| extend IpAddress = tostring(parse_json(ExtendedProperties).[""Client Address""]) 
| where Account contains v_User
| project TimeGenerated, AlertName, Computer, Account, IpAddress, ExtendedProperties 
| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress
};
// change datetime value and username value below
GetAllAlertsForUser(now(), toupper(""{user_name}""))"
"4a28dbbb-7616-4f41-bee0-a4e4862a0516","OMI Vulnerability Exploitation","true","Detection","Medium","Heartbeat","Heartbeat","1d","1d","此查询将检查OMS agen版本以避免遇到2021 年 9 月 14 日发布三个提权 (EoP) 漏洞（CVE-2021-38645、CVE-2021-38649、CVE-2021-38648）和一个未经身份验证的远程代码执行（RCE）漏洞（CVE-2021-38647) 。此检测将检查过去一天从所有代理收到的心跳，并为未更新的代理创建警报。","let OMIVulnerabilityPatchVersion = ""OMIVulnerabilityPatchVersion:1.13.40-0"";
Heartbeat
| where Category == ""Direct Agent""
| summarize arg_max(TimeGenerated,*) by Computer
| parse strcat(""Version:"" , Version) with * ""Version:"" Major:long "".""
Minor:long ""."" Patch:long ""-"" *
| parse OMIVulnerabilityPatchVersion with * ""OMIVulnerabilityPatchVersion:""
OMIVersionMajor:long ""."" OMIVersionMinor:long ""."" OMIVersionPatch:long ""-"" *
| where Major <OMIVersionMajor or (Major==OMIVersionMajor and Minor
<OMIVersionMinor) or (Major==OMIVersionMajor and Minor==OMIVersionMinor and
Patch<OMIVersionPatch) 
| project Version, Major,Minor,Patch,
Computer,ComputerIP,OSType,OSName,ResourceId"
"16eeb482-990b-40d4-9280-1875f77adf14","Disabled accounts using Squid proxy","true","Hunting","none","Syslog","Syslog","none","none","本规则将标识被 AAD 记录为禁用账号。但仍被用于Linux Squid proxy进程。回顾时间是7天","let starttime = 14d;
let endtime = 7d;
let disabledAccounts = (){
SigninLogs 
| where TimeGenerated between(ago(starttime) .. ago(endtime))
| where ResultType == 50057
| where ResultDescription =~ ""User account is disabled. The account has been disabled by an administrator."" 
};
let proxyEvents = (){
Syslog
| where TimeGenerated > ago(endtime)
| where ProcessName contains ""squid""
| extend URL = extract(""(([A-Z]+ [a-z]{4,5}:\\/\\/)|[A-Z]+ )([^ :]*)"",3,SyslogMessage), 
         SourceIP = extract(""([0-9]+ )(([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3}))"",2,SyslogMessage), 
         Status = extract(""(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))"",1,SyslogMessage), 
         HTTP_Status_Code = extract(""(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))/([0-9]{3})"",8,SyslogMessage),
         User = extract(""(CONNECT |GET )([^ ]* )([^ ]+)"",3,SyslogMessage),
         RemotePort = extract(""(CONNECT |GET )([^ ]*)(:)([0-9]*)"",4,SyslogMessage),
         Domain = extract(""(([A-Z]+ [a-z]{4,5}:\\/\\/)|[A-Z]+ )([^ :\\/]*)"",3,SyslogMessage),
         Bytes = toint(extract(""([A-Z]+\\/[0-9]{3} )([0-9]+)"",2,SyslogMessage)),
         contentType = extract(""([a-z/]+$)"",1,SyslogMessage)
| extend TLD = extract(""\\.[a-z]*$"",0,Domain)
};
proxyEvents 
| where Status !contains 'DENIED'
| join kind=inner disabledAccounts on $left.User == $right.UserPrincipalName
| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, URLCustomEntity = URL"
"1dce97e5-6355-497e-a3e4-2f927dcabe81","Rare User Agent strings","true","Hunting","none","AzureMonitor(IIS)","W3CIISLog","none","none","This will check for Rare User Agent strings over the last 3 days.  This can indicate potential probing of your IIS servers.","let timeframe = 3d;
W3CIISLog | where TimeGenerated >= ago(timeframe)
// The below line can be used to exclude local IPs if these create noise
//| where cIP !startswith ""192.168."" and cIP != ""::1""
| where isnotempty(csUserAgent) and csUserAgent !in~ (""-"", ""MSRPC"")
| extend csUserAgent_size = string_size(csUserAgent)
| project TimeGenerated, sSiteName, sPort, csUserAgent, csUserAgent_size, csUserName , csMethod, csUriStem, sIP, cIP, scStatus, 
scSubStatus, scWin32Status, csHost 
| join (
    W3CIISLog | where TimeGenerated >= ago(timeframe) 
	  // The below line can be used to exclude local IPs if these create noise
    //| where cIP !startswith ""192.168."" and cIP != ""::1""
    | where isnotempty(csUserAgent) and csUserAgent !in~ (""-"", ""MSRPC"") 
    | extend csUserAgent_size = string_size(csUserAgent)
    | summarize csUserAgent_count = count() by bin(csUserAgent_size, 1)
    | top 20 by csUserAgent_count asc nulls last 
) on csUserAgent_size
| project TimeGenerated, sSiteName, sPort, sIP, cIP, csUserAgent, csUserAgent_size, csUserAgent_count, csUserName , csMethod, csUriStem, 
scStatus, scSubStatus, scWin32Status, csHost
| extend timestamp = TimeGenerated, IPCustomEntity = cIP, HostCustomEntity = csHost, AccountCustomEntity = csUserName"
"8fde784c-0e9f-407b-9506-be95a905433f","Group created then added to built in domain local or global group","true","Detection","Medium","SecurityEvents","SecurityEvent","1h","1h","标识最近创建的组何时添加到特权内置域本地组或全局组，例如：Enterprise Admins，Cert Publishers 或 DnsAdmins。 请务必验证这是预期的添加。
参考：对于 AD SID 映射 - https://docs.microsoft.com/windows/security/identity-protection/access-control/active-directory-security-groups","let WellKnownLocalSID = ""S-1-5-32-5[0-9][0-9]$"";
let WellKnownGroupSID = ""S-1-5-21-[0-9]*-[0-9]*-[0-9]*-5[0-9][0-9]$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1102$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1103$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-498$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1000$"";
let GroupAddition = SecurityEvent 
// 4728 - A member was added to a security-enabled global group
// 4732 - A member was added to a security-enabled local group
// 4756 - A member was added to a security-enabled universal group  
| where EventID in (""4728"", ""4732"", ""4756"") 
| where AccountType =~ ""User"" and MemberName == ""-""
// Exclude Remote Desktop Users group: S-1-5-32-555
| where TargetSid !in (""S-1-5-32-555"")
| where TargetSid matches regex WellKnownLocalSID or TargetSid matches regex WellKnownGroupSID
| project GroupAddTime = TimeGenerated, GroupAddEventID = EventID, GroupAddActivity = Activity, GroupAddComputer = Computer, GroupAddTargetAccount = TargetAccount, 
GroupAddTargetSid = TargetSid, GroupAddSubjectAccount = SubjectAccount, GroupAddSubjectUserSid = SubjectUserSid, GroupSid = MemberSid;
let GroupCreated = SecurityEvent
// 4727 - A security-enabled global group was created
// 4731 - A security-enabled local group was created
// 4754 - A security-enabled universal group was created
| where EventID in (""4727"", ""4731"", ""4754"")
| where AccountType =~ ""User""
| project GroupCreateTime = TimeGenerated, GroupCreateEventID = EventID, GroupCreateActivity = Activity, GroupCreateComputer = Computer, GroupCreateTargetAccount = TargetAccount, 
GroupCreateSubjectAccount = SubjectAccount, GroupCreateSubjectUserSid = SubjectUserSid, GroupSid = TargetSid;
GroupCreated
| join (
GroupAddition
) on GroupSid 
| extend timestamp = GroupCreateTime, AccountCustomEntity = GroupCreateSubjectAccount, HostCustomEntity = GroupCreateComputer"
"b7a8b2aa-77cc-4979-b8e6-c0e43e810386","Suspect Mailbox Export on IIS/OWA","true","Hunting","none","AzureMonitor(IIS)","W3CIISLog","none","none","The hunting query looks for suspicious files accessed on a IIS server that might indicate exfiltration hosting.
This technique has been observed when exporting mailbox files from OWA servers.
Reference: https://www.volexity.com/blog/2020/12/14/dark-halo-leverages-solarwinds-compromise-to-breach-organizations/'
","let excludeIps = dynamic([""127.0.0.1"", ""::1""]);
let scriptingExt = dynamic([""aspx"", ""ashx"", ""asp""]);
W3CIISLog
| where csUriStem contains ""/owa/""
//The actor pulls a file back but won't send it any URI params
| where isempty(csUriQuery)
| extend file_ext = tostring(split(csUriStem, ""."")[-1])
//Giving your file a known scripting extension will throw an error
//rather than just serving the file as it will try to interpret the script
| where file_ext !in~ (scriptingExt)
//The actor was seen using image files, but we go wider in case they change this behaviour
//| where file_ext in~ (""jpg"", ""jpeg"", ""png"", ""bmp"")
| extend file_name = tostring(split(csUriStem, ""/"")[-1])
| where file_name != """"
| where cIP !in~ (excludeIps)
| project file_ext, csUriStem, file_name, Computer, cIP, sIP, TenantId, TimeGenerated
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), dcount(cIP), AccessingIPs=make_set(cIP), AccessTimes=make_set(TimeGenerated), Access=count() by TenantId, file_name, Computer, csUriStem
//Collection of the exfiltration will occur only once, lets check for 2 accesses in case they mess up
//Tailor this for hunting
| where Access <= 2 and dcount_cIP == 1
| extend timestamp = StartTime"
"5c3ffbdc-0e0f-49eb-8920-e2f311118738","Windows System Time changed on hosts","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","Identifies when the system time was changed on a Windows host which can indicate potential timestomping activities.
Reference: Event ID 4616 is only available when the full event collection is enabled - https://docs.microsoft.com/azure/sentinel/connect-windows-security-events'
","SecurityEvent
| where EventID == 4616
| where not(ProcessName has_any ("":\\Windows\\System32\\svchost.exe"", "":\\Program Files\\VMware\\VMware Tools\\vmtoolsd.exe""))
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by Computer, EventID, Activity, Account, AccountType, NewTime, PreviousTime, ProcessName, ProcessId, SubjectAccount, SubjectUserSid, SourceComputerId, _ResourceId
| extend timestamp = StartTime, HostCustomEntity = Computer, AccountCustomEntity = SubjectAccount"
"12fe46d6-f91e-4d17-926e-5c967e1566d3","Rare Audit activity initiated by User","true","Hunting","none","AzureActiveDirectory","AuditLogs","none","none","本规则将当前一天与过去 14 天的AAD审计日志进行比较，以识别新的用户发起的审计活动操作名称、用户主体名称、属性名称、新值。在尝试追踪与添加新用户相关的恶意活动时非常有用。","let current = 1d;
let auditLookback = 14d;
let AuditTrail = AuditLogs 
| where TimeGenerated >= ago(auditLookback) and TimeGenerated < ago(current) 
| extend InitiatedByUser = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| where isnotempty(InitiatedByUser)
| extend InitiatedByIPAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)
| extend ModProps = TargetResources.[0].modifiedProperties
| extend UserPrincipalName = tolower(tostring(TargetResources.[0].userPrincipalName))
| extend TargetResourceName = tolower(tostring(TargetResources.[0].displayName))
| mvexpand ModProps
| extend PropertyName = tostring(ModProps.displayName), newValue = replace(""\"""","""",tostring(ModProps.newValue))
| summarize count() by OperationName, InitiatedByUser, InitiatedByIPAddress, UserPrincipalName, PropertyName, newValue, TargetResourceName;
let AccountMods = AuditLogs 
| where TimeGenerated >= ago(current)
| extend InitiatedByUser = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| where isnotempty(InitiatedByUser)
| extend InitiatedByIPAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)
| extend ModProps = TargetResources.[0].modifiedProperties
| extend UserPrincipalName = tolower(tostring(TargetResources.[0].userPrincipalName))
| extend TargetResourceName = tolower(tostring(TargetResources.[0].displayName))
| mvexpand ModProps
| extend PropertyName = tostring(ModProps.displayName), newValue = replace(""\"""","""",tostring(ModProps.newValue))
| where PropertyName !in (""TargetId.UserType"", ""StsRefreshTokensValidFrom"", ""LastDirSyncTime"") and (PropertyName != ""Action Client Name"" and newValue != ""\""DirectorySync\"""") and (PropertyName != ""Included Updated Properties"" and newValue != ""\""LastDirSyncTime\"""")
| extend ModifiedProps = pack(""PropertyName"",PropertyName,""newValue"",newValue, ""Id"", Id, ""CorrelationId"", CorrelationId) 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Activity = make_bag(ModifiedProps) by Type, InitiatedByUser, InitiatedByIPAddress, UserPrincipalName, Category, OperationName, PropertyName, newValue, TargetResourceName;
let RareAudits = AccountMods | join kind= leftanti (
   AuditTrail 
) on OperationName, InitiatedByUser, InitiatedByIPAddress, UserPrincipalName, PropertyName, newValue;
RareAudits 
| summarize StartTimeUtc = min(StartTimeUtc), EndTimeUtc = max(EndTimeUtc), make_set(Activity) by InitiatedByUser, InitiatedByIPAddress, OperationName, UserPrincipalName, TargetResourceName
| order by UserPrincipalName asc, StartTimeUtc asc
| extend timestamp = StartTimeUtc, AccountCustomEntity = InitiatedByUser, HostCustomEntity = TargetResourceName, IPCustomEntity = InitiatedByIPAddress"
"e6d53324-1306-4279-8158-b454a45745bf","Alerts On Host","true","Hunting","none","AzureSecurityCenter","SecurityAlert","none","none","本规则将返回来自给定虚拟机相关的任何Azure安全中的的警报,默认查询区间是过去3天","let GetAllAlertsOnHost = (suspiciousEventTime:datetime, v_Host:string){
//-3d and +6h as some alerts fire after accumulation of events
let v_StartTime = suspiciousEventTime-3d;
let v_EndTime = suspiciousEventTime+6h;
SecurityAlert
| where TimeGenerated between (v_StartTime .. v_EndTime)
// expand JSON properties
| extend Extprop = parsejson(ExtendedProperties)
| extend Computer = iff(isnotempty(toupper(tostring(Extprop[""Compromised Host""]))), toupper(tostring(Extprop[""Compromised Host""])), tostring(parse_json(Entities)[0].HostName))
| extend Account = iff(isnotempty(tolower(tostring(Extprop[""User Name""]))), tolower(tostring(Extprop[""User Name""])), tolower(tostring(Extprop[""user name""])))
| extend IpAddress = tostring(parse_json(ExtendedProperties).[""Client Address""]) 
| where ExtendedProperties contains v_Host or Entities contains v_Host
| project TimeGenerated, AlertName, Computer, Account, IpAddress, ExtendedProperties
| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress
};
// change datetime value and hostname value below
GetAllAlertsOnHost(now(), toupper(""{host_name}""))"
"d7a8a019-78cc-4ef2-9e8c-0b04fa59017a","User Assigned Privileged Role","true","Detection","High","AzureActiveDirectory","AuditLogs","2h","2h","标识何时将新的特权角色分配给用户。 任何符合角色的帐户现在都被授予特权访问权限。 如果分配是意外的或分配到不是帐户持有人负责的角色，请进行调查。 参考：https://docs.microsoft.comazure/active-directory/fundamentals/security-operations-privileged-accounts#things-to-monitor-1","AuditLogs
| where Category =~ ""RoleManagement""
| where AADOperationType in (""Assign"", ""AssignEligibleRole"")
| where ActivityDisplayName has_any (""Add eligible member to role"", ""Add member to role"")
| mv-expand TargetResources
| mv-expand TargetResources.modifiedProperties
| extend displayName_ = tostring(TargetResources_modifiedProperties.displayName)
| where displayName_ =~ ""Role.DisplayName""
| extend RoleName = tostring(parse_json(tostring(TargetResources_modifiedProperties.newValue)))
| where RoleName contains ""Admin""
| extend InitiatingApp = tostring(parse_json(tostring(InitiatedBy.app)).displayName)
| extend Initiator = iif(isnotempty(InitiatingApp), InitiatingApp, tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName))
| extend Target = tostring(TargetResources.userPrincipalName)
| summarize by bin(TimeGenerated, 1h), OperationName,  RoleName, Target, Initiator, Result
| extend AccountCustomEntity = Target"
"c82bfb9f-1ead-47a7-8434-d5357828bbc2","Rare Custom Script Extension","true","Hunting","none","AzureActivity","AzureActivity","none","none","本规则将查询Azure操作记录来找出在虚拟机上执行自定义脚本扩展，下载并在 Azure 虚拟机上执行脚本的记录。此扩展对于部署后配置、软件安装或任何其他配置或管理任务非常有用。脚本可以从外部链接、Azure 存储、GitHub 下载，或在扩展运行时提供给 Azure 门户。 这也可能被攻击者恶意使用。","let current = 1d;
let Lookback = 14d;
let CustomScriptExecution = AzureActivity 
| where TimeGenerated >= ago(Lookback) 
| where OperationName == ""Microsoft.Compute/virtualMachines/extensions/write""
| extend Settings = tostring(parse_json(tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).settings)))
| parse Settings with * 'fileUris"":[' FileURI ""]"" *
| parse Settings with * 'commandToExecute"":' commandToExecute '}' *
| extend message_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).statusMessage)).error)).message);
let LookbackCustomScriptExecution = CustomScriptExecution
| where TimeGenerated >= ago(Lookback) and TimeGenerated < ago(current)
| where isnotempty(FileURI) and isnotempty(commandToExecute)
| summarize max(TimeGenerated), OperationCount = count() by Caller, Resource, CallerIpAddress, FileURI, commandToExecute;
let CurrentCustomScriptExecution = CustomScriptExecution
| where TimeGenerated >= ago(current)
| where isnotempty(FileURI) and isnotempty(commandToExecute)
| project TimeGenerated, ActivityStatus, OperationId, CorrelationId, ResourceId, CallerIpAddress, Caller, OperationName, Resource, ResourceGroup, FileURI, commandToExecute, FailureMessage = message_, HTTPRequest, Settings;
let RareCustomScriptExecution =  CurrentCustomScriptExecution
| join kind= leftanti (LookbackCustomScriptExecution) on Caller, CallerIpAddress, FileURI, commandToExecute;
let IPCheck = RareCustomScriptExecution 
| summarize arg_max(TimeGenerated, OperationName), OperationIds = makeset(OperationId), CallerIpAddresses = makeset(CallerIpAddress) by ActivityStatus, CorrelationId, ResourceId, Caller, Resource, ResourceGroup, FileURI, commandToExecute, FailureMessage
| extend IPArray = arraylength(CallerIpAddresses);
//Get IPs for later summarization so all associated CorrelationIds and Caller actions have an IP.  Success and Fails do not always have IP
let multiIP = IPCheck | where IPArray > 1
| mvexpand CallerIpAddresses | extend CallerIpAddress = tostring(CallerIpAddresses)
| where isnotempty(CallerIpAddresses);
let singleIP = IPCheck | where IPArray <= 1
| mvexpand CallerIpAddresses | extend CallerIpAddress = tostring(CallerIpAddresses);
let FullDetails = singleIP | union multiIP;
//Get IP address associated with successes and fails with no IP listed
let IPList = FullDetails | where isnotempty(CallerIpAddress) | summarize by CorrelationId, Caller, CallerIpAddress;
let EmptyIP = FullDetails | where isempty(CallerIpAddress) | project-away CallerIpAddress;
let IpJoin = EmptyIP | join kind= leftouter (IPList) on CorrelationId, Caller | project-away CorrelationId1, Caller1;
let nonEmptyIP = FullDetails | where isnotempty(CallerIpAddress);
nonEmptyIP | union IpJoin
// summarize all activities with a given CorrelationId and Caller together so we can provide a singular result
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), ActivityStatusSet = makeset(ActivityStatus), OperationIds = makeset(OperationIds), FailureMessages = makeset(FailureMessage) by CorrelationId, ResourceId, CallerIpAddress, Caller, Resource, ResourceGroup, FileURI, commandToExecute
| extend timestamp = StartTime, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress"
"0a505514-0031-49af-a54e-290f251cba92","New processes observed in last 24 hours","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","本规则将识别出新出现的进程，新进程可能是安装在主机上的良性新程序； 然而，尤其是在通常稳定的环境中，这些新进程可以提供已安装和运行的未经授权/恶意文件。","let starttime = 14d;
let endtime = 1d;
let ProcessCreationEvents=() {
let processEvents=SecurityEvent
| where EventID==4688
| where TimeGenerated >= ago(starttime) 
| project TimeGenerated, ComputerName=Computer,AccountName=SubjectUserName, AccountDomain=SubjectDomainName, FileName=tostring(split(NewProcessName, @'')[(-1)]), ProcessCommandLine = CommandLine, InitiatingProcessFileName=ParentProcessName,InitiatingProcessCommandLine='',InitiatingProcessParentFileName='';
processEvents};
ProcessCreationEvents
| where TimeGenerated >= ago(starttime) and TimeGenerated < ago(endtime)
| summarize HostCount=dcount(ComputerName) by tostring(FileName)
| join kind=rightanti (
    ProcessCreationEvents
    | where TimeGenerated >= ago(endtime)
    | summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Computers = makeset(ComputerName) , HostCount=dcount(ComputerName) by tostring(FileName)
) on FileName
| project StartTimeUtc, Computers, HostCount, FileName
| extend timestamp = StartTimeUtc"
"0e02298f-94aa-4640-aaa3-1777904f4d65","Azure CloudShell Usage","true","Hunting","none","AzureActiveDirectory","AzureActivity","none","none","This query look for users starting an Azure CloudShell session and summarizes the Azure Activity from that
user account during that timeframe (by default 1 hour). This can be used to help identify abuse of the CloudShell
to modify Azure resources.'
","AzureActivity
   | where ActivityStatusValue == ""Succeeded""
   | where ResourceGroup has ""cloud-shell-storage""
   | where OperationNameValue == ""Microsoft.Storage/storageAccounts/listKeys/action""
   // Change the timekey scope below to get activity for a longer window 
   | summarize by Caller, timekey= bin(TimeGenerated, 1h)
   | join (AzureActivity | where TimeGenerated >= ago(1d)
   | where OperationNameValue != ""Microsoft.Storage/storageAccounts/listKeys/action""
   | where isnotempty(OperationName)
    // Change the timekey scope below to get activity for a longer window 
   | summarize make_set(OperationName) by Caller, timekey=bin(TimeGenerated, 1h)) on Caller, timekey
   | extend timestamp = timekey, AccountCustomEntity = Caller"
"8b97eef7-589f-4ea3-909a-ddc8f0fc5b25","Potential IIS code injection attempt","true","Hunting","none","AzureMonitor(IIS)","W3CIISLog","none","none","Potential code injection into web server roles via scan of IIS logs. This represents an attempt to gain initial access to a system using a 
drive-by compromise technique.  This sort of attack happens routinely as part of security scans, of both authorized and malicious types. 
The initial goal of this detection is to flag these events when they occur and give an opportunity to review the data and filter out authorized activity.'
","// set cIP and csMethod count limit to indicate potentially noisy events, this will be listed at the top of the results 
// for any returns that are gt or equal to the default of 50
let cIP_MethodCountLimit = 50;
// Exclude private ip ranges from cIP list
let PrivateIPregex = @'^127\.|^10\.|^172\.1[6-9]\.|^172\.2[0-9]\.|^172\.3[0-1]\.|^192\.168\.';
// Exclude common csMethods, add/modify this list as needed for your environment
let csMethodExclude = dynamic(['GET', 'DEBUG', 'DELETE', 'LOCK', 'MKCOL', 'MOVE', 'PATCH', 'POST', 'PROPPATCH', 
'PUT', 'SEARCH', 'TRACE', 'TRACK', 'UNLOCK', 'OPTIONS', 'HEAD', 'RPC_IN_DATA', 'RPC_OUT_DATA', 'PROPFIND','BITS_POST','CCM_POST']);
// Include in the list expected IPs where remote methods such as vuln scanning may be expected for your environment
let expectedIPs = dynamic(['X.X.X.X', 'Y.Y.Y.Y']);
let codeInjectionAttempts = W3CIISLog
| extend cIPType = iff(cIP matches regex PrivateIPregex,""private"" ,""public"" )
| where cIPType ==""public""
| where cIP !in (expectedIPs)
| project TimeGenerated, cIP, csUserName, csMethod, csCookie, csHost, sIP, scStatus, csUriStem, csUriQuery, csUserAgent, csReferer 
// Throwing entire record into a single string column for attributable string matching
| extend pak = tostring(pack_all())
// Adding ""arr"" column containing indicators of matched suspicious strings
| extend arr = dynamic([])
| extend arr = iff(pak contains '<script' , array_concat(arr, pack_array('STRING MATCH : script')), arr)
| extend arr = iff(pak contains '%3Cscript' , array_concat(arr, pack_array('STRING MATCH : script')), arr)
| extend arr = iff(pak contains '%73%63%72%69%70%74' , array_concat(arr, pack_array('STRING MATCH : encoded script')), arr)
| extend arr = iff(pak contains '<img' , array_concat(arr, pack_array('STRING MATCH : img')), arr)
| extend arr = iff(pak contains '%3Cimg' , array_concat(arr, pack_array('STRING MATCH : img')), arr)
| extend arr = iff(pak contains 'passwd' , array_concat(arr, pack_array('STRING MATCH : passwd')), arr)
| extend arr = iff(csUserAgent contains 'nmap' , array_concat(arr, pack_array('STRING MATCH : nmap')), arr)
| extend arr = iff(csUserAgent contains 'nessus' , array_concat(arr, pack_array('STRING MATCH : nessus')), arr)
| extend arr = iff(csUserAgent contains 'qualys' , array_concat(arr, pack_array('STRING MATCH : qualys')), arr)
| extend arr = iff(csMethod !in (csMethodExclude), array_concat(arr, pack_array('INVALID HTTP METHOD')), arr)
| extend arr = iff(csUriStem == '/current_config/passwd' , array_concat(arr, pack_array('STRING MATCH : dahua scan url' )), arr)
| extend arr = iff(csUriQuery contains '..' and csUriQuery !endswith '...', array_concat(arr, pack_array('BACKTRACK ATTEMPT IN QUERY')), arr)
| extend arr = iff(csUriQuery contains 'http://www.webscantest.com' , array_concat(arr, pack_array('STRING MATCH : webscantest')), arr)
| extend arr = iff(csUriQuery contains 'http://appspidered.rapid7.com' , array_concat(arr, pack_array('STRING MATCH : appspider')), arr)
| where array_length(arr) > 0
| project-away pak;
let cIP_MethodHighCount = codeInjectionAttempts 
| summarize StartTime = max(TimeGenerated), EndTime = min(TimeGenerated), cIP_MethodCount = count() 
by cIP, tostring(arr), cIP_MethodCountType = ""High Count of cIP and csMethod, this may be noise"" 
| where cIP_MethodCount >=  cIP_MethodCountLimit;
let codeInjectAtt = 
codeInjectionAttempts 
| summarize StartTime = max(TimeGenerated), EndTime = min(TimeGenerated), cIP_MethodCount = count() 
by cIP, cIP_MethodCountType = ""Count of repeated entries, this is to reduce rowsets returned"", csMethod, 
tostring(arr), csHost, scStatus, sIP, csUriStem, csUriQuery, csUserName, csUserAgent, csCookie, csReferer;
// union the events and sort by cIP_MethodCount to identify potentially noisy entries.  Additionally, cIP_MethodCountType 
// indicates whether it is a high count or simply a count of repeated entries
(union isfuzzy=true
cIP_MethodHighCount, codeInjectAtt
| sort by cIP_MethodCount desc, cIP desc, StartTime desc)
| extend timestamp = StartTime, IPCustomEntity = cIP, HostCustomEntity = csHost, AccountCustomEntity = csUserName, URLCustomEntity = csUriQuery"
"ff98cb88-8204-4807-a31e-7e3111090cc8","Attempts to sign in to disabled accounts by account name","true","Hunting","none","AzureActiveDirectory","SigninLogs","none","none","本规则返回所有尝试登录已禁用帐户的记录, 以用户账号做集合","let timeframe = 14d;
SigninLogs 
| where TimeGenerated >= ago(timeframe)
| where ResultType == ""50057"" 
| where ResultDescription == ""User account is disabled. The account has been disabled by an administrator."" 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count() by AppDisplayName, UserPrincipalName
| extend timestamp = StartTimeUtc, AccountCustomEntity = UserPrincipalName
| order by count_ desc"
"68a7d313-77ba-4b92-94d2-42996f64e03c","User Granted Access and created resources","true","Hunting","none","AzureActivity","MultipleDataSources","none","none","本规则将标识新用户何时被授予访问权限并开始在 Azure 中创建资源。 这可以帮助您识别流氓或恶意用户行为","let auditLookback = 14d;
let opName = dynamic([""Add user"", ""Invite external user""]);
// Helper function to extract relevant fields from AuditLog events
let auditLogEvents = view (startTimeSpan:timespan, operation:dynamic)  {
    AuditLogs | where TimeGenerated >= ago(auditLookback)
    | where OperationName in~ (operation)
    | extend ModProps = iff(TargetResources.[0].modifiedProperties != ""[]"", TargetResources.[0].modifiedProperties, todynamic(""NoValues""))
    | extend IpAddress = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)), 
    tostring(parse_json(tostring(InitiatedBy.user)).ipAddress), tostring(parse_json(tostring(InitiatedBy.app)).ipAddress))
    | extend InitiatedByFull = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), 
    tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), tostring(parse_json(tostring(InitiatedBy.app)).displayName))
    | extend InitiatedBy = replace(""_"",""@"",tostring(split(InitiatedByFull, ""#"")[0]))
    | extend TargetUserPrincipalName = tostring(TargetResources[0].userPrincipalName)
    | extend TargetUserName = replace(""_"",""@"",tostring(split(TargetUserPrincipalName, ""#"")[0]))
    | extend TargetResourceName = case(
    isempty(tostring(TargetResources.[0].displayName)), TargetUserPrincipalName,
    isnotempty(tostring(TargetResources.[0].displayName)) and tostring(TargetResources.[0].displayName) startswith ""upn:"", tolower(tostring(TargetResources.[0].displayName)),
    tolower(tostring(TargetResources.[0].displayName))
    )
    | extend TargetUserName = replace(""_"",""@"",tostring(split(TargetUserPrincipalName, ""#"")[0]))
    | extend TargetUserName = iff(isempty(TargetUserName), tostring(split(split(TargetResourceName, "","")[0], "" "")[1]), TargetUserName ) 
    | mvexpand ModProps
    | extend PropertyName = tostring(ModProps.displayName), newValue = replace(""\"""","""",tostring(ModProps.newValue));
};
let UserAdd = auditLogEvents(auditLookback, opName) 
| project Action = ""User Added"", TimeGenerated, Type, InitiatedBy_Caller = InitiatedBy, IpAddress, TargetUserName = tolower(TargetUserName), OperationName, PropertyName_ResourceId = PropertyName, Value = newValue;
// Get the simple list of creatd users so we can use later to get just the associated resource creation events
let SimpleUserList = UserAdd | project TimeGenerated, TargetUserName;
let ResourceCreation = AzureActivity
| where TimeGenerated >= ago(auditLookback)
// We look for any Operation that created and then succeeded where ActivityStatus has a value so that we can provide context
| where OperationName == ""Microsoft.Resources/deployments/write""
| where ActivityStatus has ""Succeeded""
| project Action = ""Resource Created"", ResourceCreationTimeGenerated = TimeGenerated, Type, InitiatedBy_Caller = tolower(Caller), IpAddress = CallerIpAddress, OperationName, Value = OperationNameValue, PropertyName_ResourceId = ResourceId;
// Get just the Resources added by the new user
let ResourceMatch = SimpleUserList | join kind= innerunique (
   ResourceCreation
) on $left.TargetUserName == $right.InitiatedBy_Caller
// where the resource creation is after (greater than) the user addition
| where TimeGenerated < ResourceCreationTimeGenerated
| project-away TimeGenerated 
| project-rename TimeGenerated = ResourceCreationTimeGenerated
;
let SimpleResourceMatch = ResourceMatch | project InitiatedBy_Caller;
// Get only resource add, remove, change by the new user
let UserAddWithResource = SimpleResourceMatch | join kind= rightsemi (
   UserAdd 
) on $left.InitiatedBy_Caller == $right.TargetUserName;
// union the user addition events and resource addition events and provide common column names, additionally pack the value, property and resource info to reduce result set.
UserAddWithResource 
| union isfuzzy=true ResourceMatch
| extend PropertySet = pack(""Value"", Value, ""PropertyName_ResourceId"", PropertyName_ResourceId) 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), makeset(PropertySet)  by Action, Type, TargetUserName, InitiatedBy_Caller, IpAddress, OperationName
| order by StartTimeUtc asc 
| extend timestamp = StartTimeUtc, AccountCustomEntity = TargetUserName, IPCustomEntity = IpAddress"
"c053030a-595c-4aa3-bf64-2f30b0de5370","Potential Build Process Compromise","true","Detection","Medium","SecurityEvents","SecurityEvent","1d","1d","该查询会在构建过程开始后立即查找正在修改的源代码文件。 这样做的目的是在构建过程中寻找恶意代码注入。
更多详细信息：https://techcommunity.microsoft.com/t5/azure-sentinel/monitoring-the-software-supply-chain-with-azure-sentinel/ba-p/2176463","// How far back to look for events from
let timeframe = 1d;
// How close together build events and file modifications should occur to alert (make this smaller to reduce FPs)
let time_window = 5m;
// Edit this to include build processes used
let build_processes = dynamic([""MSBuild.exe"", ""dotnet.exe"", ""VBCSCompiler.exe""]);
// Include any processes that you want to allow to edit files during/around the build process
let allow_list = dynamic([""""]);
SecurityEvent
| where TimeGenerated > ago(timeframe)
// Look for build process starts
| where EventID == 4688
| where Process has_any (build_processes)
| summarize by BuildParentProcess=ParentProcessName, BuildProcess=Process, BuildAccount = Account, Computer, BuildCommand=CommandLine, timekey= bin(TimeGenerated, time_window), BuildProcessTime=TimeGenerated
| join kind=inner(
SecurityEvent
| where TimeGenerated > ago(timeframe)
// Look for file modifications to code file
| where EventID == 4663
| where Process !in (allow_list)
// Look for code files, edit this to include file extensions used in build.
| where ObjectName endswith "".cs"" or ObjectName endswith "".cpp""
// 0x6 and 0x4 for file append, 0x100 for file replacements
| where AccessMask == ""0x6""  or AccessMask == ""0x4"" or AccessMask == ""0X100""
| summarize by FileEditParentProcess=ParentProcessName, FileEditAccount = Account, Computer, FileEdited=ObjectName, FileEditProcess=ProcessName, timekey= bin(TimeGenerated, time_window), FileEditTime=TimeGenerated)
// join where build processes and file modifications seen at same time on same host
on timekey, Computer
// Limit to only where the file edit happens after the build process starts
| where BuildProcessTime <= FileEditTime
| summarize make_set(FileEdited), make_set(FileEditProcess), make_set(FileEditAccount) by timekey, Computer, BuildParentProcess, BuildProcess
| extend HostCustomEntity=Computer, timestamp=timekey"
"e0055a65-6a09-40b8-9df5-9af2a81bc25b","VIP account more than 6 failed logons in 10","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","本规则将识别在 10 分钟内尝试登录失败超过 6 次的 VIP 帐户。关于Windows VIP 账号，请参考 - https://docs.microsoft.com/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55","// Create DataTable with your own values, example below shows dummy usernames and domain
let List = datatable(VIPUser:string, Domain:string)[""Bob"", ""Domain"", ""joe"", ""domain"", ""MATT"", ""DOMAIN"", ""administrator"", """"];
let timeframe = 10m;
List
| project TargetUserName = tolower(VIPUser), TargetDomainName = toupper(Domain)
| join kind= rightsemi ( 
SecurityEvent 
| where TimeGenerated > ago(2*timeframe) 
| where EventID == ""4625""
| where AccountType == ""User""
) on TargetUserName, TargetDomainName
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), FailedVIPLogons = count() by EventID, Activity, WorkstationName, Account, TargetAccount, TargetUserName, TargetDomainName, LogonType, LogonTypeName, LogonProcessName, Status, SubStatus
| where FailedVIPLogons >= 6
// map the most common ntstatus codes
| extend StatusDesc = case(
Status =~ ""0x80090302"", ""SEC_E_UNSUPPORTED_FUNCTION"",
Status =~ ""0x80090308"", ""SEC_E_INVALID_TOKEN"",
Status =~ ""0x8009030E"", ""SEC_E_NO_CREDENTIALS"",
Status =~ ""0xC0000008"", ""STATUS_INVALID_HANDLE"",
Status =~ ""0xC0000017"", ""STATUS_NO_MEMORY"",
Status =~ ""0xC0000022"", ""STATUS_ACCESS_DENIED"",
Status =~ ""0xC0000034"", ""STATUS_OBJECT_NAME_NOT_FOUND"",
Status =~ ""0xC000005E"", ""STATUS_NO_LOGON_SERVERS"",
Status =~ ""0xC000006A"", ""STATUS_WRONG_PASSWORD"",
Status =~ ""0xC000006D"", ""STATUS_LOGON_FAILURE"",
Status =~ ""0xC000006E"", ""STATUS_ACCOUNT_RESTRICTION"",
Status =~ ""0xC0000073"", ""STATUS_NONE_MAPPED"",
Status =~ ""0xC00000FE"", ""STATUS_NO_SUCH_PACKAGE"",
Status =~ ""0xC000009A"", ""STATUS_INSUFFICIENT_RESOURCES"",
Status =~ ""0xC00000DC"", ""STATUS_INVALID_SERVER_STATE"",
Status =~ ""0xC0000106"", ""STATUS_NAME_TOO_LONG"",
Status =~ ""0xC000010B"", ""STATUS_INVALID_LOGON_TYPE"",
Status =~ ""0xC000015B"", ""STATUS_LOGON_TYPE_NOT_GRANTED"",
Status =~ ""0xC000018B"", ""STATUS_NO_TRUST_SAM_ACCOUNT"",
Status =~ ""0xC0000224"", ""STATUS_PASSWORD_MUST_CHANGE"",
Status =~ ""0xC0000234"", ""STATUS_ACCOUNT_LOCKED_OUT"",
Status =~ ""0xC00002EE"", ""STATUS_UNFINISHED_CONTEXT_DELETED"",
""See - https://docs.microsoft.com/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55""
)
| extend SubStatusDesc = case(
SubStatus =~ ""0x80090325"", ""SEC_E_UNTRUSTED_ROOT"",
SubStatus =~ ""0xC0000008"", ""STATUS_INVALID_HANDLE"",
SubStatus =~ ""0xC0000022"", ""STATUS_ACCESS_DENIED"",
SubStatus =~ ""0xC0000064"", ""STATUS_NO_SUCH_USER"",
SubStatus =~ ""0xC000006A"", ""STATUS_WRONG_PASSWORD"",
SubStatus =~ ""0xC000006D"", ""STATUS_LOGON_FAILURE"",
SubStatus =~ ""0xC000006E"", ""STATUS_ACCOUNT_RESTRICTION"",
SubStatus =~ ""0xC000006F"", ""STATUS_INVALID_LOGON_HOURS"",
SubStatus =~ ""0xC0000070"", ""STATUS_INVALID_WORKSTATION"",
SubStatus =~ ""0xC0000071"", ""STATUS_PASSWORD_EXPIRED"",
SubStatus =~ ""0xC0000072"", ""STATUS_ACCOUNT_DISABLED"",
SubStatus =~ ""0xC0000073"", ""STATUS_NONE_MAPPED"",
SubStatus =~ ""0xC00000DC"", ""STATUS_INVALID_SERVER_STATE"",
SubStatus =~ ""0xC0000133"", ""STATUS_TIME_DIFFERENCE_AT_DC"",
SubStatus =~ ""0xC000018D"", ""STATUS_TRUSTED_RELATIONSHIP_FAILURE"",
SubStatus =~ ""0xC0000193"", ""STATUS_ACCOUNT_EXPIRED"",
SubStatus =~ ""0xC0000380"", ""STATUS_SMARTCARD_WRONG_PIN"",
SubStatus =~ ""0xC0000381"", ""STATUS_SMARTCARD_CARD_BLOCKED"",
SubStatus =~ ""0xC0000382"", ""STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED"",
SubStatus =~ ""0xC0000383"", ""STATUS_SMARTCARD_NO_CARD"",
SubStatus =~ ""0xC0000384"", ""STATUS_SMARTCARD_NO_KEY_CONTAINER"",
SubStatus =~ ""0xC0000385"", ""STATUS_SMARTCARD_NO_CERTIFICATE"",
SubStatus =~ ""0xC0000386"", ""STATUS_SMARTCARD_NO_KEYSET"",
SubStatus =~ ""0xC0000387"", ""STATUS_SMARTCARD_IO_ERROR"",
SubStatus =~ ""0xC0000388"", ""STATUS_DOWNGRADE_DETECTED"",
SubStatus =~ ""0xC0000389"", ""STATUS_SMARTCARD_CERT_REVOKED"",
""See - https://docs.microsoft.com/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55""
)
| project StartTimeUtc, EndTimeUtc, FailedVIPLogons, EventID, Activity, WorkstationName, Account, TargetAccount, TargetUserName, TargetDomainName, LogonType, LogonTypeName, LogonProcessName, Status, StatusDesc, SubStatus, SubStatusDesc
| extend timestamp = StartTimeUtc, AccountCustomEntity = Account"
"bd7d7b5e-3c11-4ab9-8517-b8bd1ca07e08","Rare process running on a Linux host","true","Hunting","none","Syslog","Syslog","none","none","本规则将查找在 Linux 主机上运行的稀有进程。筛选方式是查找过去 7 天内看到的过程少于 14 次， 或观察到的比率小于环境平均值的 1% 且执行小于 100次","let starttime = 7d;
let endtime = 1m;
let lookback = 30d;
let count_threshold = 100;
let perc_threshold = 0.01;
let host_threshold = 14;
let basic=materialize(
 Syslog
 | where TimeGenerated >= ago(lookback)
    | summarize FullCount = count()
                , Count= countif(TimeGenerated between (ago(starttime) .. ago(endtime)))
                , min_TimeGenerated=min(TimeGenerated)
                , max_TimeGenerated=max(TimeGenerated) 
                      by Computer, ProcessName
    | where Count > 0 and Count < count_threshold);
let basic_avg = basic
    | summarize Avg = avg(FullCount) by  ProcessName;
basic | project-away FullCount
  | join kind=inner 
basic_avg 
  on ProcessName | project-away ProcessName1
  | where Count < host_threshold or (Count <= Avg*perc_threshold and Count < count_threshold) 
  | extend HostCustomEntity=Computer"
"a5c58bc3-7c1d-481f-830a-de0e6929f0e8","Anomalous Resource Creation and related Network Activity","true","Hunting","none","AzureActivity","MultipleDataSources","none","none","本规则将标识何时在 Azure 中成功创建了异常数量的资源。然后将其与 AzureNetworkAnalytics_CL 数据结合以识别所创建资源的任何网络相关活动。可疑资源可能被滥用于货币挖掘、命令和控制、渗漏、分布式攻击和恶意软件传播等。","let starttime = 7d;
let endtime = 1d;
let Activity = AzureActivity
| where TimeGenerated >= startofday(ago(starttime))
// We look for any Operation that created and then succeeded where ActivitySubStatus has a value so that we can provide context
| where OperationName has ""write""
| where ActivityStatus has ""Succeeded""
| make-series dResourceCount=dcount(ResourceId) default=0 on EventSubmissionTimestamp in range(startofday(ago(7d)), now(), 1d) by Caller, Resource, OperationName
| extend (RSquare,Slope,Variance,RVariance,Interception,LineFit)=series_fit_line(dResourceCount)
// Comment slope reference below to see all returns
| where Slope > 0.2
| join kind=leftsemi (
// Last day's activity is anomalous
AzureActivity
| where TimeGenerated >= startofday(ago(endtime))
// We look for any Operation that created and then succeeded where ActivitySubStatus has a value so that we can provide context
| where OperationName has ""write""
| where ActivityStatus has ""Succeeded""
| make-series dResourceCount=dcount(ResourceId) default=0 on EventSubmissionTimestamp in range(startofday(ago(1d)), now(), 1d) by Caller, Resource, OperationName
| extend (RSquare,Slope,Variance,RVariance,Interception,LineFit)=series_fit_line(dResourceCount)
// Comment slope reference below to see all returns
| where Slope > 0.2
) on Caller, Resource, OperationName
// Expanding the fields that were grouped so we can match on a time window when we join the details later
| mvexpand EventSubmissionTimestamp, dResourceCount
// Making sure the fields are the right type or the join fails
| extend todatetime(EventSubmissionTimestamp), tostring(dResourceCount)
| join kind= inner (
  AzureActivity
  | where TimeGenerated >= ago(endtime)
  // We look for any Operation that created and then succeeded where ActivitySubStatus has a value so that we can provide context
  | where OperationName has ""write""
  | where ActivityStatus has ""Succeeded"" and isnotempty(ActivitySubstatus) 
  | summarize by EventSubmissionTimestamp = bin(EventSubmissionTimestamp, 1d), Caller, CallerIpAddress, OperationName, OperationNameValue, ActivityStatusValue, Resource, ResourceGroup, ResourceId, SubscriptionId
) on EventSubmissionTimestamp, Caller, Resource, OperationName;
let NetworkAnalytics = 
  union isfuzzy=true
  (AzureNetworkAnalytics_CL
  | where TimeGenerated >= ago(endtime) 
  // Controlling for Schema Version and later parsing - This is Version 2 and Public IPs only
  | where (isnotempty(FASchemaVersion_s) and isnotempty(DestPublicIPs_s))
  | extend SchemaVersion = FASchemaVersion_s
  | extend PublicIPs = tostring(split(DestPublicIPs_s,""|"")[0])
  | summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), FirstProcessedTimeUTC = min(FlowStartTime_t), LastProcessedTimeUtc = max(FlowEndTime_t), 
  Regions = makeset(Region_s), AzureRegions = makeset(AzureRegion_s), VMs = makeset(VM_s), MACAddresses = makeset(MACAddress_s), PublicIPs = makeset(PublicIPs), DestPort = makeset(DestPort_d), SrcIP = makeset(SrcIP_s), 
  ActivityCount = count() by NSGRule_s, NSGList_s, SubNet = Subnet1_s, FlowDirection_s, Subscription = Subscription1_g, SchemaVersion
  //NSGList_s contains the subscription ID, remove that as we already have a field for this and now it will match what we get for SchemaVersion 1
  | extend NSG = case(isnotempty(NSGList_s), strcat(split(NSGList_s, ""/"")[-2],""/"",split(NSGList_s, ""/"")[-1]), ""NotAvailable"")
  // Depending on the SchemaVersion, we will need to provide the NSG_Name for matching against the resource identified in AzureActivity
  | extend NSG_Name = tostring(split(NSG, ""/"")[-1])
  ),
  (
  AzureNetworkAnalytics_CL
  | where TimeGenerated >= ago(endtime) 
  // Controlling for Schema Version and later parsing - This is Version 1
  | where isempty(FASchemaVersion_s)
  // Controlling for public IPs only
  | where isnotempty(PublicFrontendIPs_s) or isnotempty(PublicIPAddresses_s)
  | where PublicFrontendIPs_s != ""null"" or PublicIPAddresses_s != ""null""
  | extend SchemaVersion = SchemaVersion_s
  // The Public IP can be indicated in one of 2 locations, assigning here for easy union results
  | extend PublicIPs = case(isnotempty(PublicFrontendIPs_s), PublicFrontendIPs_s,
  PublicIPAddresses_s) 
  | summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), FirstProcessedTimeUTC = min(TimeProcessed_t), LastProcessedTimeUtc = max(TimeProcessed_t),  
  Regions = makeset(Region_s), AzureRegions = makeset(DiscoveryRegion_s), VMs = makeset(VirtualMachine_s), MACAddresses = makeset(MACAddress_s), PublicIPs = makeset(PublicIPs), 
  SrcIP = makeset(PrivateIPAddresses_s), Name = makeset(Name_s), DestPort = makeset(DestinationPortRange_s),
  ActivityCount = count() by NSG = NSG_s, SubNet = Subnetwork_s, Subscription = Subscription_g,  SchemaVersion
  // Some events don't have an NSG listed, populating so it is clear it is not available in th datatype
  | extend NSG = case(isnotempty(NSG), NSG, ""NotAvailable"")
  // Depending on the SchemaVersion, we will need to provide the NSG_Name for matching against the resource identified in AzureActivity
  | extend NSG_Name = tostring(split(NSG, ""/"")[-1])
  )
  | project StartTimeUtc, EndTimeUtc, FirstProcessedTimeUTC, LastProcessedTimeUtc, PublicIPs, NSG, NSG_Name, SrcIP, DestPort, SubNet, Name, VMs, MACAddresses, ActivityCount, Regions, AzureRegions, Subscription,  SchemaVersion
  ;
  Activity
     | join kind= leftouter (NetworkAnalytics
  ) on $left.Resource == $right.NSG_Name
  | extend timestamp = StartTimeUtc, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress"
"65ba2be4-9c21-4714-96f0-b4bcd9e155d8","Signins From VPS Providers","true","Hunting","none","AzureActiveDirectory","SigninLogs","none","none","Looks for successful logons from known VPS provider network ranges with suspicious token based logon patterns.
This is not an exhaustive list of VPS provider ranges but covers some of the most prevelent providers observed.'
","let IP_Data = (externaldata(network:string)
[@""https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/VPS_Networks.csv""] with (format=""csv""));
SigninLogs
| where ResultType == 0
| extend additionalDetails = tostring(Status.additionalDetails)
| evaluate ipv4_lookup(IP_Data, IPAddress, network, return_unmatched = false)
| summarize make_set(additionalDetails), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by IPAddress, UserPrincipalName
// Uncomment the remaining lines to only see logons from VPS providers with token only logons.
//| where array_length(set_additionalDetails) == 2
//| where (set_additionalDetails[1] == ""MFA requirement satisfied by claim in the token"" and set_additionalDetails[0] == ""MFA requirement satisfied by claim provided by external provider"") or (set_additionalDetails[0] == ""MFA requirement satisfied by claim in the token"" and set_additionalDetails[1] == ""MFA requirement satisfied by claim provided by external provider"")
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress"
"0ebefb38-8166-444b-9b5a-fde2c851d86f","Sensitive Azure Key Vault operations","true","Detection","Low","AzureKeyVault","AzureDiagnostics","1d","1d","Identifies when sensitive Azure Key Vault operations are used. This includes: VaultDelete, KeyDelete, KeyDecrypt, SecretDelete, SecretPurge, KeyPurge, SecretBackup, KeyBackup. 
Any Backup operations should match with expected scheduled backup activity.","let timeframe = 1d;
let SensitiveOperationList = dynamic(
[""VaultDelete"", ""KeyDelete"", ""SecretDelete"", ""SecretPurge"", ""KeyPurge"", ""SecretBackup"", ""KeyBackup""]);
AzureDiagnostics
| where TimeGenerated > ago(timeframe)
| extend ResultType = columnifexists(""ResultType"", ""NoResultType"")
| extend requestUri_s = columnifexists(""requestUri_s"", ""None""), identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g = columnifexists(""identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g"", ""None"")
| extend id_s = columnifexists(""id_s"", ""None""), CallerIPAddress = columnifexists(""CallerIPAddress"", ""None""), clientInfo_s = columnifexists(""clientInfo_s"", ""None"")
| where ResultType !~ ""None"" and isnotempty(ResultType)
| where identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g !~ ""None"" and isnotempty(identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g)
| where id_s !~ ""None"" and isnotempty(id_s)
| where CallerIPAddress !~ ""None"" and isnotempty(CallerIPAddress)
| where clientInfo_s !~ ""None"" and isnotempty(clientInfo_s)
| where requestUri_s !~ ""None"" and isnotempty(requestUri_s)
| where ResourceType =~ ""VAULTS"" and ResultType =~ ""Success"" 
| where OperationName in~ (SensitiveOperationList)  
| summarize EventCount=count(), StartTimeUtc=min(TimeGenerated), EndTimeUtc=max(TimeGenerated), TimeTriggered=makelist(TimeGenerated),OperationNameList=make_set(OperationName), RequestURLList=make_set(requestUri_s), CallerIPList = make_set(CallerIPAddress),  CallerIPMax= arg_max(CallerIPAddress,*) by ResourceType, ResultType, Resource, id_s, identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g, clientInfo_s
| extend timestamp = StartTimeUtc, IPCustomEntity = CallerIPMax, AccountCustomEntity = identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g"
"f5d90c7e-137f-42e3-a71f-dfe696173681","Suspicious enumeration using Adfind tool","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","Attackers can use Adfind which is administrative tool to gather information about Domain controllers, ADFS Servers. They may also rename executables with other benign tools on the system.
Below query will look for adfind usage in commandline arguments irrespective of executable name in short span of time. You can limit query this to your DC and ADFS servers.
Below references talk about suspicious use of adfind by adversaries.
- https://thedfirreport.com/2020/05/08/adfind-recon/
- https://www.fireeye.com/blog/threat-research/2020/05/tactics-techniques-procedures-associated-with-maze-ransomware-incidents.html
- https://www.microsoft.com/security/blog/2020/12/18/analyzing-solorigate-the-compromised-dll-file-that-started-a-sophisticated-cyberattack-and-how-microsoft-defender-helps-protect/
","let lookupwindow = 2m;
let threshold = 3; //number of commandlines in the set below
let DCADFSServersList = dynamic ([""DCServer01"", ""DCServer02"", ""ADFSServer01""]); // Enter a reference list of hostnames for your DC/ADFS servers
let tokens = dynamic([""objectcategory"",""domainlist"",""dcmodes"",""adinfo"",""trustdmp"",""computers_pwdnotreqd"",""Domain Admins"", ""objectcategory=person"", ""objectcategory=computer"", ""objectcategory=*""]);
SecurityEvent
//| where Computer in (DCADFSServersList) // Uncomment to limit it to your DC/ADFS servers list if specified above or any pattern in hostnames (startswith, matches regex, etc).
| where EventID == 4688
| where CommandLine has_any (tokens)
| where CommandLine matches regex ""(.*)>(.*)""
| summarize Commandlines = make_set(CommandLine), LastObserved=max(TimeGenerated) by bin(TimeGenerated, lookupwindow), Account, Computer, ParentProcessName, NewProcessName
| extend Count = array_length(Commandlines)
| where Count > threshold"
"b9836ab6-3892-4839-b35c-d9c9dd91ed7a","URI requests from single client","true","Hunting","none","AzureMonitor(IIS)","W3CIISLog","none","none","This will look for connections to files on the server that are requested by only a single client. This analytic will be effective where an actor is utilising relatively static operational IP addresses. The threshold can be modified. The larger the execution window for this query the more reliable the results returned.","let timeframe = 7d;
let clientThreshold = 1;
let data = W3CIISLog
//Get script files asmx, aspx
| where csUriStem contains "".as""
//Exclude local addresses, needs editing to matc your network configuration
| where cIP !startswith ""10."" and cIP !startswith ""fe80"" and cIP !startswith ""::"" and cIP !startswith ""127.""
| summarize makelist(cIP), count(TimeGenerated) by csUriStem, sSiteName, csUserAgent;
data
| mvexpand list_cIP
| distinct tostring(list_cIP), csUriStem, sSiteName, csUserAgent
| summarize dcount(list_cIP), makelist(list_cIP), makelist(sSiteName) by csUriStem, csUserAgent
| where dcount_list_cIP == clientThreshold 
//Uncomment to check to see if useragent is likely a browser
| where csUserAgent startswith ""Mozilla"""
"8b53e776-987a-4f0d-a19a-7c0dd80bd8a8","Failed logon attempts by valid accounts within 10 mins","true","Detection","Low","SecurityEvents","SecurityEvent","10m","10m","标识在 10 分钟内（每分钟最少 2 次失败登录）从有效帐户登录失败的尝试次数是 20 次或更多。","let threshold = 20;
SecurityEvent 
| where EventID == 4625
| where AccountType =~ ""User""
| where SubStatus !='0xc0000064' and Account !in ('\\', '-\\-')
// SubStatus '0xc0000064' signifies 'Account name does not exist'
| extend ResourceId = column_ifexists(""_ResourceId"", _ResourceId), SourceComputerId = column_ifexists(""SourceComputerId"", SourceComputerId)
| extend Reason = case(
SubStatus =~ '0xC000005E', 'There are currently no logon servers available to service the logon request.',
SubStatus =~ '0xC0000064', 'User logon with misspelled or bad user account',
SubStatus =~ '0xC000006A', 'User logon with misspelled or bad password', 
SubStatus =~ '0xC000006D', 'Bad user name or password',
SubStatus =~ '0xC000006E', 'Unknown user name or bad password',
SubStatus =~ '0xC000006F', 'User logon outside authorized hours',
SubStatus =~ '0xC0000070', 'User logon from unauthorized workstation',
SubStatus =~ '0xC0000071', 'User logon with expired password',
SubStatus =~ '0xC0000072', 'User logon to account disabled by administrator',
SubStatus =~ '0xC00000DC', 'Indicates the Sam Server was in the wrong state to perform the desired operation', 
SubStatus =~ '0xC0000133', 'Clocks between DC and other computer too far out of sync',
SubStatus =~ '0xC000015B', 'The user has not been granted the requested logon type (aka logon right) at this machine',
SubStatus =~ '0xC000018C', 'The logon request failed because the trust relationship between the primary domain and the trusted domain failed',
SubStatus =~ '0xC0000192', 'An attempt was made to logon, but the Netlogon service was not started',
SubStatus =~ '0xC0000193', 'User logon with expired account',
SubStatus =~ '0xC0000224', 'User is required to change password at next logon',
SubStatus =~ '0xC0000225', 'Evidently a bug in Windows and not a risk',
SubStatus =~ '0xC0000234', 'User logon with account locked',
SubStatus =~ '0xC00002EE', 'Failure Reason: An Error occurred during Logon',
SubStatus =~ '0xC0000413', 'Logon Failure: The machine you are logging onto is protected by an authentication firewall. The specified account is not allowed to authenticate to the machine',
strcat('Unknown reason substatus: ', SubStatus))
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), FailedLogonCount = count() by EventID, 
Activity, Computer, Account, TargetAccount, TargetUserName, TargetDomainName, 
LogonType, LogonTypeName, LogonProcessName, Status, SubStatus, Reason, ResourceId, SourceComputerId, WorkstationName, IpAddress
| where FailedLogonCount >= threshold
| extend timestamp = StartTime, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress"
"c074e557-ace0-43c9-8122-19848d290168","Account Created and Deleted in Short Timeframe","true","Detection","High","AzureActiveDirectory","AuditLogs","1d","1d","搜索用户主体名称 (UPN) 事件。 查找在 24 小时内创建然后删除的帐户。 攻击者可能会创建一个帐户供他们使用，然后在不再需要时删除该帐户。 参考：https://docs.microsoft.comazure/active-directory/fundamentals/security-operations-user-accounts#short-lived-account","AuditLogs
| where OperationName =~ ""Add user""
| extend UPN = tostring(TargetResources[0].userPrincipalName)
| join kind=inner (AuditLogs
| where OperationName =~ ""Delete user""
| extend UPN = tostring(TargetResources[0].userPrincipalName)
| extend IPAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)) on UPN
| extend timedelta = TimeGenerated1 - TimeGenerated
| project-reorder TimeGenerated, TimeGenerated1, timedelta
| where timedelta < timespan(24h) and timedelta > timespan(0h)
| extend CustomAccountEntity = UPN, IPCustomEntity = IPAddress"
"347faa74-effc-49f4-b015-58e0abf1c21d","Mass secret retrieval from Azure Key Vault","true","Detection","Low","AzureKeyVault","AzureDiagnostics","1d","1d","Identifies mass secret retrieval from Azure Key Vault observed by a single user. 
Mass secret retrival crossing a certain threshold is an indication of credential dump operations or mis-configured applications. 
You can tweak the EventCountThreshold based on average count seen in your environment 
and also filter any known sources (IP/Account) and useragent combinations based on historical analysis to further reduce noise","let timeframe =1d;
let EventCountThreshold = 25;
let OperationList = dynamic(
[""SecretGet"", ""KeyGet"", ""VaultGet""]);
AzureDiagnostics
| where TimeGenerated > ago(timeframe)
| extend ResultType = columnifexists(""ResultType"", ""None""), identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g = columnifexists(""identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g"", ""None"")
| where ResultType !~ ""None"" and isnotempty(ResultType)
| where identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g !~ ""None"" and isnotempty(identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g)
| where ResourceType =~ ""VAULTS"" and ResultType =~ ""Success""
| where OperationName in (OperationList) 
| summarize count() by identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g, OperationName
| where count_ > EventCountThreshold  
| join (
AzureDiagnostics
| where TimeGenerated > ago(timeframe)
| extend ResultType = columnifexists(""ResultType"", ""NoResultType"")
| extend requestUri_s = columnifexists(""requestUri_s"", ""None""), identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g = columnifexists(""identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g"", ""None"")
| extend id_s = columnifexists(""id_s"", ""None""), CallerIPAddress = columnifexists(""CallerIPAddress"", ""None""), clientInfo_s = columnifexists(""clientInfo_s"", ""None"")
| where ResultType !~ ""None"" and isnotempty(ResultType)
| where identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g !~ ""None"" and isnotempty(identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g)
| where id_s !~ ""None"" and isnotempty(id_s)
| where CallerIPAddress !~ ""None"" and isnotempty(CallerIPAddress)
| where clientInfo_s !~ ""None"" and isnotempty(clientInfo_s)
| where requestUri_s !~ ""None"" and isnotempty(requestUri_s)
| where OperationName in~ (OperationList)   
) on identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g 
| summarize EventCount=sum(count_), StartTimeUtc=min(TimeGenerated), EndTimeUtc=max(TimeGenerated), TimeTriggered=makelist(TimeGenerated),OperationNameList=make_set(OperationName), RequestURLList=make_set(requestUri_s), CallerIPList = make_set(CallerIPAddress),  CallerIPMax= arg_max(CallerIPAddress,*) by ResourceType, ResultType, Resource, id_s, identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g, clientInfo_s
| extend timestamp = EndTimeUtc, IPCustomEntity = CallerIPMax, AccountCustomEntity = identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g"
"3cf6ff1e-61d3-4516-882b-457137ab67b8","IP with multiple failed Azure AD logins successfully logs in to Palo Alto VPN","true","Detection","Medium","AzureActiveDirectory","MultipleDataSources","1d","1d","This query creates a list of IP addresses with a number failed login attempts to AAD 
above a set threshold.  It then looks for any successful Palo Alto VPN logins from any
of these IPs within the same timeframe.","let timeframe = 1d;
//Set a threshold of failed AAD signins from an IP address within 1 day above which we want to deem those logins suspicious.
let signin_threshold = 5; 
//Make a list of IPs with AAD signin failures above our threshold.
let suspicious_signins = 
    SigninLogs
    | where TimeGenerated >= ago(timeframe)
    //Looking for logon failure results
    | where ResultType !in (""0"", ""50125"", ""50140"")
    //Exclude localhost addresses to reduce the chance of FPs
    | where IPAddress != ""127.0.0.1""
    | summarize count() by IPAddress
    | where count_ >  signin_threshold
    | summarize make_list(IPAddress);
//See if any of those IPs have sucessfully logged into PA VPNs during the same timeperiod
CommonSecurityLog
    | where TimeGenerated > ago(timeframe)
    //Select only PA VPN sucessful logons
    | where DeviceVendor == ""Palo Alto Networks"" and DeviceEventClassID == ""globalprotect""
    | where Message has ""GlobalProtect gateway user authentication succeeded""
    //Parse out the logon source IP from the Message field to match on
    | extend SourceIP = extract(""Login from: ([^,]+)"", 1, Message) 
    | where SourceIP in (suspicious_signins)
    | extend Reason = ""Multiple failed AAD logins from SourceIP""
    //Parse out other useful information from Message field
    | extend User = extract(""User name: ([^,]+)"", 1, Message) 
    | extend ClientOS = extract(""Client OS version: ([^,\""]+)"", 1, Message)
    | extend Location = extract(""Source region: ([^,]{2})"",1, Message)
    | project TimeGenerated, Reason, SourceIP, User, ClientOS, Location, Message, DeviceName, ReceiptTime, DeviceVendor, DeviceEventClassID, Computer, FileName
    | extend AccountCustomEntity = User, IPCustomEntity = SourceIP, timestamp = TimeGenerated, HostCustomEntity = DeviceName"
"f8d54cab-caa9-4d08-bf9d-051253dba362","User account added to built in domain local or global group","true","Detection","Low","SecurityEvents","SecurityEvent","1d","1d","本规则将标识用户帐户添加到特权内置域本地组或全局组的安全日志。例如添加账号到 Enterprise Adminis、Cert Publishers 或 DnsAdmins。请务必确认这是预期的添加。","let timeframe = 1d;
// For AD SID mappings - https://docs.microsoft.com/windows/security/identity-protection/access-control/active-directory-security-groups
let WellKnownLocalSID = ""S-1-5-32-5[0-9][0-9]$"";
let WellKnownGroupSID = ""S-1-5-21-[0-9]*-[0-9]*-[0-9]*-5[0-9][0-9]$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1102$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1103$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-498$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1000$"";
SecurityEvent 
| where TimeGenerated > ago(timeframe)
// When MemberName contains '-' this indicates addition of a group to a group
| where AccountType == ""User"" and MemberName != ""-""
// 4728 - A member was added to a security-enabled global group
// 4732 - A member was added to a security-enabled local group
// 4756 - A member was added to a security-enabled universal group
| where EventID in (4728, 4732, 4756)   
| where TargetSid matches regex WellKnownLocalSID or TargetSid matches regex WellKnownGroupSID
// Exclude Remote Desktop Users group: S-1-5-32-555
| where TargetSid !in (""S-1-5-32-555"")
| extend SimpleMemberName = tostring(split(tostring(split(MemberName, "","")[0]),""CN="")[1])
| project StartTimeUtc = TimeGenerated, EventID, Activity, Computer, SimpleMemberName, MemberName, MemberSid, TargetUserName, TargetDomainName, TargetSid, UserPrincipalName, SubjectUserName, SubjectUserSid
| extend timestamp = StartTimeUtc, AccountCustomEntity = SimpleMemberName, HostCustomEntity = Computer"
"f6e10021-805b-4a05-a9f3-da9b4a1c91d3","Process execution frequency anomaly","true","Detection","Medium","SecurityEvents","SecurityEvent","1h","14d","Identifies anomalous spike in frequency of executions of sensitive processes which are often leveraged as attack vectors. 
The query leverages KQL built-in anomaly detection algorithms to find large deviations from baseline patterns. 
Sudden increases in execution frequency of sensitive processes should be further investigated for malicious activity.
Tune the values from 1.5 to 3 in series_decompose_anomalies for further outliers or based on custom threshold values for score.","let starttime = 14d;
let endtime = 1d;
let timeframe = 1h;
let TotalEventsThreshold = 5;
let ExeList = dynamic([""powershell.exe"",""cmd.exe"",""wmic.exe"",""psexec.exe"",""cacls.exe"",""rundll.exe""]);
let TimeSeriesData = 
SecurityEvent
| where EventID == 4688 | extend Process = tolower(Process)
| where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))
| where Process in (ExeList)
| project TimeGenerated, Computer, AccountType, Account, Process
| make-series Total=count() on TimeGenerated from ago(starttime) to ago(endtime) step timeframe by Process;
let TimeSeriesAlerts = TimeSeriesData
| extend (anomalies, score, baseline) = series_decompose_anomalies(Total, 1.5, -1, 'linefit')
| mv-expand Total to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double), score to typeof(double), baseline to typeof(long)
| where anomalies > 0
| project Process, TimeGenerated, Total, baseline, anomalies, score
| where Total > TotalEventsThreshold;
TimeSeriesAlerts
| join (
SecurityEvent
| where EventID == 4688 | extend Process = tolower(Process)
| summarize CommandlineCount = count() by bin(TimeGenerated, 1h), Process, CommandLine, Computer, Account
) on Process, TimeGenerated 
| project AnomalyHour = TimeGenerated, Computer, Account, Process, CommandLine, CommandlineCount, Total, baseline, anomalies, score 
| extend timestamp = AnomalyHour, AccountCustomEntity = Account, HostCustomEntity = Computer"
"44c12a22-f186-4a51-bb99-d0b4187f5eed","Summary of users created using uncommon/undocumented commandline switches","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","本规则将识别创建持久性用户帐户的命令。此类命令可能是正常的服务账号创建，但也可能是用于执行持久性攻击， 具体可以参考：https://attack.mitre.org/wiki/Technique/T1136","let timeframe = 1d;
SecurityEvent
| where TimeGenerated >= ago(timeframe) 
| where EventID==4688
| project TimeGenerated, ComputerName=Computer,AccountName=SubjectUserName, 
    AccountDomain=SubjectDomainName, FileName=tostring(split(NewProcessName, '\\')[-1]), 
    ProcessCommandLine = CommandLine, 
    FolderPath = """", InitiatingProcessFileName=ParentProcessName,
    InitiatingProcessCommandLine="""",InitiatingProcessParentFileName=""""
| where FileName in~ (""net.exe"", ""net1.exe"")
| parse kind=regex flags=iU ProcessCommandLine with * ""user "" CreatedUser "" "" * ""/ad""
| where not(FileName =~ ""net1.exe"" and InitiatingProcessFileName =~ ""net.exe"" and replace(""net"", ""net1"", InitiatingProcessCommandLine) =~ ProcessCommandLine)
| extend CreatedOnLocalMachine=(ProcessCommandLine !contains ""/do"")
| where ProcessCommandLine contains ""/add"" or (CreatedOnLocalMachine == 0 and ProcessCommandLine !contains ""/domain"")
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), MachineCount=dcount(ComputerName) by CreatedUser, CreatedOnLocalMachine, InitiatingProcessFileName, FileName, ProcessCommandLine, InitiatingProcessCommandLine
| extend timestamp = StartTimeUtc, AccountCustomEntity = CreatedUser"
"acb462bf-a2f3-474b-9b2c-fefd6bda7089","Excessive Windows logon failures","true","Detection","Low","SecurityEvents","SecurityEvent","1d","8d","User has over 50 Windows logon failures today and at least 33% of the count of logon failures over the previous 7 days.","let starttime = 8d;
let endtime = 1d;
let threshold = 0.333;
let countlimit = 50;
SecurityEvent
| where TimeGenerated >= ago(endtime)
| where EventID == 4625 and AccountType =~ ""User""
| where IpAddress !in (""127.0.0.1"", ""::1"")
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), CountToday = count() by EventID, Account, LogonTypeName, SubStatus, AccountType, Computer, WorkstationName, IpAddress
| join kind=leftouter (
    SecurityEvent 
    | where TimeGenerated between (ago(starttime) .. ago(endtime))
    | where EventID == 4625 and AccountType =~ ""User""
    | where IpAddress !in (""127.0.0.1"", ""::1"")
    | summarize CountPrev7day = count() by EventID, Account, LogonTypeName, SubStatus, AccountType, Computer, WorkstationName, IpAddress
) on EventID, Account, LogonTypeName, SubStatus, AccountType, Computer, WorkstationName, IpAddress
| where CountToday >= coalesce(CountPrev7day,0)*threshold and CountToday >= countlimit
| extend Reason = case(
SubStatus == '0xc000005e', 'No logon servers available to service the logon request',
SubStatus == '0xc0000062', 'Account name is not properly formatted',
SubStatus == '0xc0000064', 'Account name does not exist',
SubStatus == '0xc000006a', 'Incorrect password',    
SubStatus == '0xc000006d', 'Bad user name or password',
SubStatus == '0xc000006f', 'User logon blocked by account restriction',
SubStatus == '0xc000006f', 'User logon outside of restricted logon hours',
SubStatus == '0xc0000070', 'User logon blocked by workstation restriction',
SubStatus == '0xc0000071', 'Password has expired',
SubStatus == '0xc0000072', 'Account is disabled',
SubStatus == '0xc0000133', 'Clocks between DC and other computer too far out of sync',
SubStatus == '0xc000015b', 'The user has not been granted the requested logon right at this machine',
SubStatus == '0xc0000193', 'Account has expirated',
SubStatus == '0xc0000224', 'User is required to change password at next logon',
SubStatus == '0xc0000234', 'Account is currently locked out',
strcat('Unknown reason substatus: ', SubStatus))
| extend WorkstationName = iff(WorkstationName == ""-"" or isempty(WorkstationName), Computer , WorkstationName) 
| project StartTimeUtc, EndTimeUtc, EventID, Account, LogonTypeName, SubStatus, Reason, AccountType, Computer, WorkstationName, IpAddress, CountToday, CountPrev7day, Avg7Day = CountPrev7day/7
| summarize StartTimeUtc = min(StartTimeUtc), EndTimeUtc = max(EndTimeUtc), Computer = make_set(Computer,128), IpAddressList = make_set(IpAddress,128), sum(CountToday), sum(CountPrev7day), avg(Avg7Day) 
by EventID, Account, LogonTypeName, SubStatus, Reason, AccountType, WorkstationName
| order by sum_CountToday desc nulls last 
| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = WorkstationName"
"e28c0db5-166c-4769-8c1f-943407eb9c3c","Exchange Server ProxyLogon URIs","true","Hunting","none","AzureMonitor(IIS)","W3CIISLog","none","none","This query will detect paths suspicious associated with ProxyLogon exploitation'
","W3CIISLog
| where not(ipv4_is_private(cIP))
| where (csUriStem matches regex @""\/owa\/auth\/[A-Za-z0-9]{1,30}\.js"") or (csUriStem matches regex @""\/ecp\/[A-Za-z0-9]{1,30}\.(js|flt|css)"")
| project TimeGenerated, sSiteName, csMethod, csUriStem, sPort, sIP, cIP, csUserAgent
| extend timestamp = TimeGenerated"
"92492474-8184-4bff-b514-3e6d53e1f37d","Signin Logs with expanded Conditional Access Policies","true","Hunting","none","AzureActiveDirectory","SigninLogs","none","none","本规则查询AAD登录日志，并显示拆分登录记录的压缩字段","let timeframe = 1d;
SigninLogs 
| where TimeGenerated >= ago(timeframe)
| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser
| extend ConditionalAccessPol0Name = tostring(ConditionalAccessPolicies[0].displayName), ConditionalAccessPol0Result = tostring(ConditionalAccessPolicies[0].result)
| extend ConditionalAccessPol1Name = tostring(ConditionalAccessPolicies[1].displayName), ConditionalAccessPol1Result = tostring(ConditionalAccessPolicies[1].result)
| extend ConditionalAccessPol2Name = tostring(ConditionalAccessPolicies[2].displayName), ConditionalAccessPol2Result = tostring(ConditionalAccessPolicies[2].result)
| extend StatusCode = tostring(Status.errorCode), StatusDetails = tostring(Status.additionalDetails)
| extend State = tostring(LocationDetails.state), City = tostring(LocationDetails.city)
| extend Date = startofday(TimeGenerated), Hour = datetime_part(""Hour"", TimeGenerated)
| summarize count() by Date, Identity, UserDisplayName, UserPrincipalName, IPAddress, ResultType, ResultDescription, StatusCode, StatusDetails, 
ConditionalAccessPol0Name, ConditionalAccessPol0Result, ConditionalAccessPol1Name, ConditionalAccessPol1Result, ConditionalAccessPol2Name, ConditionalAccessPol2Result, 
Location, State, City
| extend timestamp = Date, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress
| sort by Date"
"fc495630-0a92-4784-9840-eb10ec8c79b7","Enumeration of users and groups","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","本规则将识别尝试使用内置 Windows 'net' 工具列出用户或组的记录","let timeframe = 1d;
let ProcessCreationEvents=() {
let processEvents=SecurityEvent
| where EventID==4688
| project TimeGenerated, ComputerName=Computer,AccountName=SubjectUserName,        AccountDomain=SubjectDomainName,
FileName=tostring(split(NewProcessName, '\\')[-1]),
ProcessCommandLine = CommandLine, 
FolderPath = """",
InitiatingProcessFileName=ParentProcessName,InitiatingProcessCommandLine="""",InitiatingProcessParentFileName="""";
processEvents};
ProcessCreationEvents
| where TimeGenerated >= ago(timeframe)
| where FileName == 'net.exe' and AccountName != """" and ProcessCommandLine !contains '\\'  and ProcessCommandLine !contains '/add' 
| where (ProcessCommandLine contains ' user ' or ProcessCommandLine contains ' group ') and (ProcessCommandLine endswith ' /do' or ProcessCommandLine endswith ' /domain') 
| extend Target = extract(""(?i)[user|group] (\""*[a-zA-Z0-9-_ ]+\""*)"", 1, ProcessCommandLine) | filter Target  != '' 
| summarize minTimeGenerated=min(TimeGenerated), maxTimeGenerated=max(TimeGenerated), count() by AccountName, Target, ProcessCommandLine, ComputerName
| project minTimeGenerated, maxTimeGenerated, count_, AccountName, Target, ProcessCommandLine, ComputerName
| sort by AccountName, Target
| extend timestamp = minTimeGenerated, AccountCustomEntity = AccountName, HostCustomEntity = ComputerName"
"e098eb0d-7641-4429-beb1-66ea3043dcfc","Summary of user logons by logon type","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","本规则将统计成功和不成功的登录尝试","let timeframe = 1d;
SecurityEvent
| where TimeGenerated >= ago(timeframe)
| where EventID in (4624, 4625)
| where AccountType == 'User' 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Amount = count() by LogonTypeName
| extend timestamp = StartTimeUtc"
"7dfada8b-b31f-4253-97de-43e3bf8ce304","Credential added after admin consented to Application","true","Detection","Medium","AzureActiveDirectory","AuditLogs","1d","2d","此查询将识别一个用户在应用程序被另一用户授予管理员同意权限后将服务主体凭据添加到应用程序的实例。
 如果威胁行为者获得对具有足够权限的帐户的访问权限并添加备用身份验证材料触发 在此事件中，威胁行为者现在可以使用此凭据作为应用程序或服务主体进行身份验证。
 有关 OAuth 凭据授予的其他信息可在 RFC 6749 第 4.4 节或 https://docs.microsoft.com/azure/active- directory/develop/v2-oauth2-client-creds-grant-flow。
 有关 AuditLogs 的更多信息，请参阅 https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities","let auditLookbackStart = 2d;
let auditLookbackEnd = 1d;
AuditLogs
| where TimeGenerated >= ago(auditLookbackStart)
| where OperationName =~ ""Consent to application"" 
| where Result =~ ""success""
| mv-expand target = TargetResources
| extend targetResourceName = tostring(target.displayName)
| extend targetResourceID = tostring(target.id)
| extend targetResourceType = tostring(target.type)
| extend targetModifiedProp = TargetResources[0].modifiedProperties
| extend isAdminConsent = targetModifiedProp[0].newValue
| extend Consent_ServicePrincipalNames = targetModifiedProp[5].newValue
| extend Consent_Permissions = targetModifiedProp[4].newValue
| extend Consent_InitiatingUserOrApp = iff(isnotempty(InitiatedBy.user.userPrincipalName),tostring(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.app.displayName))
| extend Consent_InitiatingIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), tostring(InitiatedBy.user.ipAddress), tostring(InitiatedBy.app.ipAddress))
| join ( 
AuditLogs
| where TimeGenerated  >= ago(auditLookbackEnd)
| where OperationName =~ ""Add service principal credentials""
| where Result =~ ""success""
| mv-expand target = TargetResources
| extend targetResourceName = tostring(target.displayName)
| extend targetResourceID = tostring(target.id)
| extend targetModifiedProp = TargetResources[0].modifiedProperties
| extend Credential_KeyDescription = targetModifiedProp[0].newValue
| extend UpdatedProperties = targetModifiedProp[1].newValue
| extend Credential_ServicePrincipalNames = targetModifiedProp[2].newValue
| extend Credential_InitiatingUserOrApp = iff(isnotempty(InitiatedBy.user.userPrincipalName),tostring(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.app.displayName))
| extend Credential_InitiatingIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), tostring(InitiatedBy.user.ipAddress), tostring(InitiatedBy.app.ipAddress))
) on targetResourceName, targetResourceID
| extend TimeConsent = TimeGenerated, TimeCred = TimeGenerated1
| where TimeConsent > TimeCred 
| project TimeConsent, TimeCred, Consent_InitiatingUserOrApp, Credential_InitiatingUserOrApp, targetResourceName, targetResourceType, isAdminConsent, Consent_ServicePrincipalNames, Credential_ServicePrincipalNames, Consent_Permissions, Credential_KeyDescription, Consent_InitiatingIpAddress, Credential_InitiatingIpAddress
| extend timestamp = TimeConsent, AccountCustomEntity = Consent_InitiatingUserOrApp, IPCustomEntity = Consent_InitiatingIpAddress"
"224ebf12-63f5-4a91-ad1a-a5580c98c0e8","Azure Key Vault access TimeSeries anomaly","true","Detection","Low","AzureKeyVault","AzureDiagnostics","1d","14d","Indentifies a sudden increase in count of Azure Key Vault secret or vault access operations by CallerIPAddress. The query leverages a built-in KQL anomaly detection algorithm 
to find large deviations from baseline Azure Key Vault access patterns. Any sudden increase in the count of Azure Key Vault accesses can be an 
indication of adversary dumping credentials via automated methods. If you are seeing any noise, try filtering known source(IP/Account) and user-agent combinations.
TimeSeries Reference Blog: https://techcommunity.microsoft.com/t5/azure-sentinel/looking-for-unknown-anomalies-what-is-normal-time-series/ba-p/555052","let starttime = 14d;
let timeframe = 1d;
let scorethreshold = 3;
let baselinethreshold = 5;
let OperationList = dynamic(
[""SecretGet"", ""KeyGet"", ""VaultGet""]);
let TimeSeriesData = AzureDiagnostics
| where TimeGenerated between (startofday(ago(starttime))..startofday(now()))
| extend ResultType = columnifexists(""ResultType"", ""None""), CallerIPAddress = columnifexists(""CallerIPAddress"", ""None"")
| where ResultType !~ ""None"" and isnotempty(ResultType)
| where CallerIPAddress !~ ""None"" and isnotempty(CallerIPAddress)
| where ResourceType =~ ""VAULTS"" and ResultType =~ ""Success""
| where OperationName in (OperationList) 
| project TimeGenerated, OperationName, Resource, CallerIPAddress 
| make-series HourlyCount=count() on TimeGenerated from startofday(ago(starttime)) to startofday(now()) step timeframe by Resource;
//Filter anomolies against TimeSeriesData
let TimeSeriesAlerts = TimeSeriesData
| extend (anomalies, score, baseline) = series_decompose_anomalies(HourlyCount, scorethreshold, -1, 'linefit')
| mv-expand HourlyCount to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double),score to typeof(double), baseline to typeof(long)
| where anomalies > 0 | extend AnomalyHour = TimeGenerated
| where baseline > baselinethreshold // Filtering low count events per baselinethreshold
| project Resource, AnomalyHour, TimeGenerated, HourlyCount, baseline, anomalies, score;
// Filter the alerts since specified timeframe
TimeSeriesAlerts
| where TimeGenerated > ago(timeframe)
// Join against base logs since specified timeframe to retrive records associated with the hour of anomoly
| join (
AzureDiagnostics
| where TimeGenerated > ago(timeframe)
| extend ResultType = columnifexists(""ResultType"", ""NoResultType"")
| extend requestUri_s = columnifexists(""requestUri_s"", ""None""), identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g = columnifexists(""identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g"", ""None"")
| extend id_s = columnifexists(""id_s"", ""None""), CallerIPAddress = columnifexists(""CallerIPAddress"", ""None""), clientInfo_s = columnifexists(""clientInfo_s"", ""None"")
| where ResultType !~ ""None"" and isnotempty(ResultType)
| where identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g !~ ""None"" and isnotempty(identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g)
| where id_s !~ ""None"" and isnotempty(id_s)
| where CallerIPAddress !~ ""None"" and isnotempty(CallerIPAddress)
| where clientInfo_s !~ ""None"" and isnotempty(clientInfo_s)
| where requestUri_s !~ ""None"" and isnotempty(requestUri_s)
| where ResourceType =~ ""VAULTS"" and ResultType =~ ""Success""
| where OperationName in (OperationList)  
| summarize PerOperationCount=count(), LatestAnomalyTime = arg_max(TimeGenerated,*) by bin(TimeGenerated,1h), Resource, OperationName, id_s, CallerIPAddress, identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g, requestUri_s, clientInfo_s     
) on Resource, TimeGenerated 
| summarize EventCount=count(), OperationNameList = make_set(OperationName), RequestURLList = make_set(requestUri_s), AccountList = make_set(identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g), AccountMax = arg_max(identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g,*) by Resource, id_s, clientInfo_s, LatestAnomalyTime
| extend timestamp = LatestAnomalyTime, IPCustomEntity = CallerIPAddress, AccountCustomEntity = AccountMax"
"ec45a63c-6ff5-425f-a6b4-cb27eec6ce72","Attempts to sign in to disabled accounts by IP address","true","Hunting","none","AzureActiveDirectory","SigninLogs","none","none","本规则返回所有尝试登录已禁用帐户的记录, 以登录IP地址做集合","let timeframe = 14d;
SigninLogs 
| where TimeGenerated >= ago(timeframe)
| where ResultType == ""50057"" 
| where ResultDescription == ""User account is disabled. The account has been disabled by an administrator."" 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), numberAccountsTargeted = dcount(UserPrincipalName), 
numberApplicationsTargeted = dcount(AppDisplayName), accountSet = makeset(UserPrincipalName), applicationSet=makeset(AppDisplayName), 
numberLoginAttempts = count() by IPAddress
| extend timestamp = StartTimeUtc, IPCustomEntity = IPAddress
| order by numberLoginAttempts desc"
"1281faf2-5e2c-454e-952d-cff2b4a8f525","AD Account Lockout","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","本规则将识别Active Directory 帐户锁定","let timeframe = 7d;
SecurityEvent
| where TimeGenerated >= ago(timeframe)
| where EventID == 4740
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), LockoutsCount = count() by Activity, Account, TargetSid, TargetDomainName, SourceComputerId, SourceDomainController = Computer
| extend timestamp = StartTime, AccountCustomEntity = Account, HostCustomEntity = TargetDomainName"
"4e0cf057-231f-4312-8599-15750ab0a1d5","Azure VM Run Command executed from Azure IP address","true","Hunting","none","AzureActivity","AzureActivity","none","none","Identifies any Azure VM Run Command operation executed from an Azure IP address.
Run Command allows an attacker or legitimate user to execute aribitrary PowerShell
on a target VM. This technique has been seen in use by NOBELIUM.'
","let azure_ranges = externaldata(changeNumber: string, cloud: string, values: dynamic)
[""https://download.microsoft.com/download/7/1/D/71D86715-5596-4529-9B13-DA13A5DE5B63/ServiceTags_Public_20211018.json""]
with(format='multijson')
| mv-expand values
// Limit to virtual desktop IP ranges, uncomment to see all Azure ranges
| where values contains ""VirtualDesktop""
| mv-expand values.properties.addressPrefixes
| mv-expand values_properties_addressPrefixes
| summarize by tostring(values_properties_addressPrefixes);
AzureActivity
| where TimeGenerated > ago(30d)
// Isolate run command actions
| where OperationNameValue == ""Microsoft.Compute/virtualMachines/runCommand/action""
// Confirm that the operation impacted a virtual machine
| where Authorization has ""virtualMachines""
// Each runcommand operation consists of three events when successful, Started, Accepted (or Rejected), Successful (or Failed).
| summarize StartTime=min(TimeGenerated), EndTime=max(TimeGenerated), max(CallerIpAddress), make_list(ActivityStatusValue) by CorrelationId, Authorization, Caller
// Limit to Run Command executions that Succeeded
| where list_ActivityStatusValue has ""Succeeded""
// Extract data from the Authorization field, allowing us to later extract the Caller (UPN) and CallerIpAddress
| extend Authorization_d = parse_json(Authorization)
| extend Scope = Authorization_d.scope
| extend Scope_s = split(Scope, ""/"")
| extend Subscription = tostring(Scope_s[2])
| extend VirtualMachineName = tostring(Scope_s[-1])
| project StartTime, EndTime, Subscription, VirtualMachineName, CorrelationId, Caller, CallerIpAddress=max_CallerIpAddress
| evaluate ipv4_lookup(azure_ranges, CallerIpAddress, values_properties_addressPrefixes)
| extend timestamp = StartTime, IPCustomEntity=CallerIpAddress"
"3becd9d6-57c4-4d8d-9177-3887d721b6cf","Detect PIM Alert Disabling activity","true","Detection","Medium","AzureActiveDirectory","SecurityAlert","1d","1d","当 Azure Active Directory (Azure AD) 组织中存在可疑或不安全活动时，特权身份管理 (PIM) 会生成警报。 
此查询将帮助检测攻击者试图禁用与 Azure MFA 要求相关的产品 PIM 警报，并可能指示特权访问的激活。","AuditLogs
| where LoggedByService =~ ""PIM""
| where Category =~ ""RoleManagement""
| where ActivityDisplayName has ""Disable PIM Alert""
| extend IpAddress = case(
  isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)) and tostring(parse_json(tostring(InitiatedBy.user)).ipAddress) != 'null', tostring(parse_json(tostring(InitiatedBy.user)).ipAddress), 
  isnotempty(tostring(parse_json(tostring(InitiatedBy.app)).ipAddress)) and tostring(parse_json(tostring(InitiatedBy.app)).ipAddress) != 'null', tostring(parse_json(tostring(InitiatedBy.app)).ipAddress),
  'Not Available')
| extend InitiatedBy = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), 
  tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), tostring(parse_json(tostring(InitiatedBy.app)).displayName)), UserRoles = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)
| project InitiatedBy, ActivityDateTime, ActivityDisplayName, IpAddress, AADOperationType, AADTenantId, ResourceId, CorrelationId, Identity
| extend timestamp = ActivityDateTime, IPCustomEntity = IpAddress, AccountCustomEntity = tolower(InitiatedBy), ResourceCustomEntity = ResourceId"
"796c5d19-7ea8-4683-afcb-22fd9b301cad","User account added or removed from a security group by an unauthorized user","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","本规则将识别未经授权的用户在安全组中添加或删除的用户帐户","// Create DataTable with your own values, example below shows dummy usernames that are authorized and for what domain
let List = datatable(AuthorizedUser:string, Domain:string)[""Bob"", ""Domain"", ""joe"", ""domain"", ""MATT"", ""DOMAIN""];
let timeframe = 1d;
SecurityEvent
| where TimeGenerated >= ago(timeframe)
| where EventID in (4728, 4729, 4732, 4733, 4746, 4747, 4751, 4752, 4756, 4757, 4761, 4762)
| join kind= leftanti (
    List
    | project SubjectUserName = tolower(AuthorizedUser), SubjectDomainName = toupper(Domain)
) on SubjectUserName, SubjectDomainName
| project TimeGenerated, Computer, Account, SubjectUserName, SubjectDomainName, TargetAccount, EventID, Activity
| extend timestamp = TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account"
"4664982f-dfc4-4ceb-86e6-563a42a35783","Host Exporting Mailbox and Removing Export","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","This hunting query looks for hosts exporting a mailbox from an on-prem Exchange server, followed by
that same host removing the export within a short time window. This pattern has been observed by attackers 
when exfiltrating emails from a target environment. A Mailbox export is unlikely to be a common command run so look for
activity from unexpected hosts and accounts.
Reference: https://www.volexity.com/blog/2020/12/14/dark-halo-leverages-solarwinds-compromise-to-breach-organizations/'
","// Adjust the timeframe to change the window events need to occur within to alert
let timeframe = 1h;
SecurityEvent
| where EventID == 4688
| where Process in~ (""powershell.exe"", ""cmd.exe"")
| where CommandLine contains 'New-MailboxExportRequest'
| summarize by Computer, timekey = bin(TimeGenerated, timeframe), CommandLine, SubjectUserName
| join kind=inner (SecurityEvent
| where EventID == 4688
| where Process in~ (""powershell.exe"", ""cmd.exe"")
| where CommandLine contains 'Remove-MailboxExportRequest'
| summarize by Computer, timekey = bin(TimeGenerated, timeframe), CommandLine, SubjectUserName) on Computer, timekey, SubjectUserName
| extend commands = pack_array(CommandLine1, CommandLine)
| summarize by timekey, Computer, tostring(commands), SubjectUserName
| project-reorder timekey, Computer, SubjectUserName, ['commands']
| extend HostCustomEntity = Computer, AccountCustomEntity = SubjectUserName"
"0bcc1ad6-7190-4b0f-802a-4d0e70e7383f","Spike in failed sign-in events","true","Hunting","none","AzureActiveDirectory","SigninLogs","none","none","Identifies spikes in failed sign-in events based on the volume of failed sign-in events over time. Use to identify patterns of suspicious behavior such as unusually high failed sign-in attempts from certain users.
Ref : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts'
","let starttime = todatetime('{{StartTimeISO}}');
let auditLookback = starttime - 14d;
let ts_data = (SigninLogs
| where TimeGenerated between(auditLookback..starttime)
| where ResultType != 0
| make-series count() on TimeGenerated step 1h by UserPrincipalName
| extend series_decompose(count_)
| extend NoLogons = count_);
let TimeSeriesAlerts=ts_data
  | extend (anomalies, score, baseline) = series_decompose_anomalies(count_, 1.5, -1, 'linefit',0, 'ctukey', 0.7)
  | mv-expand NoLogons to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double),score to typeof(double), baseline to typeof(long)
  | where anomalies > 0
  | project UserPrincipalName, TimeGenerated, NoLogons, baseline, anomalies, score;
TimeSeriesAlerts
  | join kind=inner (
  SigninLogs
  | summarize ResultTypeCount=count(),ResultTypes=make_set(ResultType), Locations=make_set(Location), Apps=make_set(AppDisplayName), Ips=make_set( IPAddress) by UserPrincipalName, bin(TimeGenerated, 1h)
  ) on UserPrincipalName, TimeGenerated
  | summarize AnomolyTimes = make_set(TimeGenerated), Ips = make_set(Ips), Apps = make_set(Apps), sum(anomalies), Locations=make_set(Locations) by UserPrincipalName
  | sort by sum_anomalies desc"
"71ef21fe-3040-475b-ab7d-690a237e4f45","AD FS Remote Auth Sync Connection","true","Detection","Medium","SecurityEvents","SecurityEvent","1d","1d","此检测使用来自“AD FS 审核”提供程序的安全事件来检测 AD FS 服务器上的可疑身份验证事件。 然后将结果与来自 Windows 筛选平台 (WFP) 的事件相关联，以检测 AD FS 服务器上端口 80 上的可疑传入网络流量。 
这可能是威胁行为者试图使用 AD FS 服务器上的复制服务来获取其配置设置并提取敏感信息（例如 AD FS 证书）的迹象。
为了使用此查询，您需要启用 AD FS 审核 AD FS 服务器。 
参考：https://twitter.com/OTR_Community/status/1387038995016732672","// Adjust this to use a longer timeframe to identify ADFS servers
//let lookback = 0d;
// Adjust this to adjust detection timeframe
//let timeframe = 1d;
// SamAccountName of AD FS Service Account. Filter on the use of a specific AD FS user account
//let adfsuser = 'adfsadmin';
// Identify ADFS Servers
let ADFS_Servers = (
    SecurityEvent
    //| where TimeGenerated > ago(timeframe+lookback)
    | where EventSourceName == 'AD FS Auditing'
    | distinct Computer
);
SecurityEvent
    //| where TimeGenerated > ago(timeframe)
    | where Computer in~ (ADFS_Servers)
    // A token of type 'http://schemas.microsoft.com/ws/2006/05/servicemodel/tokens/SecureConversation'
    // for relying party '-' was successfully authenticated.
    | where EventID == 412
    | extend EventData = parse_xml(EventData).EventData.Data
    | extend InstanceId = tostring(EventData[0])
| join kind=inner
(
    SecurityEvent
    //| where TimeGenerated > ago(timeframe)
    | where Computer in~ (ADFS_Servers)
    // Events to identify caller identity from event 412
    | where EventID == 501
    | extend EventData = parse_xml(EventData).EventData.Data
    | where tostring(EventData[1]) contains 'identity/claims/name'
    | extend InstanceId = tostring(EventData[0])
    | extend ClaimsName = tostring(EventData[2])
    // Filter on the use of a specific AD FS user account
    //| where ClaimsName contains adfsuser
)
on $left.InstanceId == $right.InstanceId
| join kind=inner
(
    SecurityEvent
    | where EventID == 5156
    | where Computer in~ (ADFS_Servers)
    | extend EventData = parse_xml(EventData).EventData.Data
    | mv-expand bagexpansion=array EventData
    | evaluate bag_unpack(EventData)
    | extend Key = tostring(column_ifexists('@Name', """")), Value = column_ifexists('#text', """")
    | evaluate pivot(Key, any(Value), TimeGenerated, Computer, EventID)
    | extend DestPort = column_ifexists(""DestPort"", """"),
          Direction = column_ifexists(""Direction"", """"),
          Application = column_ifexists(""Application"", """"),
          DestAddress = column_ifexists(""DestAddress"", """"),
          SourceAddress = column_ifexists(""SourceAddress"", """"),
          SourcePort = column_ifexists(""SourcePort"", """")
    // Look for inbound connections from endpoints on port 80
    | where DestPort == 80 and Direction == '%%14592' and Application == 'System'
    | where DestAddress !in ('::1','0:0:0:0:0:0:0:1') 
)
on $left.Computer == $right.Computer
| project TimeGenerated, Computer, ClaimsName, SourceAddress, SourcePort
| extend HostCustomEntity = Computer, AccountCustomEntity = ClaimsName, IPCustomEntity = SourceAddress"
"dc11bdd8-c01a-4acd-aba0-f5b21a64e7d8","User account created and deleted within 10 mins","true","Detection","Medium","SecurityEvents","SecurityEvent","1d","2d","Identifies when a user account is created and then deleted within 10 minutes. This can be an indication of compromise and
an adversary attempting to hide in the noise.","let timeframe = 1d;
let spanoftime = 10m;
let threshold = 0;
SecurityEvent 
| where TimeGenerated > ago(2*timeframe) 
// A user account was created
| where EventID == 4720
| where AccountType =~ ""User""
| project creationTime = TimeGenerated, CreateEventID = EventID, Activity, Computer, TargetUserName, UserPrincipalName, 
AccountUsedToCreate = SubjectUserName, TargetSid, SubjectUserSid 
| join kind= inner (
  SecurityEvent
  | where TimeGenerated > ago(timeframe) 
  // A user account was deleted 
  | where EventID == 4726
| where AccountType == ""User""
| project deletionTime = TimeGenerated, DeleteEventID = EventID, Activity, Computer, TargetUserName, UserPrincipalName, 
AccountUsedToDelete = SubjectUserName, TargetSid, SubjectUserSid 
) on Computer, TargetUserName
| where deletionTime - creationTime < spanoftime
| extend TimeDelta = deletionTime - creationTime
| where tolong(TimeDelta) >= threshold
| project TimeDelta, creationTime, CreateEventID, Computer, TargetUserName, UserPrincipalName, AccountUsedToCreate, 
deletionTime, DeleteEventID, AccountUsedToDelete
| extend timestamp = creationTime, AccountCustomEntity = AccountUsedToCreate, HostCustomEntity = Computer"
"e3ff1e7b-3035-44f2-b9de-2e955fb61a63","Azure AD Health Service Agents Registry Keys Access","false","Detection","Medium","SecurityEvents","SecurityEvent","1d","1d","此检测使用 Windows 安全事件来检测对 Azure AD Health 服务代理（例如 AD FS）的注册表项值和子项的可疑访问尝试。
来自 AD Health 服务代理的信息可用于潜在地滥用提供的某些功能 由云中的那些服务（例如联合）。
此检测需要以下安全对象的系统访问控制列表 (SACL) 上的访问控制条目 (ACE)：HKLM:\SOFTWARE\Microsoft\ADHealthAgent。 确保将 SACL 设置为传播到其子项。 您可以在此处找到更多信息 https://github.com/OTRF/Set-AuditRule/blob/master/rules/registry/aad_connect_health_service_agent.yml","// ADHealthAgent Registry Key
let aadConnectHealthRegKey = ""\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\ADHealthAgent"";
// Filter out known processes
let aadConnectHealthProcs = dynamic ([
    'Microsoft.Identity.Health.Adfs.DiagnosticsAgent.exe',
    'Microsoft.Identity.Health.Adfs.InsightsService.exe',
    'Microsoft.Identity.Health.Adfs.MonitoringAgent.Startup.exe',
    'Microsoft.Identity.Health.Adfs.PshSurrogate.exe',
    'Microsoft.Identity.Health.Common.Clients.ResourceMonitor.exe'
]);
(union isfuzzy=true
(
SecurityEvent
| where EventID == '4656'
| extend EventData = parse_xml(EventData).EventData.Data
| mv-expand bagexpansion=array EventData
| evaluate bag_unpack(EventData)
| extend Key = tostring(column_ifexists('@Name', """")), Value = column_ifexists('#text', """")
| evaluate pivot(Key, any(Value), TimeGenerated, Computer, EventID)
| extend SubjectUserName = column_ifexists(""SubjectUserName"", """"),
    SubjectDomainName = column_ifexists(""SubjectDomainName"", """"),
    ObjectName = column_ifexists(""ObjectName"", """"),
    ObjectType = column_ifexists(""ObjectType"", """"),
    ProcessName = column_ifexists(""ProcessName"", """")
| extend Process = split(ProcessName, '\\', -1)[-1],
    Account = strcat(SubjectDomainName, ""\\"", SubjectUserName)
| where ObjectType == 'Key'
| where ObjectName startswith aadConnectHealthRegKey
| where Process !in (aadConnectHealthProcs)
),
(
SecurityEvent
| where EventID == '4663'
| extend Process = split(ProcessName, '\\', -1)[-1]
| where ObjectType == 'Key'
| where ObjectName startswith aadConnectHealthRegKey
| where Process !in (aadConnectHealthProcs)
)
)
// You can filter out potential machine accounts
//| where AccountType != 'Machine'
| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer"
"0fc8661c-c74a-4743-8011-291198202f53","PIM Elevation Request Rejected","true","Detection","High","AzureActiveDirectory","AuditLogs","2h","2h","标识用户何时因通过 PIM 的特权角色提升而被拒绝。 监控对请求帐户的攻击者入侵指标的拒绝。 参考：https://docs.microsoft.comazure/active-directory/fundamentals/security-operations-privileged-identity-management","AuditLogs
| where ActivityDisplayName =~'Add member to role completed (PIM activation)'
| where Result == ""failure""
| extend Role = tostring(TargetResources[3].displayName)
| extend User = tostring(TargetResources[2].displayName)
| project-reorder TimeGenerated, User, Role, OperationName, Result, ResultDescription
| extend InitiatingUser = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| extend AccountCustomEntity = User, IPCustomEntity = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)"
"c0f64109-ac5e-404f-802d-d18de551ef90","Hosts running a rare process with commandline","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","本规则用于寻找运行罕见进程的主机（包含命令行）。 低于 30 天平均值的 1%，并且在给定主机上的计数低于 100 或在过去 7 天内在给定主机上的计数低于 14","let v_StartTime = ago(7d);
let v_EndTime = ago(1m);
let basic=materialize(
  SecurityEvent
    | where TimeGenerated >= ago(30d)
    | where EventID == 4688
    | where isnotempty(CommandLine) and NewProcessName !endswith "":\\windows\\system32\\conhost.exe"" and CommandLine !~ NewProcessName and CommandLine !~ strcat('\""',NewProcessName,'\""',"" ""))
    | extend CommandLine=tolower(CommandLine)
    | summarize FullCount = count()
                , Count= countif(TimeGenerated between (v_StartTime .. v_EndTime))
                , min_TimeGenerated=min(TimeGenerated)
                , max_TimeGenerated=max(TimeGenerated) 
                      by Computer, NewProcessName, CommandLine
    | where Count > 0 and Count < 100);
let basic_avg = basic
    | summarize Avg = avg(FullCount) by  NewProcessName, CommandLine;
basic | project-away FullCount
  | join kind=inner 
basic_avg 
  on NewProcessName, CommandLine | project-away NewProcessName1, CommandLine1
  | where Count < 7 or (Count <= Avg*0.01 and Count < 100) 
  | extend HostCustomEntity=Computer"
"a144b1d5-98ee-44a0-a2fc-7336672bd7fd","Dormant User Update MFA and Logs In - UEBA","true","Hunting","none","AzureActiveDirectory","MultipleDataSources","none","none","This query look for accounts that have not been successfully logged into recently who then add or update an MFA method before logging in.
Threat actors may look to re-activate dormant accounts and use them for access by adding MFA methods in the hope that changes to such dormant accounts may go un-noticed. This query uses the Azure Sentinel UEBA features.
Ref: [LINK TO BLOG]'
","let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = endtime - 14d;
let active_users = (
  BehaviorAnalytics
  | extend dormant = tostring(UsersInsights.IsDormantAccount)
  | where isempty(dormant)
  | summarize by UserPrincipalName);
AuditLogs
| where TimeGenerated between(starttime..endtime)
// Get users where they added MFA
| where OperationName =~ ""User registered security info""
| extend TargetUser = tolower(tostring(TargetResources[0].userPrincipalName))
| extend UserId = tostring(TargetResources[0].id)
// Check and see if this activity was from a user who is considered not active
| where UserId !in (active_users)
// Further reduce FP by just looking at users who have successfully logged in recently as well (avoiding hits for users adding MFA but not actually logging in)
| join kind=inner (SigninLogs | where TimeGenerated > ago(1d) | where ResultType == 0 | summarize max(TimeGenerated), make_set(IPAddress), make_set(UserAgent), make_set(LocationDetails) by UserPrincipalName, UserId
) on UserId
| extend LogonLocation = set_LocationDetails[0], LogonUserAgent = set_UserAgent[0], LogonIP = set_IPAddress[0]
| project-rename MostRecentLogon = max_TimeGenerated
| project-reorder TimeGenerated, TargetUser, OperationName, ResultDescription, MostRecentLogon, LogonUserAgent, LogonLocation, LogonIP
| extend AccountCustomEntity = TargetUser, IPCustomEntity = LogonIP"
"e0166936-c2be-4662-854f-b55454f0878a","Squid proxy events related to mining pools","true","Detection","Low","Syslog","Syslog","1d","1d","本规则用于检查 Syslog，当发现出现和常见“挖矿'软件矿池有关联的 Squid 代理事件将发起告警","let timeframe = 1d;
let DomainList = dynamic([""monerohash.com"", ""do-dear.com"", ""xmrminerpro.com"", ""secumine.net"", ""xmrpool.com"", ""minexmr.org"", ""hashanywhere.com"", ""xmrget.com"", 
""mininglottery.eu"", ""minergate.com"", ""moriaxmr.com"", ""multipooler.com"", ""moneropools.com"", ""xmrpool.eu"", ""coolmining.club"", ""supportxmr.com"",
""minexmr.com"", ""hashvault.pro"", ""xmrpool.net"", ""crypto-pool.fr"", ""xmr.pt"", ""miner.rocks"", ""walpool.com"", ""herominers.com"", ""gntl.co.uk"", ""semipool.com"", 
""coinfoundry.org"", ""cryptoknight.cc"", ""fairhash.org"", ""baikalmine.com"", ""tubepool.xyz"", ""fairpool.xyz"", ""asiapool.io"", ""coinpoolit.webhop.me"", ""nanopool.org"", 
""moneropool.com"", ""miner.center"", ""prohash.net"", ""poolto.be"", ""cryptoescrow.eu"", ""monerominers.net"", ""cryptonotepool.org"", ""extrmepool.org"", ""webcoin.me"", 
""kippo.eu"", ""hashinvest.ws"", ""monero.farm"", ""supportxmr.com"", ""xmrpool.eu"", ""linux-repository-updates.com"", ""1gh.com"", ""dwarfpool.com"", ""hash-to-coins.com"", 
""hashvault.pro"", ""pool-proxy.com"", ""hashfor.cash"", ""fairpool.cloud"", ""litecoinpool.org"", ""mineshaft.ml"", ""abcxyz.stream"", ""moneropool.ru"", ""cryptonotepool.org.uk"",
""extremepool.org"", ""extremehash.com"", ""hashinvest.net"", ""unipool.pro"", ""crypto-pools.org"", ""monero.net"", ""backup-pool.com"", ""mooo.com"", ""freeyy.me"", ""cryptonight.net"",
""shscrypto.net""]);
Syslog
| where TimeGenerated >= ago(timeframe)
| where ProcessName contains ""squid""
| extend URL = extract(""(([A-Z]+ [a-z]{4,5}:\\/\\/)|[A-Z]+ )([^ :]*)"",3,SyslogMessage), 
        SourceIP = extract(""([0-9]+ )(([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3}))"",2,SyslogMessage), 
        Status = extract(""(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))"",1,SyslogMessage), 
        HTTP_Status_Code = extract(""(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))/([0-9]{3})"",8,SyslogMessage),
        User = extract(""(CONNECT |GET )([^ ]* )([^ ]+)"",3,SyslogMessage),
        RemotePort = extract(""(CONNECT |GET )([^ ]*)(:)([0-9]*)"",4,SyslogMessage),
        Domain = extract(""(([A-Z]+ [a-z]{4,5}:\\/\\/)|[A-Z]+ )([^ :\\/]*)"",3,SyslogMessage),
        Bytes = toint(extract(""([A-Z]+\\/[0-9]{3} )([0-9]+)"",2,SyslogMessage)),
        contentType = extract(""([a-z/]+$)"",1,SyslogMessage)
| extend TLD = extract(""\\.[a-z]*$"",0,Domain)
| where HTTP_Status_Code == '200'
| where Domain contains "".""
| where Domain has_any (DomainList)
| extend timestamp = TimeGenerated, URLCustomEntity = URL, IPCustomEntity = SourceIP, AccountCustomEntity = User"
"5bfb8b28-03bc-403d-90ca-cb1f664e53fc","Entropy for Processes for a given Host","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","本规则将识别出Windows上执行的罕见进程。 此处罕见意味着进程在过去 7 天内出现在主机上的次数相对较少。","// May need to reduce the number of days if the environment is very large.  Try 3-5 days, but less accuracy.
let end = startofday(now());
let start = end - 7d;
let Exclude = SecurityEvent
// timeframe is set so that results do not change during the same day (UTC time)
| where TimeGenerated >= start and TimeGenerated <= end
| where EventID == 4688
| summarize ExcludeCompCount = dcount(Computer),  ExcludeProcCount = count() by Process 
// Removing noisy processes for an environment, adjust as needed
| where ExcludeProcCount >= 2000 and ExcludeCompCount > 2
;
let AllSecEvents = SecurityEvent
| where TimeGenerated >= start and TimeGenerated <= end
| where EventID == 4688
// excluding well known processes
| where NewProcessName !endswith ':\\Windows\\System32\\conhost.exe' and ParentProcessName !endswith ':\\Windows\\System32\\conhost.exe'
| where ParentProcessName !endswith "":\\Windows\\System32\\wuauclt.exe"" and NewProcessName !startswith ""C:\\Windows\\SoftwareDistribution\\Download\\Install\\AM_Delta_Patch_""
| where ParentProcessName !has "":\\WindowsAzure\\GuestAgent_"" and NewProcessName !has "":\\WindowsAzure\\GuestAgent_""
| where ParentProcessName !has "":\\WindowsAzure\\WindowsAzureNetAgent_"" and NewProcessName !has "":\\WindowsAzure\\WindowsAzureNetAgent_""
| where ParentProcessName !has "":\\ProgramData\\Microsoft\\Windows Defender\\platform\\"" and ParentProcessName !endswith ""\\MpCmdRun.exe"" 
| project Computer, Process;
// Removing noisy process from full list
let Include = Exclude | join kind= rightanti (
AllSecEvents
) on Process;
// Identifying prevalence for a given process in the environment
let DCwPC = Include | summarize DistinctComputersWithProcessCount = dcount(Computer) by Process
| join kind=inner (
Include 
) on Process
| distinct Computer, Process, DistinctComputersWithProcessCount;
// Getting the Total process count on each host to use as the denominator in the entropy calc
let TPCoH = Include | summarize TotalProcessCountOnHost = count(Process) by Computer
| join kind=inner (
Include 
) on Computer
| distinct Computer, Process, TotalProcessCountOnHost
//Getting a decimal value for later computation
| extend TPCoHValue = todecimal(TotalProcessCountOnHost);
// Need the count of each class in my bucket or also said as count of ProcName(Class) per Host(Bucket) for use in the entropy calc
let PCoH = Include | summarize ProcessCountOnHost = count(Process) by Computer, Process
| join kind=inner (
Include
) on Computer,Process
| distinct Computer, Process, ProcessCountOnHost
//Getting a decimal value for later computation
| extend PCoHValue = todecimal(ProcessCountOnHost);
let Combined = DCwPC | join ( TPCoH ) on Computer, Process | join ( PCoH ) on Computer, Process; 
let Results = Combined
// Entropy calculation
| extend ProcessEntropy = -log2(PCoHValue/TPCoHValue)*(PCoHValue/TPCoHValue)
| extend AdjustedProcessEntropy = toreal(ProcessEntropy*10000)
// Calculating Weight, see details in description
| extend Weight = toreal((ProcessEntropy*10000)*ProcessCountOnHost*DistinctComputersWithProcessCount)
// Remove or increase value to see processes with low entropy, meaning more common.
| where Weight <= 75
| project Computer, Process, Weight , ProcessEntropy, TotalProcessCountOnHost, ProcessCountOnHost, DistinctComputersWithProcessCount, AdjustedProcessEntropy;
// Join back full entry
Results | join kind= inner (
    SecurityEvent
    | where TimeGenerated >= start and TimeGenerated <= end
    | where EventID == 4688
    // excluding well known processes
    | where NewProcessName !endswith ':\\Windows\\System32\\conhost.exe' and ParentProcessName !endswith ':\\Windows\\System32\\conhost.exe'
    | where ParentProcessName !endswith "":\\Windows\\System32\\wuauclt.exe"" and NewProcessName !startswith ""C:\\Windows\\SoftwareDistribution\\Download\\Install\\AM_Delta_Patch_""
    | where ParentProcessName !has "":\\WindowsAzure\\GuestAgent_"" and NewProcessName !has "":\\WindowsAzure\\GuestAgent_""
    | where ParentProcessName !has "":\\WindowsAzure\\WindowsAzureNetAgent_"" and NewProcessName !has "":\\WindowsAzure\\WindowsAzureNetAgent_""
    | where ParentProcessName !has "":\\ProgramData\\Microsoft\\Windows Defender\\platform\\"" and ParentProcessName !endswith ""\\MpCmdRun.exe"" 
    | project TimeGenerated, EventID, Computer, SubjectUserSid, Account, AccountType, Process, NewProcessName, CommandLine, ParentProcessName
) on Computer, Process
| project TimeGenerated, EventID, Computer, SubjectUserSid, Account, Weight, AdjustedProcessEntropy, FullDecimalProcessEntropy = ProcessEntropy, Process, NewProcessName, CommandLine, ParentProcessName, TotalProcessCountOnHost, ProcessCountOnHost, DistinctComputersWithProcessCount
| sort by Weight asc, AdjustedProcessEntropy asc, NewProcessName asc
| extend timestamp = TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account"
"2e31f7d9-3351-4870-9a4d-07743700fbd9","Same IP address with multiple csUserAgent","true","Hunting","none","AzureMonitor(IIS)","W3CIISLog","none","none","This alerts when the same client IP (cIP) is connecting with more than 1 but less than 15 different useragent string (csUserAgent) in less than 1 hour.
We limit to 50 or less connections to avoid high traffic sites. This may indicate malicious activity as this is a method of probing an environment
References: Status code mappings for your convenience
IIS status code mapping - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0
Win32 Status code mapping - https://msdn.microsoft.com/library/cc231199.aspx","let timeframe = ago(1h);
W3CIISLog
| where TimeGenerated >= timeframe
| where scStatus !startswith ""20"" and scStatus !startswith ""30"" and cIP !startswith ""192.168."" and cIP != sIP and cIP != ""::1""
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), makeset(csUserAgent), ConnectionCount = count() 
by Computer, sSiteName, sIP, sPort, cIP, csMethod
| extend csUserAgentPerIPCount = arraylength(set_csUserAgent)
| where  csUserAgentPerIPCount between ( 2 .. 15 ) and ConnectionCount <=50
| extend timestamp = StartTimeUtc, IPCustomEntity = cIP, HostCustomEntity = Computer"
"e2d28d4e-7ff5-4ef6-9282-ebb818f3a189","Hosts with new logons","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","本规则将显示首次登录主机的新帐户。如果发现帐户首次登录多个主机，这可能意味着该帐户被用于横向攻击","let starttime = 7d;
let endtime = 1d;
let LogonEvents=() { 
let logonSuccess=SecurityEvent 
| where EventID==4624 
| project TimeGenerated, ComputerName=Computer, AccountName=TargetUserName, AccountDomain=TargetDomainName, IpAddress, ActionType='Logon';
let logonFail=SecurityEvent 
| where EventID==4625 
| project TimeGenerated, ComputerName=Computer, AccountName=TargetUserName, AccountDomain=TargetDomainName, IpAddress, ActionType='LogonFailure';
logonFail 
| union logonSuccess
};
LogonEvents 
| where TimeGenerated > ago(endtime) 
| where ActionType == 'Logon' 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count() by ComputerName, AccountName 
| join kind=leftanti ( 
LogonEvents 
| where TimeGenerated between(ago(starttime)..ago(endtime)) 
| where ActionType == 'Logon' 
| summarize count() by ComputerName, AccountName 
) on ComputerName, AccountName 
| summarize StartTimeUtc = min(StartTimeUtc), EndTimeUtc = max(EndTimeUtc), HostCount=dcount(ComputerName), HostSet=makeset(ComputerName, 10)  by AccountName, ComputerName
| extend timestamp = StartTimeUtc, AccountCustomEntity = AccountName"
"8cb99718-4cee-4d43-a175-b9597e21b8cb","Cisco - firewall block but success logon to Azure AD","true","Detection","Medium","CiscoASA","MultipleDataSources","1d","1d","Correlate IPs blocked by a Cisco firewall appliance with successful Azure Active Directory signins. 
Because the IP was blocked by the firewall, that same IP logging on successfully to AAD is potentially suspect
and could indicate credential compromise for the user account.","let PrivateIPregex = @'^127\.|^10\.|^172\.1[6-9]\.|^172\.2[0-9]\.|^172\.3[0-1]\.|^192\.168\.';
let endtime = 1d;
CommonSecurityLog
| where TimeGenerated >= ago(endtime) 
| where DeviceVendor =~ ""Cisco""
| where DeviceAction =~ ""denied""
| extend SourceIPType = iff(SourceIP matches regex PrivateIPregex,""private"" ,""public"" )
| where SourceIPType == ""public""
| summarize count() by SourceIP
| join (
    // Successful signins from IPs blocked by the firewall solution are suspect
    // Include fully successful sign-ins, but also ones that failed only at MFA stage
    // as that supposes the password was sucessfully guessed.
  SigninLogs
  | where ResultType in (""0"", ""50074"", ""50076"") 
) on $left.SourceIP == $right.IPAddress
| extend timestamp = TimeGenerated, IPCustomEntity = SourceIP, AccountCustomEntity = UserPrincipalName"
"0e5c0ffe-1e2f-48e3-9f78-28c8736ead03","Hosts running a rare process","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","本规则用于寻找运行罕见进程的主机。 低于 30 天平均值的 1%，并且在给定主机上的计数低于 100 或在过去 7 天内在给定主机上的计数低于 14","let v_StartTime = ago(1d);
let v_EndTime = ago(1m);
let basic=materialize(
  SecurityEvent
    | where TimeGenerated >= ago(30d)
    | where EventID == 4688
    | summarize FullCount = count()
                , Count= countif(TimeGenerated between (v_StartTime .. v_EndTime))
                , min_TimeGenerated=min(TimeGenerated)
                , max_TimeGenerated=max(TimeGenerated) 
                      by Computer, NewProcessName
    | where Count > 0 and Count < 100);
let basic_avg = basic
    | summarize Avg = avg(FullCount) by  NewProcessName;
basic | project-away FullCount
  | join kind=inner 
basic_avg 
  on NewProcessName | project-away NewProcessName1
  | where Count < 14 or (Count <= Avg*0.01 and Count < 100) 
  | extend HostCustomEntity=Computer"
"60725789-c381-4378-a2b7-c064fb2befb3","Same User - Successful logon for a given App and failure on another App within 1m and low distribution","true","Hunting","none","AzureActiveDirectory","SigninLogs","none","none","本规则将识别用户帐户何时成功登录到给定的应用程序，并且在 1 分钟内未能登录到不同的应用程序。这可能表明恶意尝试访问不允许的应用程序以进行发现或潜在的横向移动","let timeframe = ago(1d);
let logonDiff = 1m;
let Success = SigninLogs 
| where TimeGenerated >= timeframe 
| where ResultType == ""0"" 
| where AppDisplayName !in (""Office 365 Exchange Online"", ""Skype for Business Online"", ""Office 365 SharePoint Online"")
| project SuccessLogonTime = TimeGenerated, UserPrincipalName, IPAddress , SuccessAppDisplayName = AppDisplayName;
let Fail = SigninLogs 
| where TimeGenerated >= timeframe 
| where ResultType !in (""0"", ""50140"") 
| where ResultDescription !~ ""Other"" 
| where AppDisplayName !in (""Office 365 Exchange Online"", ""Skype for Business Online"", ""Office 365 SharePoint Online"")
| project FailedLogonTime = TimeGenerated, UserPrincipalName, IPAddress , FailedAppDisplayName = AppDisplayName, ResultType, ResultDescription;
let InitialDataSet = 
Success | join kind= inner (
Fail
) on UserPrincipalName, IPAddress 
| where isnotempty(FailedAppDisplayName)
| where SuccessLogonTime < FailedLogonTime and FailedLogonTime - SuccessLogonTime <= logonDiff and SuccessAppDisplayName != FailedAppDisplayName;
let InitialHits = 
InitialDataSet
| summarize FailedLogonTime = min(FailedLogonTime), SuccessLogonTime = min(SuccessLogonTime) 
by UserPrincipalName, SuccessAppDisplayName, FailedAppDisplayName, IPAddress, ResultType, ResultDescription;
// Only take hits where there is 5 or less distinct AppDisplayNames on the success side as this limits highly active applications where failures occur more regularly
let Distribution =
InitialDataSet
| summarize count(SuccessAppDisplayName) by SuccessAppDisplayName, ResultType
| where count_SuccessAppDisplayName <= 5;
InitialHits | join (
   Distribution 
) on SuccessAppDisplayName, ResultType
| project UserPrincipalName, SuccessLogonTime, IPAddress, SuccessAppDisplayName, FailedLogonTime, FailedAppDisplayName, ResultType, ResultDescription 
| extend timestamp = SuccessLogonTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress"
"74e2f3f7-e677-418e-a5de-5abffab493f3","Failed service logon attempt by user account with available AuditData","true","Hunting","none","AzureActiveDirectory","MultipleDataSources","none","none","本规则将查找用户帐户在当前时间段内登录失败（默认为过去 1 天）记录， 找出超过 10 次失败的登录或使用 3 个不同的 IP的登录尝试。此外，如果可用，将加入与给定 UserPrincipalName 相关的过去几天（默认 7 天）的 Azure 审核日志数据。这有助于了解与用户或组管理相关的同一用户的任何事件。结果可能表明对很少使用的帐户的潜在恶意使用。 这可能是一个新帐户或新启用的帐户。关联的 Azure 审核数据应有助于确定此帐户最近的任何更改，并可能帮助您了解登录失败的原因。未收到任何结果表示在默认 7 天内有不少于 10 次失败的登录或与此 UserPrincipalName 相关的审核日志。","let current = 1d;
let failLimit = 10;
let ipLimit = 3;
let auditLookback = 7d;
let FailedSignins = SigninLogs 
| where TimeGenerated >= ago(current)
| where ResultType != ""0"" and AppDisplayName != ""Windows Sign In""
| extend UserPrincipalName = tolower(UserPrincipalName)
| extend CityState = strcat(tostring(LocationDetails.city),""|"", tostring(LocationDetails.state))
| extend Result = strcat(ResultType,""-"",ResultDescription) 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), DistinctIPAddressCount = dcount(IPAddress), IPAddresses = makeset(IPAddress), 
CityStates = makeset(CityState), DistinctResultCount = dcount(Result), Results = makeset(Result), AppDisplayNames = makeset(AppDisplayName), 
FailedLogonCount = count() by Type, OperationName, Category, UserPrincipalName = tolower(UserPrincipalName), ClientAppUsed, Location, CorrelationId
| project Type, StartTimeUtc, EndTimeUtc, OperationName, Category, UserPrincipalName, AppDisplayNames, DistinctIPAddressCount, IPAddresses, DistinctResultCount, 
Results, FailedLogonCount, Location, CityStates 
| where FailedLogonCount >= failLimit or DistinctIPAddressCount >= ipLimit
| extend Activity = pack(""IPAddresses"", IPAddresses, ""AppDisplayNames"", AppDisplayNames, ""Results"", Results, ""Location"", Location, ""CityStates"", CityStates)
| project Type, StartTimeUtc, EndTimeUtc, OperationName, Category, UserPrincipalName, FailedLogonCount, DistinctIPAddressCount, DistinctResultCount, Activity
| extend AccountCustomEntity = UserPrincipalName;
let AccountMods = AuditLogs | where TimeGenerated >= ago(current+auditLookback)
| where Category == ""UserManagement"" or Category == ""GroupManagement""
| extend ModProps = TargetResources.[0].modifiedProperties
| extend InitiatedBy = case(
isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName),
isnotempty(tostring(parse_json(tostring(InitiatedBy.app)).displayName)), tostring(parse_json(tostring(InitiatedBy.app)).displayName),
"""")
| extend UserPrincipalName = tolower(tostring(TargetResources.[0].userPrincipalName))
| mvexpand ModProps
| extend PropertyName = tostring(ModProps.displayName), oldValue = tostring(ModProps.oldValue), newValue = tostring(ModProps.newValue)
| extend ModifiedProps = pack(""PropertyName"",PropertyName,""oldValue"",oldValue,""newValue"",newValue) 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Activity = make_bag(ModifiedProps) by Type, InitiatedBy, UserPrincipalName, Category, OperationName, CorrelationId, Id
| extend AccountCustomEntity = UserPrincipalName;
// Gather only Audit data for UserPrincipalNames that we have Audit data for
let AccountNameOnly = FailedSignins | project UserPrincipalName;
let AuditMods = AccountNameOnly
| join kind= innerunique (
AccountMods
) on UserPrincipalName;
let AvailableAudits = AuditMods | project UserPrincipalName;
let SigninsWithAudit = AvailableAudits
| join kind= innerunique (
FailedSignins
) on UserPrincipalName;
// Union the Current Signin failures so we do not lose them with the Auditing data we do have
let Activity = (union isfuzzy=true
SigninsWithAudit, AuditMods)
| order by StartTimeUtc, UserPrincipalName;
Activity
| project StartTimeUtc, EndTimeUtc, DataType = Type, Category, OperationName, UserPrincipalName, InitiatedBy, Activity, FailedLogonCount, DistinctIPAddressCount, DistinctResultCount, CorrelationId, Id
| order by UserPrincipalName, StartTimeUtc
| extend timestamp = StartTimeUtc, AccountCustomEntity = UserPrincipalName"
"4a5cbd5c-6cf7-4dcf-96c3-c8479b1fe3fb","AD FS Remote HTTP Network Connection","false","Detection","Medium","SecurityEvents","SecurityEvent","1d","1d","此检测使用 Sysmon 事件（NetworkConnect 事件）来检测 AD FS 服务器上端口 80 上的传入网络流量。 这可能是威胁参与者试图使用 AD FS 服务器上的复制服务来获取其配置设置并提取敏感信息（例如 AD FS 证书）的迹象。
为了使用此查询，您需要在服务器上启用 Sysmon 遥测 AD FS 服务器。
参考：https://twitter.com/OTR_Community/status/1387038995016732672","// Adjust this to use a longer timeframe to identify ADFS servers
//let lookback = 0d;
// Adjust this to adjust detection timeframe
//let timeframe = 1d;
// Filter out other servers in the AD FS farm
let ADFSServersList = dynamic([""ADFS02.domain.com"",""ADFS03.domain.com""]);
// Start by identifying ADFS servers to reduce FP chance
let ADFS_Servers = (
Event
//| where TimeGenerated > ago(timeframe+lookback)
| where Source == ""Microsoft-Windows-Sysmon""
| where EventID == 18
| where Computer !in (ADFSServersList)
| extend EventData = parse_xml(EventData).DataItem.EventData.Data
| mv-expand bagexpansion=array EventData
| evaluate bag_unpack(EventData)
| extend Key = tostring(column_ifexists('@Name', """")), Value = column_ifexists('#text', """")
| evaluate pivot(Key, any(Value), TimeGenerated, Source, EventLog, Computer, EventLevel, EventLevelName, EventID, UserName, MG, ManagementGroupName, _ResourceId)
| extend Image = column_ifexists(""Image"", """")
| extend process = split(Image, '\\', -1)[-1]
| where process =~ ""Microsoft.IdentityServer.ServiceHost.exe""
| summarize by Computer
);
// Look for ADFS servers receiving connections over port 80
Event
//| where TimeGenerated > ago(timeframe)
| where Source == ""Microsoft-Windows-Sysmon""
| where Computer in~ (ADFS_Servers)
| extend RenderedDescription = tostring(split(RenderedDescription, "":"")[0])
| extend EventData = parse_xml(EventData).DataItem.EventData.Data
| mv-expand bagexpansion=array EventData
| evaluate bag_unpack(EventData)
| extend Key = tostring(column_ifexists('@Name', """")), Value = column_ifexists('#text', """")
| evaluate pivot(Key, any(Value), TimeGenerated, Source, EventLog, Computer, EventLevel, EventLevelName, EventID, UserName, RenderedDescription, MG, ManagementGroupName, _ResourceId)
| extend RuleName = column_ifexists(""RuleName"", """"), TechniqueId = column_ifexists(""TechniqueId"", """"),  TechniqueName = column_ifexists(""TechniqueName"", """")
| parse RuleName with * 'technique_id=' TechniqueId ',' * 'technique_name=' TechniqueName
| where EventID == 3
// Look for endpoints connecting to the AD FS server over port 80
| extend DestinationPort = column_ifexists(""DestinationPort"", """"), Image = column_ifexists(""Image"", """"), Initiated = column_ifexists(""Initiated"", """"), SourceIp = column_ifexists(""DestinationIp"", """"), DestinationIp = column_ifexists(""DestinationIp"", """")
| where DestinationPort == 80
| extend process = split(Image, '\\', -1)[-1]
// Look for the System process receiving connections
| where process == 'System' and Initiated == 'false'
| where DestinationIp !in ('::1','0:0:0:0:0:0:0:1')
| extend Operation = RenderedDescription
| project-reorder TimeGenerated, Operation, Image, Computer, UserName
| extend HostCustomEntity = Computer, AccountCustomEntity = UserName, IPCustomEntity = SourceIp"
"20bc7121-8e97-4974-a339-8bd917ab5d7b","Multiple Password Reset by user","true","Detection","Low","AzureActiveDirectory","MultipleDataSources","1d","1d","本规则将查询是否存在用户跨多个数据源进行的多次密码重置","let TotalThreshold = 100;
let action = dynamic([""change"", ""changed"", ""reset""]);
let pWord = dynamic([""password"", ""credentials""]);
let PasswordResetMultiDataSource =
(union isfuzzy=true
(//Azure Active Directory Password reset events
AuditLogs
| where OperationName has_any (pWord) and OperationName has_any (action) and Result =~ ""success""
| extend AccountType = tostring(TargetResources[0].type), Account = tostring(TargetResources[0].userPrincipalName), 
TargetUserName = tolower(tostring(TargetResources[0].displayName))
| project TimeGenerated, AccountType, Account, Computer = """", Type),
(
Syslog
| where Facility in (""auth"",""authpriv"")
| where SyslogMessage has_any (pWord) and SyslogMessage has_any (action)
| extend AccountType = iif(SyslogMessage contains ""root"", ""Root"", ""Non-Root"")
| where SyslogMessage matches regex "".*password changed for.*""
| parse SyslogMessage with * ""password changed for"" Account
| project TimeGenerated, AccountType, Account, Computer = HostName, Type, TargetUserName=Account)
);
let pwrmd = PasswordResetMultiDataSource
| project TimeGenerated, Computer, AccountType, Account, Type, TargetUserName;
(union isfuzzy=true  
(pwrmd
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Computerlist = make_set(Computer, 25), AccountType = make_set(AccountType, 25), Computer = arg_max(Computer , TimeGenerated), TargetUserList = make_set(TargetUserName, 25), TargetUserName = arg_max(TargetUserName, TimeGenerated), Total=count() by Account, Type
| where Total > PerUserThreshold
| extend ResetPivot = ""PerUserReset""),  
(pwrmd
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ComputerList = make_set(Computer, 25), AccountList = make_set(Account, 25), AccountType = make_set(AccountType, 25), Account = arg_max(Account, TimeGenerated), Computer = arg_max(Computer , TimeGenerated), TargetUserList = make_set(TargetUserName, 25), TargetUserName = arg_max(TargetUserName, TimeGenerated), Total=count() by Type
| where Total > TotalThreshold
| extend ResetPivot = ""TotalUserReset"")
)
| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = Computer"
"6350e6cd-4792-46e3-85b5-3db480714871","MFA Rejected by User","true","Detection","Medium","AzureActiveDirectory","SigninLogs","1h","1h","标识用户拒绝 MFA 提示的准确率。 这可能表明威胁行为者已经泄露了该用户帐户的用户名和密码，并正在使用它来尝试登录该帐户。
 参考: https://docs.microsoft.comazure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-failed-unusual-sign-ins","SigninLogs
| where ResultType == 500121
| extend additionalDetails_ = tostring(Status.additionalDetails)
| where additionalDetails_ =~ ""MFA denied; user declined the authentication""
| extend AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress"
"4e1b1663-2943-470b-8b6c-3975824f00cd","New PowerShell scripts encoded on the commandline","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","本规则将识别出新建的 encoded powershell 脚本的执行。回顾时间是14天。","let starttime = 21d;
let midtime = 14d;
let endtime = 7d;
let ProcessCreationEvents=() {
let processEvents=SecurityEvent
| where EventID==4688
| project  TimeGenerated, ComputerName=Computer,AccountName=SubjectUserName,AccountDomain=SubjectDomainName,
  FileName=tostring(split(NewProcessName, '\\')[-1]),
ProcessCommandLine = CommandLine, 
InitiatingProcessFileName=ParentProcessName,InitiatingProcessCommandLine="""",InitiatingProcessParentFileName="""";
processEvents};
let encodedPSScripts = 
ProcessCreationEvents 
| where TimeGenerated >= ago(midtime)
| where FileName =~ ""powershell.exe""
| where ProcessCommandLine contains ""-encodedCommand"";
encodedPSScripts
| where TimeGenerated > ago(endtime)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count() by ProcessCommandLine
| parse ProcessCommandLine with * ""-EncodedCommand "" encodedCommand
| project StartTimeUtc, EndTimeUtc, decodedCommand=base64_decodestring(substring(encodedCommand, 0, 
 strlen(encodedCommand) - (strlen(encodedCommand) %8))), encodedCommand 
| join kind=anti (encodedPSScripts
  | where TimeGenerated between(ago(starttime)..ago(endtime))
  | summarize count() by ProcessCommandLine
  | parse ProcessCommandLine with * ""-EncodedCommand "" encodedCommand
  | project decodedCommand=base64_decodestring(substring(encodedCommand, 0, 
   strlen(encodedCommand) - (strlen(encodedCommand) %8))), encodedCommand 
) on encodedCommand, decodedCommand 
| extend timestamp = StartTimeUtc"
"c4dccfd4-57ff-45fc-906c-a6c81071fafd","Rundll32 (LOLBins and LOLScripts)","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","This detection uses Sysmon telemetry to hunt Signed Binary Proxy Execution: Rundll32 activities'
","Event
//This query uses sysmon data depending on table name used this may need updataing
| where Source == ""Microsoft-Windows-Sysmon""
| where EventID == 1
| extend RenderedDescription = tostring(split(RenderedDescription, "":"")[0])
| extend EventData = parse_xml(EventData).DataItem.EventData.Data
| mv-expand bagexpansion=array EventData
| evaluate bag_unpack(EventData)
| extend Key = tostring(column_ifexists('@Name', """")), Value = column_ifexists('#text', """")
| evaluate pivot(Key, any(Value), TimeGenerated, Source, EventLog, Computer, EventLevel, EventLevelName, EventID, UserName, RenderedDescription, MG, ManagementGroupName, Type, _ResourceId)
| extend RuleName = column_ifexists(""RuleName"", """"), TechniqueId = column_ifexists(""TechniqueId"", """"),  TechniqueName = column_ifexists(""TechniqueName"", """")
| parse RuleName with * 'technique_id=' TechniqueId ',' * 'technique_name=' TechniqueName
| where Image has ""rundll32.exe""
// Uncomment the next line and add your commandLine Whitelisted/ignore terms.For example ""payload.dll""
// | where CommandLine !contains (""payload.dll"") 
| extend HostCustomEntity = Computer, AccountCustomEntity = UserName"
"bc7b7c80-5074-4f7d-9c27-11cd2ac1ea9a","Suspicious number of resource creation or deployment activities","true","Detection","Medium","AzureActivity","AzureActivity","1d","7d","本规则将对 Azure 中发生异常数量的 VM 创建或部署活动发出告警","let szOperationNames = dynamic([""Microsoft.Compute/virtualMachines/write"", ""Microsoft.Resources/deployments/write""]);
let starttime = 14d;
let endtime = 1d;
AzureActivity
| where TimeGenerated between (startofday(ago(starttime)) .. startofday(ago(endtime)))
| where OperationNameValue  in~ (szOperationNames)
| extend Resource = tostring(Properties_d.resource), ResourceId = tostring(Properties_d.entity)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ActivityTimeStamp = makelist(TimeGenerated), ActivityStatus = makelist(ActivityStatusValue), 
OperationIds = makelist(OperationId), CallerIpAddress = makelist(CallerIpAddress), CorrelationId = makelist(CorrelationId) 
by ResourceId, Caller, OperationNameValue, Resource, ResourceGroup
| mvexpand CallerIpAddress
| where isnotempty(CallerIpAddress)
| make-series dResourceCount=dcount(ResourceId)  default=0 on StartTimeUtc in range(startofday(ago(7d)), now(), 1d) 
by Caller, tostring(ActivityTimeStamp), tostring(ActivityStatus), tostring(OperationIds), tostring(CallerIpAddress), tostring(CorrelationId), ResourceId, OperationNameValue, Resource, ResourceGroup
| extend (RSquare,Slope,Variance,RVariance,Interception,LineFit)=series_fit_line(dResourceCount)
| where Slope > 0.2
| join kind=leftsemi  (
// Last day's activity is anomalous
AzureActivity
| where TimeGenerated >= startofday(ago(endtime))
| where OperationNameValue  in~ (szOperationNames)
| extend Resource = tostring(Properties_d.resource), ResourceId = tostring(Properties_d.entity)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ActivityTimeStamp = makelist(TimeGenerated), ActivityStatus = makelist(ActivityStatus), 
OperationIds = makelist(OperationId), CallerIpAddress = makelist(CallerIpAddress), CorrelationId = makelist(CorrelationId) 
by ResourceId, Caller, OperationNameValue, Resource, ResourceGroup
| mvexpand CallerIpAddress
| where isnotempty(CallerIpAddress)
| make-series dResourceCount=dcount(ResourceId)  default=0 on StartTimeUtc in range(startofday(ago(1d)), now(), 1d) 
by Caller, tostring(ActivityTimeStamp), tostring(ActivityStatus), tostring(OperationIds), tostring(CallerIpAddress), tostring(CorrelationId), ResourceId, OperationNameValue, Resource, ResourceGroup
| extend (RSquare,Slope,Variance,RVariance,Interception,LineFit)=series_fit_line(dResourceCount)
| where Slope > 0.2    
) on Caller, CallerIpAddress        
| mvexpand todynamic(ActivityTimeStamp), todynamic(ActivityStatus), todynamic(OperationIds), todynamic(CorrelationId)
| extend timestamp = ActivityTimeStamp, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress"
"4d43e08f-95ae-4fec-af18-7d2fc3ef419d","Windows System Shutdown/Reboot(Sysmon)","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","This detection uses Sysmon telemetry to detect System Shutdown/Reboot (MITRE Technique: T1529)'
","Event
| where Source == ""Microsoft-Windows-Sysmon""
| where EventID == 1
| extend RenderedDescription = tostring(split(RenderedDescription, "":"")[0])
| extend EventData = parse_xml(EventData).DataItem.EventData.Data
| mv-expand bagexpansion=array EventData
| evaluate bag_unpack(EventData)
| extend Key=tostring(['@Name']), Value=['#text']
| evaluate pivot(Key, any(Value), TimeGenerated, Source, EventLog, Computer, EventLevel, EventLevelName, EventID, UserName, RenderedDescription, MG, ManagementGroupName, Type, _ResourceId)
| extend RuleName = column_ifexists(""RuleName"", """"), TechniqueId = column_ifexists(""TechniqueId"", """"),  TechniqueName = column_ifexists(""TechniqueName"", """")
| parse RuleName with * 'technique_id=' TechniqueId ',' * 'technique_name=' TechniqueName
| where Image has ""shutdown.exe""
| extend HostCustomEntity = Computer, AccountCustomEntity = UserName"
"444f285c-c305-4d35-a836-738168d3e69d","Group added to Built in Domain Local or Global Group","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","本规则将识别过去 7 天内创建的组已添加到特权内置域本地组或全局组，例如企业管理员、证书发布者或 DnsAdmins。 请务必验证这是预期的添加","let timeframe = 7d;
// For AD SID mappings - https://docs.microsoft.com/windows/security/identity-protection/access-control/active-directory-security-groups
let WellKnownLocalSID = ""S-1-5-32-5[0-9][0-9]$"";
// The SIDs for DnsAdmins and DnsUpdateProxy can be different than *-1102 and -*1103. Check these SIDs in your domain before running the query 
let WellKnownGroupSID = ""S-1-5-21-[0-9]*-[0-9]*-[0-9]*-5[0-9][0-9]$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1102$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1103$"";
let GroupAddition = SecurityEvent 
| where TimeGenerated > ago(timeframe)
// 4728 - A member was added to a security-enabled global group
// 4732 - A member was added to a security-enabled local group
// 4756 - A member was added to a security-enabled universal group  
| where EventID in (""4728"", ""4732"", ""4756"") 
| where AccountType == ""User"" and MemberName == ""-""
// Exclude Remote Desktop Users group: S-1-5-32-555
| where TargetSid !in (""S-1-5-32-555"")
| where TargetSid matches regex WellKnownLocalSID or TargetSid matches regex WellKnownGroupSID
| project GroupAddTime = TimeGenerated, GroupAddEventID = EventID, GroupAddActivity = Activity, GroupAddComputer = Computer, 
GroupAddTargetUserName = TargetUserName, GroupAddTargetDomainName = TargetDomainName, GroupAddTargetSid = TargetSid,  
GroupAddSubjectUserName = SubjectUserName, GroupAddSubjectUserSid = SubjectUserSid, GroupSid = MemberSid, Account, Computer
| extend AccountCustomEntity = Account, HostCustomEntity = Computer;
let GroupCreated = SecurityEvent
| where TimeGenerated > ago(timeframe)
// 4727 - A security-enabled global group was created
// 4731 - A security-enabled local group was created
// 4754 - A security-enabled universal group was created
| where EventID in (""4727"", ""4731"", ""4754"")
| where AccountType == ""User""
| project GroupCreateTime = TimeGenerated, GroupCreateEventID = EventID, GroupCreateActivity = Activity, GroupCreateComputer = Computer, 
GroupCreateTargetUserName = TargetUserName, GroupCreateTargetDomainName = TargetDomainName, GroupCreateSubjectUserName = SubjectUserName, 
GroupCreateSubjectDomainName = SubjectDomainName, GroupCreateSubjectUserSid = SubjectUserSid, GroupSid = TargetSid, Account, Computer;
GroupCreated
| join (
GroupAddition
) on GroupSid
| extend timestamp = GroupCreateTime, AccountCustomEntity = Account, HostCustomEntity = Computer"
"151c8e5e-8348-4055-b507-496b7f4bda48","Security Event log cleared","true","Detection","Medium","SecurityEvents","SecurityEvent","1d","1d","Checks for event id 1102 which indicates the security event log was cleared. 
It uses Event Source Name 'Microsoft-Windows-Eventlog' to avoid generating false positives from other sources, like AD FS servers for instance.","let timeframe = 1d;
SecurityEvent
| where TimeGenerated >= ago(timeframe)
| where EventID == 1102 and EventSourceName == ""Microsoft-Windows-Eventlog"" 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), EventCount = count() by Computer, Account, EventID, Activity
| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = Computer"
"c5a556c5-c399-4481-bce6-d92ea5e127dc","Creation of expensive computes in Azure","true","Detection","Low","AzureActivity","AzureActivity","1d","1d","本规则将对在Azure 中创建大型/昂贵的 VM（GPU 或没有大量虚拟 CPU）时发出告警。  Windows/Linux 虚拟机大小参考 - https://docs.microsoft.com/azure/virtual-machines/windows/sizes","let tokens = dynamic([""416"",""208"",""128"",""120"",""96"",""80"",""72"",""64"",""48"",""44"",""40"",""g5"",""gs5"",""g4"",""gs4"",""nc12"",""nc24"",""nv12"",""2s""]);
let operationList = dynamic([""Create or Update Virtual Machine"", ""Create Deployment"", ""Microsoft.Compute/virtualMachines/write""]);
let vmSeriesfilter = 12;
let timeframe = 1d;
AzureActivity
| where TimeGenerated >= ago(timeframe)
| where OperationNameValue in~ (operationList)
| where ActivityStatusValue == ""Accept"" 
| where isnotempty(Properties)
| extend vmSize = tolower(tostring(parse_json(tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).hardwareProfile)).vmSize))
| where isnotempty(vmSize)
| extend vmSeries = split(replace(""[a-z|A-Z]"","""",vmSize),'_',1)[0]
| where vmSize has_any (tokens) or vmSeries > vmSeriesfilter
| extend ComputerName = tostring(parse_json(tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).osProfile)).computerName)
| extend clientIpAddress = tostring(parse_json(HTTPRequest).clientIpAddress)
| project TimeGenerated, OperationNameValue, ActivityStatusValue, Caller, CallerIpAddress, HostCustomEntity=ComputerName, vmSize
| extend timestamp = TimeGenerated, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress"
"f13c3878-00e8-48aa-8cf1-2776e12ae4ad","High count of failed logons by a user","true","Detection","Medium","AzureMonitor(IIS)","W3CIISLog","1d","1d","Identifies when 100 or more failed attempts by a given user in 10 minutes occur on the IIS Server.
This could be indicative of attempted brute force based on known account information.
This could also simply indicate a misconfigured service or device. 
References:
IIS status code mapping - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0
Win32 Status code mapping - https://msdn.microsoft.com/library/cc231199.aspx","let timeframe = 1d;
let timeBin = 10m;
let failedThreshold = 100;
W3CIISLog
| where TimeGenerated >= ago(timeframe)
| where scStatus in (""401"",""403"")
| where csUserName != ""-""
// Handling Exchange specific items in IIS logs to remove the unique log identifier in the URI
| extend csUriQuery = iff(csUriQuery startswith ""MailboxId="", tostring(split(csUriQuery, ""&"")[0]) , csUriQuery )
| extend csUriQuery = iff(csUriQuery startswith ""X-ARR-CACHE-HIT="", strcat(tostring(split(csUriQuery, ""&"")[0]),tostring(split(csUriQuery, ""&"")[1])) , csUriQuery )
| extend scStatusFull = strcat(scStatus, ""."",scSubStatus) 
// Map common IIS codes
| extend scStatusFull_Friendly = case(
scStatusFull == ""401.0"", ""Access denied."",
scStatusFull == ""401.1"", ""Logon failed."",
scStatusFull == ""401.2"", ""Logon failed due to server configuration."",
scStatusFull == ""401.3"", ""Unauthorized due to ACL on resource."",
scStatusFull == ""401.4"", ""Authorization failed by filter."",
scStatusFull == ""401.5"", ""Authorization failed by ISAPI/CGI application."",
scStatusFull == ""403.0"", ""Forbidden."",
scStatusFull == ""403.4"", ""SSL required."",
""See - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0"")
// Mapping to Hex so can be mapped using website in comments above
| extend scWin32Status_Hex = tohex(tolong(scWin32Status)) 
// Map common win32 codes
| extend scWin32Status_Friendly = case(
scWin32Status_Hex =~ ""775"", ""The referenced account is currently locked out and cannot be logged on to."",
scWin32Status_Hex =~ ""52e"", ""Logon failure: Unknown user name or bad password."",
scWin32Status_Hex =~ ""532"", ""Logon failure: The specified account password has expired."",
scWin32Status_Hex =~ ""533"", ""Logon failure: Account currently disabled."", 
scWin32Status_Hex =~ ""2ee2"", ""The request has timed out."", 
scWin32Status_Hex =~ ""0"", ""The operation completed successfully."", 
scWin32Status_Hex =~ ""1"", ""Incorrect function."", 
scWin32Status_Hex =~ ""2"", ""The system cannot find the file specified."", 
scWin32Status_Hex =~ ""3"", ""The system cannot find the path specified."", 
scWin32Status_Hex =~ ""4"", ""The system cannot open the file."", 
scWin32Status_Hex =~ ""5"", ""Access is denied."", 
scWin32Status_Hex =~ ""8009030e"", ""SEC_E_NO_CREDENTIALS"", 
scWin32Status_Hex =~ ""8009030C"", ""SEC_E_LOGON_DENIED"", 
""See - https://msdn.microsoft.com/library/cc231199.aspx"")
// decode URI when available
| extend decodedUriQuery = url_decode(csUriQuery)
// Count of failed logons by a user
| summarize makeset(decodedUriQuery), makeset(cIP), makeset(sSiteName), makeset(sPort), makeset(csUserAgent), makeset(csMethod), makeset(csUriQuery), makeset(scStatusFull), makeset(scStatusFull_Friendly), makeset(scWin32Status_Hex), makeset(scWin32Status_Friendly), FailedConnectionsCount = count() by bin(TimeGenerated, timeBin), csUserName, Computer, sIP
| where FailedConnectionsCount >= failedThreshold
| project TimeGenerated, csUserName, set_decodedUriQuery, Computer, set_sSiteName, sIP, set_cIP, set_sPort, set_csUserAgent, set_csMethod, set_scStatusFull, set_scStatusFull_Friendly, set_scWin32Status_Hex, set_scWin32Status_Friendly, FailedConnectionsCount
| order by FailedConnectionsCount
| extend timestamp = TimeGenerated, AccountCustomEntity = csUserName, HostCustomEntity = Computer"
"b3c5e06e-ee4a-48bb-9e33-8f8ec71ad111","Crypto currency miners EXECVE","true","Hunting","none","Syslog","Syslog","none","none","本规则将识别通过 AUOMS 生成的 EXECVE syslog 数据寻找加密货币矿工的进程实例。 返回所有的的可疑命令行表。具体可参考 - https://techcommunity.microsoft.com/t5/azure-sentinel/hunting-threats-on-linux-with-azure-sentinel/ba-p/1344431","// Extract EventType and EventData from AUOMS Syslog message
Syslog
| parse SyslogMessage with ""type="" EventType "" audit("" * ""): "" EventData
| project TimeGenerated, EventType, Computer, EventData 
// Extract AUOMS_EXECVE details from EventData
| where EventType =~ ""AUOMS_EXECVE""
| parse EventData with * ""syscall="" syscall "" syscall_r="" * "" success="" success "" exit="" exit "" a0"" * "" ppid="" ppid "" pid="" pid "" audit_user="" audit_user "" auid="" auid "" user="" user "" uid="" uid "" group="" group "" gid="" gid ""effective_user="" effective_user "" euid="" euid "" set_user="" set_user "" suid="" suid "" filesystem_user="" filesystem_user "" fsuid="" fsuid "" effective_group="" effective_group "" egid="" egid "" set_group="" set_group "" sgid="" sgid "" filesystem_group="" filesystem_group "" fsgid="" fsgid "" tty="" tty "" ses="" ses "" comm=\"""" comm ""\"" exe=\"""" exe ""\"""" * ""cwd=\"""" cwd ""\"""" * ""name=\"""" name ""\"""" * ""cmdline=\"""" cmdline ""\"" containerid="" containerid
// Find wget and curl commands
| where comm in (""wget"", ""curl"")
// Find command lines featuring known crypto currency miner names
| where cmdline contains ""nicehashminer"" or cmdline contains ""ethminer"" or cmdline contains ""equihash"" or cmdline contains ""NsCpuCNMiner64"" or cmdline contains ""minergate"" or cmdline contains ""minerd"" or cmdline contains ""cpuminer"" or cmdline contains ""xmr-stak-cpu"" or cmdline contains ""xmrig"" or cmdline contains ""stratum+tcp"" or cmdline contains ""cryptonight"" or cmdline contains ""monero"" or cmdline contains ""oceanhole"" or cmdline contains ""dockerminer"" or cmdline contains ""xmrdemo""
| project TimeGenerated, Computer, audit_user, user, cmdline
| extend AccountCustomEntity = user, HostCustomEntity = Computer, timestamp = TimeGenerated
| sort by TimeGenerated desc"
"f774b34a-1b47-42f4-9ad0-2dd71e5db261","Creation of an anomalous number of resources","true","Hunting","none","AzureActivity","AzureActivity","none","none","本规则将在 azure 活动日志中查找异常数量的资源创建或部署活动。缺省查询的回顾期是7天","let timeframe = 7d;
AzureActivity
| where TimeGenerated >= ago(timeframe)
| where OperationName == ""Microsoft.Compute/virtualMachines/write"" or OperationName == ""Microsoft.Resources/deployments/write"" 
| where ActivityStatus == ""Succeeded"" 
| make-series dcount(ResourceId)  default=0 on EventSubmissionTimestamp in range(ago(7d), now(), 1d) by Caller
| extend AccountCustomEntity = Caller
| render timechart"
"d3c1d4a4-d4aa-4b20-a7d4-7f1c934aa3a1","Azure Active Directory Hybrid Health AD FS New Server","true","Detection","Medium","AzureActivity","AzureActivity","1d","1d","此检测使用 AzureActivity 日志（管理类别）来识别 Azure AD 混合运行状况 AD FS 服务中服务器实例的创建或更新。 威胁参与者可以创建新的 AD Health ADFS 服务并创建虚假服务器实例来欺骗 AD FS 签名日志。 无需危及本地 AD FS 服务器。 这可以通过对 Azure 的 HTTP 请求以编程方式完成。 
参考：https://o365blog.com/post/hybridhealthagent","AzureActivity
| where CategoryValue == 'Administrative'
| where ResourceProviderValue =~ 'Microsoft.ADHybridHealthService'
| where _ResourceId contains 'AdFederationService'
| where OperationNameValue =~ 'Microsoft.ADHybridHealthService/services/servicemembers/action'
| extend claimsJson = parse_json(Claims)
| extend AppId = tostring(claimsJson.appid)
| extend AccountName = tostring(claimsJson.name)
| project-away claimsJson
| extend timestamp = TimeGenerated, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress"
"113a6e60-38f6-4242-9240-6aeea3b98c86","Rare subscription-level operations in Azure","true","Detection","Low","AzureActivity","AzureActivity","1d","14d","本规则用于监视 Azure 活动日志中的敏感的订阅级事件。  例如，这会监视用于创建备份但可能被攻击者滥用的操作名称“创建或更新快照” 转储散列或从磁盘中提取敏感信息。","let starttime = 14d;
let endtime = 1d;
// The number of operations below which an IP address is considered an unusual source of role assignment operations
let alertOperationThreshold = 5;
let SensitiveOperationList = dynamic(
[""Microsoft.Storage/storageAccounts/listKeys"", ""Register Subscription"", ""Microsoft.Compute/snapshots/write"", ""Create or Update Network Security Group"",""Microsoft.Network/networkSecurityGroups""]);
let SensitiveActivity = AzureActivity
| where OperationNameValue has_any (SensitiveOperationList)
| where ActivityStatusValue =~ ""Success"";
SensitiveActivity
| where TimeGenerated between (ago(starttime) .. ago(endtime))
| summarize count() by CallerIpAddress, Caller, OperationNameValue
| where count_ >= alertOperationThreshold
| join kind = rightanti ( 
SensitiveActivity
| where TimeGenerated >= ago(endtime)
| extend Resource = tostring(Properties_d.resource), ResourceId = tostring(Properties_d.entity)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ActivityTimeStamp = makelist(TimeGenerated), ActivityStatusValue = makelist(ActivityStatusValue), 
OperationIds = makelist(OperationId), CorrelationIds = makelist(CorrelationId), Resources = makelist(Resource), ResourceGroups = makelist(ResourceGroup), ResourceIds = makelist(ResourceId), ActivityCountByCallerIPAddress = count()  
by CallerIpAddress, Caller, OperationNameValue
) on CallerIpAddress, Caller
| extend timestamp = StartTimeUtc, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress"
"7cbd4bef-e8a2-4f2c-b96d-3d8cd911c490","HAFNIUM New UM Service Child Process","true","Detection","Medium","SecurityEvents","SecurityEvent","1d","14d","此查询查找由 Exchange UM 服务生成的新进程，而该进程以前从未被观察到。 
参考：https://www.microsoft.com/security/blog/2021/03/02/hafnium-targeting-exchange-servers","let lookback = 14d;
let timeframe = 1d;
SecurityEvent
| where TimeGenerated > ago(lookback) and TimeGenerated < ago(timeframe)
| where EventID == 4688
| where ParentProcessName has_any (""umworkerprocess.exe"", ""UMService.exe"")
| join kind=rightanti (
SecurityEvent
| where TimeGenerated > ago(timeframe)
| where ParentProcessName has_any (""umworkerprocess.exe"", ""UMService.exe"")
| where EventID == 4688) on NewProcessName
| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress"
"6254d144-8487-4362-bdad-c1c498efd872","Anomalous sign-in location by user account and authenticating application","true","Detection","Medium","AzureActiveDirectory","SigninLogs","1d","14d","本规则将查询AAD的可疑登录行为，例如同时在多个不同区域出现登录行为","let lookBack_long = 14d;
let lookBack_med = 7d;
let lookBack = 1d;
SigninLogs
| where TimeGenerated >= startofday(ago(lookBack_long))
| extend locationString = strcat(tostring(LocationDetails[""countryOrRegion""]), ""/"", tostring(LocationDetails[""state""]), ""/"", tostring(LocationDetails[""city""]), "";"") 
| project TimeGenerated, AppDisplayName , UserPrincipalName, locationString 
// Create time series 
| make-series dLocationCount = dcount(locationString) on TimeGenerated in range(startofday(ago(lookBack_long)),now(), 1d) 
by UserPrincipalName, AppDisplayName 
// Compute best fit line for each entry 
| extend (RSquare,Slope,Variance,RVariance,Interception,LineFit)=series_fit_line(dLocationCount) 
// Chart the 3 most interesting lines  
// A 0-value slope corresponds to an account being completely stable over time for a given Azure Active Directory application
| where Slope > 0.3
| top 50 by Slope desc
| join kind = leftsemi (
SigninLogs
| where TimeGenerated >= startofday(ago(lookBack_med))
| extend locationString = strcat(tostring(LocationDetails[""countryOrRegion""]), ""/"", tostring(LocationDetails[""state""]), ""/"", tostring(LocationDetails[""city""]), "";"") 
| project TimeGenerated, AppDisplayName , UserPrincipalName, locationString 
| make-series dLocationCount = dcount(locationString) on TimeGenerated in range(startofday(ago(lookBack_med)) ,now(), 1d) 
by UserPrincipalName, AppDisplayName 
| extend (RSquare,Slope,Variance,RVariance,Interception,LineFit)=series_fit_line(dLocationCount) 
| top 50 by Slope desc
| where Slope > 0.3
) on UserPrincipalName, AppDisplayName
| join kind = leftsemi (
SigninLogs
| where TimeGenerated >= startofday(ago(lookBack))
| extend locationString = strcat(tostring(LocationDetails[""countryOrRegion""]), ""/"", tostring(LocationDetails[""state""]), ""/"", tostring(LocationDetails[""city""]), "";"") 
| project TimeGenerated, AppDisplayName , UserPrincipalName, locationString 
| make-series dLocationCount = dcount(locationString) on TimeGenerated in range(startofday(ago(lookBack)) ,now(), 1d) 
by UserPrincipalName, AppDisplayName 
| extend (RSquare,Slope,Variance,RVariance,Interception,LineFit)=series_fit_line(dLocationCount) 
| top 50 by Slope desc
// Higher threshold requirement on last day anomaly
| where Slope > 5
) on UserPrincipalName, AppDisplayName
| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName"
"2bcd4c9e-1a2d-406f-8868-affa733470a7","Login spike with increase failure rate","true","Hunting","none","AzureActiveDirectory","SigninLogs","none","none","This query over SiginLogs will summarise the total number of login attempts for each hour of the day on week days, this can be edited.
The query then uses Kusto anomaly detection to find login spikes for each hour across all days. The query will then calculate the
percentage change between the anomalous period and the average logins for that period. Finally the query will determine the success
and failure rate for logins for the given 1 hour period, if a specified % change in logins is detected alongside a specified failure rate
a result is presented.'
","let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = starttime - 14d;
let failureThreshold = 15;
let percentageChangeThreshold = 50;
SigninLogs
//Collect number of users logging in for each hour
| where TimeGenerated >= lookback
| summarize dcount(UserPrincipalName) by bin(TimeGenerated, 1h)
| extend hour = datetime_part(""Hour"",TimeGenerated)
| extend day = dayofweek(TimeGenerated)
//Exclude Saturday and Sunday as they skew the data, change depending on your weekend days
| where day != 6d and day != 7d
| order by TimeGenerated asc
//Summarise users trying to authenticate by each hour of the day
| summarize make_list(dcount_UserPrincipalName), make_list(TimeGenerated), avg(dcount_UserPrincipalName), make_list(day) by hour
//Find outlier hours where the number of users trying to authenticate spikes, expand and then keep only anomalous rows
| extend series_decompose_anomalies(list_dcount_UserPrincipalName)
| mv-expand list_dcount_UserPrincipalName, series_decompose_anomalies_list_dcount_UserPrincipalName_ad_flag, list_TimeGenerated, list_day
| where series_decompose_anomalies_list_dcount_UserPrincipalName_ad_flag == 1
//Calculate the percentage change between the spike and the average users authenticating
| project TimeGenerated=todatetime(list_TimeGenerated), Hour=hour, WeekDay=list_day, AccountsAuthenticating=list_dcount_UserPrincipalName, AverageAccountsAuthenticatin=round(avg_dcount_UserPrincipalName, 0), PercentageChange = round  ((list_dcount_UserPrincipalName - avg_dcount_UserPrincipalName) / avg_dcount_UserPrincipalName * 100,   2)
| order by PercentageChange desc
//As an additional feature we collect successful and unsuccessful logins during the 1h windows with anomalies
| join kind=inner(
SigninLogs
| where TimeGenerated >= lookback
| where ResultType == ""0""
| summarize Success=dcount(UserPrincipalName), SuccessAccounts=make_set(UserPrincipalName) by bin(TimeGenerated, 1h)
| join kind=inner(
    SigninLogs
    | where TimeGenerated >= lookback
    //Failed sign-ins based on failed username/password combos or failed MFA
    | where ResultType in (""50126"", ""50074"", ""50057"", ""51004"")
    | summarize Failed=dcount(UserPrincipalName), FailedAccounts=make_set(UserPrincipalName) by bin(TimeGenerated, 1h)
) on TimeGenerated
| project-away TimeGenerated1
| extend Total = Failed + Success
| project TimeGenerated, SuccessRate = round((toreal(Success) / toreal(Total)) *100) , round(FailureRate = (toreal(Failed) / toreal(Total)) *100), SuccessAccounts, FailedAccounts
) on TimeGenerated
| order by PercentageChange
| project-away TimeGenerated1
//Thresholds, 15% account authentication failure rate at a 50% increase in accounts attempting to authenticate by default
//Comment out line below to see all anomalous results
| where FailureRate >= failureThreshold and PercentageChange >= percentageChangeThreshold
| extend timestamp = TimeGenerated"
"73a31908-a023-4de5-ac68-7a7ddc5d9bc6","Suspicious Windows Login outside normal hours","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","本规则将识别出正常登录时间之外的可疑交互式登录事件","let v_StartTime = 14d;
let v_EndTime = 2d;
let lookback = 1d;
let AllLogonEvents = materialize(
SecurityEvent
| where TimeGenerated  between (ago(v_StartTime)..ago(v_EndTime))
| where EventID in (4624, 4625)
| where LogonTypeName in~ ('2 - Interactive','10 - RemoteInteractive')
| where AccountType =~ 'User'
| extend HourOfLogin = hourofday(TimeGenerated), DayNumberofWeek = dayofweek(TimeGenerated)
| extend DayofWeek = case(
DayNumberofWeek == ""00:00:00"", ""Sunday"", 
DayNumberofWeek == ""1.00:00:00"", ""Monday"", 
DayNumberofWeek == ""2.00:00:00"", ""Tuesday"", 
DayNumberofWeek == ""3.00:00:00"", ""Wednesday"", 
DayNumberofWeek == ""4.00:00:00"", ""Thursday"", 
DayNumberofWeek == ""5.00:00:00"", ""Friday"", 
DayNumberofWeek == ""6.00:00:00"", ""Saturday"",""InvalidTimeStamp"")
// map the most common ntstatus codes
| extend StatusDesc = case(
Status =~ ""0x80090302"", ""SEC_E_UNSUPPORTED_FUNCTION"",
Status =~ ""0x80090308"", ""SEC_E_INVALID_TOKEN"",
Status =~ ""0x8009030E"", ""SEC_E_NO_CREDENTIALS"",
Status =~ ""0xC0000008"", ""STATUS_INVALID_HANDLE"",
Status =~ ""0xC0000017"", ""STATUS_NO_MEMORY"",
Status =~ ""0xC0000022"", ""STATUS_ACCESS_DENIED"",
Status =~ ""0xC0000034"", ""STATUS_OBJECT_NAME_NOT_FOUND"",
Status =~ ""0xC000005E"", ""STATUS_NO_LOGON_SERVERS"",
Status =~ ""0xC000006A"", ""STATUS_WRONG_PASSWORD"",
Status =~ ""0xC000006D"", ""STATUS_LOGON_FAILURE"",
Status =~ ""0xC000006E"", ""STATUS_ACCOUNT_RESTRICTION"",
Status =~ ""0xC0000073"", ""STATUS_NONE_MAPPED"",
Status =~ ""0xC00000FE"", ""STATUS_NO_SUCH_PACKAGE"",
Status =~ ""0xC000009A"", ""STATUS_INSUFFICIENT_RESOURCES"",
Status =~ ""0xC00000DC"", ""STATUS_INVALID_SERVER_STATE"",
Status =~ ""0xC0000106"", ""STATUS_NAME_TOO_LONG"",
Status =~ ""0xC000010B"", ""STATUS_INVALID_LOGON_TYPE"",
Status =~ ""0xC000015B"", ""STATUS_LOGON_TYPE_NOT_GRANTED"",
Status =~ ""0xC000018B"", ""STATUS_NO_TRUST_SAM_ACCOUNT"",
Status =~ ""0xC0000224"", ""STATUS_PASSWORD_MUST_CHANGE"",
Status =~ ""0xC0000234"", ""STATUS_ACCOUNT_LOCKED_OUT"",
Status =~ ""0xC00002EE"", ""STATUS_UNFINISHED_CONTEXT_DELETED"",
EventID == 4624, ""Success"",
""See - https://docs.microsoft.com/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55""
)
| extend SubStatusDesc = case(
SubStatus =~ ""0x80090325"", ""SEC_E_UNTRUSTED_ROOT"",
SubStatus =~ ""0xC0000008"", ""STATUS_INVALID_HANDLE"",
SubStatus =~ ""0xC0000022"", ""STATUS_ACCESS_DENIED"",
SubStatus =~ ""0xC0000064"", ""STATUS_NO_SUCH_USER"",
SubStatus =~ ""0xC000006A"", ""STATUS_WRONG_PASSWORD"",
SubStatus =~ ""0xC000006D"", ""STATUS_LOGON_FAILURE"",
SubStatus =~ ""0xC000006E"", ""STATUS_ACCOUNT_RESTRICTION"",
SubStatus =~ ""0xC000006F"", ""STATUS_INVALID_LOGON_HOURS"",
SubStatus =~ ""0xC0000070"", ""STATUS_INVALID_WORKSTATION"",
SubStatus =~ ""0xC0000071"", ""STATUS_PASSWORD_EXPIRED"",
SubStatus =~ ""0xC0000072"", ""STATUS_ACCOUNT_DISABLED"",
SubStatus =~ ""0xC0000073"", ""STATUS_NONE_MAPPED"",
SubStatus =~ ""0xC00000DC"", ""STATUS_INVALID_SERVER_STATE"",
SubStatus =~ ""0xC0000133"", ""STATUS_TIME_DIFFERENCE_AT_DC"",
SubStatus =~ ""0xC000018D"", ""STATUS_TRUSTED_RELATIONSHIP_FAILURE"",
SubStatus =~ ""0xC0000193"", ""STATUS_ACCOUNT_EXPIRED"",
SubStatus =~ ""0xC0000380"", ""STATUS_SMARTCARD_WRONG_PIN"",
SubStatus =~ ""0xC0000381"", ""STATUS_SMARTCARD_CARD_BLOCKED"",
SubStatus =~ ""0xC0000382"", ""STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED"",
SubStatus =~ ""0xC0000383"", ""STATUS_SMARTCARD_NO_CARD"",
SubStatus =~ ""0xC0000384"", ""STATUS_SMARTCARD_NO_KEY_CONTAINER"",
SubStatus =~ ""0xC0000385"", ""STATUS_SMARTCARD_NO_CERTIFICATE"",
SubStatus =~ ""0xC0000386"", ""STATUS_SMARTCARD_NO_KEYSET"",
SubStatus =~ ""0xC0000387"", ""STATUS_SMARTCARD_IO_ERROR"",
SubStatus =~ ""0xC0000388"", ""STATUS_DOWNGRADE_DETECTED"",
SubStatus =~ ""0xC0000389"", ""STATUS_SMARTCARD_CERT_REVOKED"",
EventID == 4624, ""Success"",
""See - https://docs.microsoft.com/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55""
)
| project StartTime = TimeGenerated, DayofWeek, HourOfLogin, EventID, Activity, IpAddress, WorkstationName, Computer, TargetUserName, TargetDomainName, ProcessName, SubjectUserName, PrivilegeList, LogonTypeName, StatusDesc, SubStatusDesc
);
AllLogonEvents
| where TargetDomainName !in (""Window Manager"",""Font Driver Host"")
| summarize max(HourOfLogin), min(HourOfLogin), historical_DayofWeek=make_set(DayofWeek) by TargetUserName
| join kind= inner
(
    AllLogonEvents
    | where StartTime > ago(lookback)
)
on TargetUserName
// Filtering for logon events based on range of max and min of historical logon hour values seen
| where HourOfLogin > max_HourOfLogin or HourOfLogin < min_HourOfLogin
// Also populating additional column showing historical days of week when logon was seen
| extend historical_DayofWeek = tostring(historical_DayofWeek)
| summarize Total= count(), max(HourOfLogin), min(HourOfLogin), current_DayofWeek =make_set(DayofWeek), StartTime=max(StartTime), EndTime = min(StartTime), SourceIP = make_set(IpAddress), SourceHost = make_set(WorkstationName), SubjectUserName = make_set(SubjectUserName), HostLoggedOn = make_set(Computer) by EventID, Activity, TargetDomainName, TargetUserName , ProcessName , LogonTypeName, StatusDesc, SubStatusDesc, historical_DayofWeek
| extend historical_DayofWeek = todynamic(historical_DayofWeek) 
| extend timestamp = StartTime, AccountCustomEntity = TargetUserName"
"233df8c2-cd60-4fb5-8b96-10156f5c96d8","Privleged Role Assigned Outside PIM","true","Detection","Low","AzureActiveDirectory","AuditLogs","1d","1d","标识分配给 PIM 之外的用户的特权角色。 参考：https://docs.microsoft.comazure/active-directory/fundamentals/security-operations-privileged-accounts#things-to-monitor-1","AuditLogs
| where Category =~ ""RoleManagement""
| where ActivityDisplayName =~ 'Add member to role (permanent)'
| extend AccountCustomEntity = tostring(TargetResources[0].userPrincipalName), IPCustomEntity = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)"
"ddf46f16-a0db-45f0-9194-e3961ead47c9","Web Shell Activity","true","Hunting","none","AzureMonitor(IIS)","W3CIISLog","none","none","Web shells are scripts that, when uploaded to a web server, can be used to provide a backdoor to a compromised network.
Attackers can use this entry point to leave malicious implants, such as obtaining unauthorized access, escalating privilege, and further compromising the environment.

This query hunts for web shells by analysing the distribution of commonly-used web shell scripts against regular scripts for those public client IPs which have not observed any W3CIIS activity in a fixed lookback period.
The results obtained summarise the public client IPs, user agents, and the distribution of the above scripts between the start and end time.'
","let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = starttime - (3d);
let script_extensions = dynamic(["".asp"", "".aspx"", "".armx"", "".asax"", "".ashz"", "".asmx"", "".axd"", "".cshtml"", "".php"", "".phps"", "".php3"", "".php4"", "".php5"", "".php7"", "".jsp"", "".jspx"", "".cfm"", "".cfml"", "".phtml""]);
let ignore_uristems = dynamic([""/ews/exchange.asmx""]);
let lookback_period = (
W3CIISLog
| where TimeGenerated between (lookback .. starttime)
| where not(ipv4_is_private(cIP)) and cIP != ""127.0.0.1""
| summarize count() by cIP, csUserAgent
| project cIP, csUserAgent
);
let potential_webshell_activity = (W3CIISLog
| where TimeGenerated between (starttime .. endtime)
| extend csUriStem = tolower(csUriStem)
| where csUriStem matches regex ""\\.[a-zA-Z][a-zA-Z0-9]+$""
| where csUriStem !in~ (ignore_uristems) // Remove noisy uri stems in the final results by editing the ignore_uristems variable
| extend suffix = strcat(""."", split(split(csUriStem, ""/"")[-1], ""."")[-1])
| extend is_script = iff(suffix in (script_extensions), 1, 0)
| where not(ipv4_is_private(cIP)) and cIP != ""127.0.0.1""
| extend status_xx = strcat(substring(tostring(scStatus), 0, 1), 'XX')
| serialize cIP, csUserAgent, TimeGenerated
| extend SessionStarted = row_window_session(TimeGenerated, 30s, 3s, (cIP != prev(cIP)) and (csUserAgent != prev(csUserAgent))));
let dynamic_scripts = (potential_webshell_activity
| where is_script == 1
| summarize set_dynamic_scripts = make_set(csUriStem) by cIP, csUserAgent, SessionStarted);
let non_dynamic_scripts = (potential_webshell_activity
| where is_script == 0
| summarize set_non_dynamic_scripts = make_set(csUriStem) by cIP, csUserAgent, SessionStarted);
potential_webshell_activity
| summarize num_non_dyn_scripts = count() - sum(is_script), num_dynamic_scripts = sum(is_script) by cIP, csUserAgent, SessionStarted
| join kind=leftanti (lookback_period) on cIP, csUserAgent
| join kind=inner (dynamic_scripts) on cIP, csUserAgent, SessionStarted
| join kind=leftouter (non_dynamic_scripts) on cIP, csUserAgent, SessionStarted
| extend dyn_to_non_dyn_ratio = iff(num_non_dyn_scripts == 0, 10000.0, 1.0 * num_dynamic_scripts/num_non_dyn_scripts)
| project cIP, csUserAgent, SessionStarted,  num_dynamic_scripts, set_dynamic_scripts, num_non_dyn_scripts, set_non_dynamic_scripts,  dyn_to_non_dyn_ratio
| sort by dyn_to_non_dyn_ratio desc, num_dynamic_scripts desc
| extend summary = pack('IPCustomEntity', cIP, 'user_agent', csUserAgent, 'num_dynamic_scripts', num_dynamic_scripts, 'set_dynamic_scripts', set_dynamic_scripts, 'num_non_dyn_scripts', num_non_dyn_scripts, 'set_non_dynamic_scripts', set_non_dynamic_scripts, 'ratio', dyn_to_non_dyn_ratio, 'Session_StartTime', SessionStarted)
| summarize summaries=make_list(summary), num_of_sessions_on_day = count() by cIP, csUserAgent
| sort by num_of_sessions_on_day asc"
"021d778b-a97e-4956-91fb-ea19760e2616","Password spray attack against Azure AD application","true","Detection","Medium","AzureActiveDirectory","SigninLogs","1d","7d","本规则将识别针对 Azure AD 应用程序的密码喷射攻击的 IP 地址。规则使用的默认失败帐户阈值是 5，默认失败时间窗口是 20分钟，默认回顾窗口是 3 天","let timeframe = 3d;
let lookBack = 7d;
let authenticationWindow = 20m;
let authenticationThreshold = 5;
let isGUID = ""[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}"";
let failureCodes = dynamic([50053, 50126, 50055]); // invalid password, account is locked - too many sign ins, expired password
let successCodes = dynamic([0, 50055, 50057, 50155, 50105, 50133, 50005, 50076, 50079, 50173, 50158, 50072, 50074, 53003, 53000, 53001, 50129]);
// Lookup up resolved identities from last 7 days
let identityLookup = SigninLogs
| where TimeGenerated >= ago(lookBack)
| where not(Identity matches regex isGUID)
| where isnotempty(UserId)
| summarize by UserId, lu_UserDisplayName = UserDisplayName, lu_UserPrincipalName = UserPrincipalName;
// collect window threshold breaches
SigninLogs
| where TimeGenerated > ago(timeframe)
| where ResultType in(failureCodes)
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), make_set(ClientAppUsed), count() by bin(TimeGenerated, authenticationWindow), IPAddress, AppDisplayName, UserPrincipalName
| summarize FailedPrincipalCount = dcount(UserPrincipalName) by bin(TimeGenerated, authenticationWindow), IPAddress, AppDisplayName
| where FailedPrincipalCount >= authenticationThreshold
| summarize WindowThresholdBreaches = count() by IPAddress
| join kind= inner (
// where we breached a threshold, join the details back on all failure data
 SigninLogs
| where TimeGenerated > ago(timeframe)
| where ResultType in(failureCodes)
| extend FullLocation = strcat(Location,'|', LocationDetails.state, '|', LocationDetails.city)
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), make_set(ClientAppUsed), make_set(FullLocation), FailureCount = count() by IPAddress, AppDisplayName, UserPrincipalName, UserDisplayName, Identity, UserId
// lookup any unresolved identities
| extend UnresolvedUserId = iff(Identity matches regex isGUID, UserId, """")
| join kind= leftouter (
 identityLookup 
) on $left.UnresolvedUserId==$right.UserId
| extend UserDisplayName=iff(isempty(lu_UserDisplayName), UserDisplayName, lu_UserDisplayName)
| extend UserPrincipalName=iff(isempty(lu_UserPrincipalName), UserPrincipalName, lu_UserPrincipalName)
| summarize StartTime = min(StartTime), EndTime = max(EndTime), make_set(UserPrincipalName), make_set(UserDisplayName), make_set(set_ClientAppUsed), make_set(set_FullLocation), make_list(FailureCount) by IPAddress, AppDisplayName
| extend FailedPrincipalCount = arraylength(set_UserPrincipalName)
) on IPAddress
| project IPAddress, StartTime, EndTime, TargetedApplication=AppDisplayName, FailedPrincipalCount, UserPrincipalNames=set_UserPrincipalName, UserDisplayNames=set_UserDisplayName, ClientAppsUsed=set_set_ClientAppUsed, Locations=set_set_FullLocation, FailureCountByPrincipal=list_FailureCount, WindowThresholdBreaches
| join kind= inner (
SigninLogs // get data on success vs. failure history for each IP
| where TimeGenerated > ago(timeframe)
| where ResultType in(successCodes) or ResultType in(failureCodes) // success or failure types
| summarize GlobalSuccessPrincipalCount = dcountif(UserPrincipalName, (ResultType in(successCodes))), ResultTypeSuccesses = make_set_if(ResultType, (ResultType in(successCodes))), GlobalFailPrincipalCount = dcountif(UserPrincipalName, (ResultType in(failureCodes))), ResultTypeFailures = make_set_if(ResultType, (ResultType in(failureCodes))) by IPAddress
| where GlobalFailPrincipalCount > GlobalSuccessPrincipalCount // where the number of failed principals is greater than success - eliminates FPs from IPs who authenticate successfully alot and as a side effect have alot of failures
) on IPAddress
| project-away IPAddress1
| extend timestamp=StartTime, IPCustomEntity = IPAddress"
"6b5455c3-cbfd-418a-bd05-8d114c670995","Suspicious granting of permissions to an account","true","Detection","Medium","AzureActivity","AzureActivity","1d","14d","本规则会标记所有用户授予其他用户访问 azure 资源的 IP。当出现新的 IP 地址时发出警报","let starttime = 14d;
let endtime = 1d;
let roleassingmentactions = dynamic([""Microsoft.Authorization/classicadministrators/write"",""Microsoft.Authorization/roleAssignments/write""]);
// The number of operations below which an IP address is considered an unusual source of role assignment operations
let alertOperationThreshold = 5;
let createRoleAssignmentActivity = AzureActivity
| where OperationNameValue in~ (roleassingmentactions);
createRoleAssignmentActivity
| where TimeGenerated between (ago(starttime) .. ago(endtime))
| summarize count() by CallerIpAddress, Caller
| where count_ >= alertOperationThreshold
| join kind = rightanti ( 
createRoleAssignmentActivity
| where TimeGenerated > ago(endtime)
| extend Resource = tostring(Properties_d.resource), ResourceId = tostring(Properties_d.entity)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ActivityTimeStamp = makelist(TimeGenerated), ActivityStatus = makelist(ActivityStatus), 
OperationIds = makelist(OperationId), CorrelationId = makelist(CorrelationId), ActivityCountByCallerIPAddress = count()  
by ResourceId, CallerIpAddress, Caller, OperationName, Resource, ResourceGroup
) on CallerIpAddress, Caller
| extend timestamp = StartTimeUtc, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress"
"64d6c897-55a1-4bdb-9cba-0b53f1f39657","Login attempts using Legacy Auth","true","Hunting","none","AzureActiveDirectory","SigninLogs","none","none","本规则将返回所有使用传统身份验证的AAD登录日志。 因为在使用传统身份验证时不评估条件访问策略，旧身份验证可用于规避所有 Azure 条件访问策略","let endtime = 1d;
let starttime = 7d;
let legacyAuthentications =
SigninLogs
| where TimeGenerated >= ago(starttime)
// success logons only
| where ResultType == 0
| extend ClientAppUsed = iff(isempty(ClientAppUsed)==true,""Unknown"" ,ClientAppUsed)
| extend isLegacyAuth = case(
ClientAppUsed contains ""Browser"", ""No"", 
ClientAppUsed contains ""Mobile Apps and Desktop clients"", ""No"", 
ClientAppUsed contains ""Exchange ActiveSync"", ""No"", 
ClientAppUsed contains ""Other clients"", ""Yes"", 
""Unknown"")
| where isLegacyAuth==""Yes"";
legacyAuthentications 
| where TimeGenerated >= ago(endtime)
// Don't alert for accounts already seen using legacy auth in prior 7 days
| join kind=leftanti (
   legacyAuthentications 
   | where TimeGenerated between(ago(starttime) .. ago(endtime))
) on UserPrincipalName, ClientAppUsed, AppDisplayName, IPAddress
| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser
| extend LocationString= strcat(tostring(LocationDetails[""countryOrRegion""]), ""/"", 
tostring(LocationDetails[""state""]), ""/"", tostring(LocationDetails[""city""]))
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), AttemptCount = count() 
by UserPrincipalName, ClientAppUsed, AppDisplayName, IPAddress, isLegacyAuth, tostring(OS), tostring(Browser), LocationString
| sort by AttemptCount desc nulls last 
| extend timestamp = StartTimeUtc, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress"
"2a979ec4-9563-4834-a7a5-bea409d3599f","Least Common Processes Including Folder Depth","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","本规则将识别Windows 安全日志中找到的最不常见的进程命令行","let Allowlist = dynamic (['foo.exe', 'baz.exe']);
let Sensitivity = 15;
let StartDate = ago(7d);
let Duration = 7d;
SecurityEvent
| where EventID == 4688 and TimeGenerated > StartDate and TimeGenerated < (StartDate + Duration)
| extend ProcArray = split(NewProcessName, '\\')
// ProcArrayLength is Folder Depth
| extend ProcArrayLength = arraylength(ProcArray)
| extend LastIndex = ProcArrayLength - 1
| extend Proc = ProcArray[LastIndex]
| where Proc !in (Allowlist)
// ProcArray[0] is the proc's Drive
| extend DriveDepthProc = strcat(ProcArray[0], '-', ProcArrayLength, '-', Proc)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), TimesSeen = count(), HostCount = dcount(Computer), Hosts = makeset(Computer), UserCount = dcount(SubjectUserName), Users = makeset(SubjectUserName) by DriveDepthProc
| where TimesSeen < Sensitivity
| extend timestamp = StartTimeUtc"
"b2d38c95-0352-4d71-890b-5e2ac64a45f1","Dormant User Update MFA and Logs In","true","Hunting","none","AzureActiveDirectory","MultipleDataSources","none","none","This querys look for users accounts that have not been successfully logged into recently, who then have a MFA method added or updated before logging in.
Threat actors may look to re-activate dormant accounts and use them for access by adding MFA methods in the hope that changes to such dormant accounts may go un-noticed.'
","let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = endtime - 14d;
let active_users = (
    SigninLogs
    | where TimeGenerated between(lookback..starttime)
    | where ResultType == 0
    | extend UserPrincipalName == tolower(UserPrincipalName)
    | summarize by UserId);
AuditLogs
| where TimeGenerated between(starttime..endtime)
// Get users where they added MFA
| where OperationName =~ ""User registered security info""
| extend TargetUser = tolower(tostring(TargetResources[0].userPrincipalName))
| extend UserId = tostring(TargetResources[0].id)
// Check and see if this activity was from a user who is considered not active
| where UserId !in (active_users)
// Further reduce FP by just looking at users who have successfully logged in recently as well (avoiding hits for users adding MFA but not actually logging in)
| join kind=inner (SigninLogs | where TimeGenerated  between(starttime..endtime) | where ResultType == 0 | summarize max(TimeGenerated), make_set(IPAddress), make_set(UserAgent), make_set(LocationDetails) by UserPrincipalName, UserId
) on UserId
| extend LogonLocation = set_LocationDetails[0], LogonUserAgent = set_UserAgent[0], LogonIP = set_IPAddress[0]
| project-rename MostRecentLogon = max_TimeGenerated
| project-reorder TimeGenerated, TargetUser, OperationName, ResultDescription, MostRecentLogon, LogonUserAgent, LogonLocation, LogonIP
| extend AccountCustomEntity = TargetUser, IPCustomEntity = LogonIP"
"215d92a9-0473-4e06-8124-5a3dffce89b4","Attempts to sign in to disabled accounts","true","Detection","Medium","AzureActiveDirectory","SigninLogs","1d","1d","本规则检查AAD 登录失败日志： 50057 - 用户帐户被禁用，该帐户已被管理员禁用。出现连续3次尝试将报警","let timeframe = 1d;
let threshold = 3;
SigninLogs
| where TimeGenerated >= ago(timeframe)
| where ResultType == ""50057""
| where ResultDescription contains ""User account is disabled""
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count(), applicationCount = dcount(AppDisplayName), 
applicationSet = makeset(AppDisplayName) by UserPrincipalName, IPAddress
| where applicationCount >= threshold
| extend timestamp = StartTimeUtc, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress"
"a4064d34-d87c-4a2d-bb9d-552649f2683e","Common deployed resources","true","Hunting","none","AzureActivity","AzureActivity","none","none","本规则将查询查找常见的部署资源（资源名称和资源组）。 通常用于结合其他显示可疑部署的信号来评估资源部署是否是正常的","let timeframe = 7d;
AzureActivity
| where TimeGenerated >= ago(timeframe)
| where OperationNameValue =~ ""Microsoft.Compute/virtualMachines/write"" or OperationName =~ ""Microsoft.Resources/deployments/write"" 
| where ActivityStatusValue =~ ""Success""
| project Resource = Properties_d.resource, ResourceGroup
| evaluate basket()"
"378857c1-e5a3-4d8a-9a3e-73d898be2b53","Several deny actions registered","true","Detection","Medium","AzureFirewall","AzureFirewall","1h","1h","当攻击者尝试在网络上的资源之间移动或扫描时识别攻击模式，并在源在 Azure 防火墙中注册的拒绝操作超过 1 个时创建事件。","let threshold = 1;
AzureDiagnostics
    | where OperationName in (""AzureFirewallApplicationRuleLog"",""AzureFirewallNetworkRuleLog"")
    | extend msg_s_replaced0 = replace(@""\s\s"",@"" "",msg_s)
    | extend msg_s_replaced1 = replace(@""\.\s"",@"" "",msg_s_replaced0)
    | extend msg_a = split(msg_s_replaced1,"" "")
    | extend srcAddr_a = split(msg_a[3],"":"") , destAddr_a = split(msg_a[5],"":"")
    | extend protocol = tostring(msg_a[0]), srcIp = tostring(srcAddr_a[0]), srcPort = tostring(srcAddr_a[1]), destIp = tostring(destAddr_a[0]), destPort = tostring(destAddr_a[1]), action = tostring(msg_a[7])
    | where action == ""Deny""
    | extend url = iff(destIp matches regex ""\\d+\\.\\d+\\.\\d+\\.\\d+"","""",destIp)
    | summarize StartTime = min(TimeGenerated), count() by srcIp, destIp, url, action, protocol
    | where count_ >= [""threshold""]
    | extend timestamp = StartTime, URLCustomEntity = url, IPCustomEntity = srcIp"
"3ec73349-fc32-43ed-946b-070be3160f24","Failed Login Attempt by Expired account","true","Hunting","none","AzureActiveDirectory","MultipleDataSources","none","none","本规则将识别所有已过期帐户的登录尝试","let timeframe = 1d;
(union isfuzzy=true
(SecurityEvent
| where TimeGenerated >= ago(timeframe) 
| where EventID == 4625
//4625: An account failed to log on
| where AccountType == 'User' 
| where SubStatus == '0xc0000193' 
| extend Reason = 
case
( SubStatus == '0xc0000193', 'Windows EventID (4625) - Account has expired', ""Unknown"")
| project Computer, Account,  Reason , TimeGenerated
),
(
SecurityEvent
| where TimeGenerated >= ago(timeframe) 
| where EventID == 4769
//4769: A Kerberos service ticket was requested ( Kerberos Auth)
| parse EventData with * 'Status"">' Status ""<"" *
| parse EventData with * 'TargetUserName"">' TargetUserName ""<"" *
| where Status == '0x12'
| where TargetUserName !has ""$"" and isnotempty(TargetUserName)
| extend Reason = 
case(
Status == '0x12', 'Windows EventID (4769) - Account disabled, expired, locked out',
'Unknown'), Account = TargetUserName 
| project Computer, Account, Reason , TimeGenerated
),
(
SecurityEvent
| where TimeGenerated >= ago(timeframe) 
| where EventID == 4776 
// 4776: The domain controller attempted to validate the credentials for an account ( NTLM Auth)
| where Status == ""0xc0000193""
| extend Reason = 
case(
ErrorCode == '0xc0000193', 'Windows EventID (4776) - Account has expired',
'Unknown'), Account = TargetAccount 
| parse EventData with * 'Workstation"">' Workstation ""<"" *
| extend Workstation = trim_start(@""[\\]*"", Workstation)
| extend Computer = iff(isnotempty(Workstation), Workstation, Computer ) 
| project Computer, Account, Reason , TimeGenerated
) ,
(
SigninLogs
| where TimeGenerated >= ago(timeframe) 
| where ResultType == ""50057"" 
| extend Reason = 
case(
ResultType == '50057', 'SigninLogs( Result Code- 50057) - User account is disabled. The account has been disabled by an administrator.',
'Unknown'), Account = UserPrincipalName 
| project Computer, Account, Reason , TimeGenerated
) )
| summarize StartTimeUtc = min(TimeGenerated), EndTImeUtc = max(TimeGenerated), EventCount = count() by Computer, Account, Reason
| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = Computer
| order by EventCount desc"
"cde33084-4d44-4942-8660-5d24a99d64e9","Potential IIS brute force","true","Hunting","none","AzureMonitor(IIS)","W3CIISLog","none","none","This query shows when 1200 (20 per minute) or more failed attempts by cIP per hour occur on a given server and then a successful logon by cIP. 
This only includes when more than 1 user agent strings is used or more than 1 port is used.
This could be indicative of successful probing and password brute force success on your IIS servers. 
Feel free to adjust the threshold as needed - ConnectionCount >= 1200 
References: Status code mappings for your convenience, also inline if the mapping is not available
IIS status code mapping - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0
Win32 Status code mapping - https://msdn.microsoft.com/library/cc231199.aspx","let timeframe = ago(1h);
W3CIISLog
| where TimeGenerated >= timeframe
| where scStatus in (""401"",""403"")
| where cIP !startswith ""192.168."" and cIP != sIP and cIP != ""::1"" //and csUserName != ""-"" 
// Handling Exchange specific items in IIS logs to remove the unique log identifier in the URI
| extend csUriQuery = iff(csUriQuery startswith ""MailboxId="", tostring(split(csUriQuery, ""&"")[0]) , csUriQuery )
| extend csUriQuery = iff(csUriQuery startswith ""X-ARR-CACHE-HIT="", strcat(tostring(split(csUriQuery, ""&"")[0]),tostring(split(csUriQuery, ""&"")[1])) , csUriQuery )
| summarize FailStartTimeUtc = min(TimeGenerated), FailEndTimeUtc = max(TimeGenerated), makeset(sPort), makeset(csUserAgent), makeset(csUserName), csUserNameCount = dcount(csUserName), ConnectionCount = count() by Computer, sSiteName, sIP, cIP, csUriQuery, csMethod, scStatus, scSubStatus, scWin32Status
| extend csUserAgentPerIPCount = arraylength(set_csUserAgent)
| extend sPortCount = arraylength(set_sPort)
| extend scStatusFull = strcat(scStatus, ""."",scSubStatus) 
// Map common IIS codes
| extend scStatusFull_Friendly = case(
scStatusFull == ""401.0"", ""Access denied."",
scStatusFull == ""401.1"", ""Logon failed."",
scStatusFull == ""401.2"", ""Logon failed due to server configuration."",
scStatusFull == ""401.3"", ""Unauthorized due to ACL on resource."",
scStatusFull == ""401.4"", ""Authorization failed by filter."",
scStatusFull == ""401.5"", ""Authorization failed by ISAPI/CGI application."",
scStatusFull == ""403.0"", ""Forbidden."",
scStatusFull == ""403.4"", ""SSL required."",
""See - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0"")
// Mapping to Hex so can be mapped using website in comments above
| extend scWin32Status_Hex = tohex(tolong(scWin32Status)) 
// Map common win32 codes
| extend scWin32Status_Friendly = case(
scWin32Status_Hex =~ ""52e"", ""Logon failure: Unknown user name or bad password."", 
scWin32Status_Hex =~ ""533"", ""Logon failure: Account currently disabled."", 
scWin32Status_Hex =~ ""2ee2"", ""The request has timed out."", 
scWin32Status_Hex =~ ""0"", ""The operation completed successfully."", 
scWin32Status_Hex =~ ""1"", ""Incorrect function."", 
scWin32Status_Hex =~ ""2"", ""The system cannot find the file specified."", 
scWin32Status_Hex =~ ""3"", ""The system cannot find the path specified."", 
scWin32Status_Hex =~ ""4"", ""The system cannot open the file."", 
scWin32Status_Hex =~ ""5"", ""Access is denied."", 
scWin32Status_Hex =~ ""8009030e"", ""SEC_E_NO_CREDENTIALS"", 
scWin32Status_Hex =~ ""8009030C"", ""SEC_E_LOGON_DENIED"", 
""See - https://msdn.microsoft.com/library/cc231199.aspx"")
// decode URI when available
| extend decodedUriQuery = url_decode(csUriQuery)
| where (ConnectionCount >= 1200 and csUserAgentPerIPCount > 1) or (ConnectionCount >= 1200 and sPortCount > 1)
// now join back to see if there is a successful logon after so many failures
| join (
W3CIISLog
| where TimeGenerated >= timeframe
| where scStatus startswith ""20""
| where cIP !startswith ""192.168."" and cIP != sIP and cIP != ""::1""
| extend LogonSuccessTimeUtc = TimeGenerated, Success_scStatus = scStatus
| distinct LogonSuccessTimeUtc, Computer, sSiteName, sIP, cIP, Success_scStatus
) on Computer, sSiteName, sIP, cIP
| where FailEndTimeUtc < LogonSuccessTimeUtc and not(LogonSuccessTimeUtc between (FailStartTimeUtc .. FailEndTimeUtc))
| summarize makeset(LogonSuccessTimeUtc) by FailStartTimeUtc, FailEndTimeUtc, Computer, sSiteName, sIP, cIP, tostring(set_csUserName), csUserNameCount, csUriQuery, csMethod, scStatus, scSubStatus, scWin32Status, tostring(set_sPort), tostring(set_csUserAgent), ConnectionCount, csUserAgentPerIPCount, sPortCount, scStatusFull, scStatusFull_Friendly, scWin32Status_Hex, scWin32Status_Friendly
| project FailStartTimeUtc, FailEndTimeUtc, set_LogonSuccessTimeUtc, Computer, sSiteName, sIP, cIP, set_csUserName, csUserNameCount, csUriQuery, csMethod, scStatus, scSubStatus, scWin32Status, set_sPort, set_csUserAgent, ConnectionCount, csUserAgentPerIPCount, sPortCount, scStatusFull, scStatusFull_Friendly, scWin32Status_Hex, scWin32Status_Friendly
| extend timestamp = FailStartTimeUtc, IPCustomEntity = cIP, HostCustomEntity = Computer"
"570a0e53-54b9-4563-bfa3-a73a152b2202","OAuth Application Required Resource Access Update","true","Hunting","none","AzureActiveDirectory","AuditLogs","none","none","This hunting query identifies updates to the RequiredResourceAccess property of an OAuth application.
This property specifies resources that an application requires access to and the set of OAuth permission scopes and application roles that it needs under each of those resources.
This pre-configuration of required resource access drives the consent experience. The resourceAccess property of the requiredResourceAccess type is a collection of ResourceAccess.
A threat actor might update this property before granting permissions to an application.
'
","AuditLogs
| where Category =~ ""ApplicationManagement""
| where ActivityDisplayName has_any (""Update application"")
| where Result =~ ""success""
| where tostring(InitiatedBy.user.userPrincipalName) has ""@"" or tostring(InitiatedBy.app.displayName) has ""@""
| extend UserAgent = tostring(AdditionalDetails[0].value)
| extend InitiatingUser = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| extend InitiatingIpAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)
| extend ModifiedApplication = tostring(TargetResources[0].displayName)
| extend ModifiedApplicationObjectId = tostring(TargetResources[0].id)
| extend ModifiedProperties = parse_json(tostring(TargetResources[0].modifiedProperties))
| extend ModifiedPropertyName = tostring(ModifiedProperties[0].displayName)
| extend ResourceAppId = parse_json(tostring(ModifiedProperties[0].newValue))[0].ResourceAppId
| where ModifiedPropertyName =~ ""RequiredResourceAccess""
| extend Type = tostring(TargetResources[0].type)
| project-away ModifiedProperties
| project-reorder TimeGenerated, OperationName, InitiatingUser, InitiatingIpAddress, UserAgent, ModifiedApplication, ModifiedApplicationObjectId, CorrelationId, TenantId
| extend timestamp = TimeGenerated, AccountCustomEntity = InitiatingUser, IPCustomEntity = InitiatingIpAddress"
"b162f44c-30ef-4c54-86af-252d0d67c7c8","Masquerading files","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","本规则将识别出进程名为常见Windows服务（例如svchost), 但执行账号可疑的进程","let timeframe = 1d;
SecurityEvent
| where TimeGenerated >= ago(timeframe)
| where NewProcessName endswith ""\\svchost.exe""
| where SubjectUserSid !in (""S-1-5-18"", ""S-1-5-19"", ""S-1-5-20"")
| where NewProcessName !contains "":\\Windows\\System32""
| where NewProcessName !contains "":\\Windows\\Syswow64""
| summarize minTimeGenerated=min(TimeGenerated), maxTimeGenerated=max(TimeGenerated), count() by Computer, SubjectUserName, NewProcessName, CommandLine, Account
| project minTimeGenerated , maxTimeGenerated , count_ , Computer , SubjectUserName , NewProcessName , CommandLine, Account 
| extend timestamp = minTimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account"
"33b2c562-82c2-4cfa-a8fb-2892ec46237b","Azure Sentinel Connectors Administrative Operations","true","Hunting","none","AzureActivity","AzureActivity","none","none","Identifies set of Azure Sentinel Data Connectors administrative operational detection queries for hunting activites'
","let opValues = dynamic([""Microsoft.SecurityInsights/dataConnectors/write"", ""Microsoft.SecurityInsights/dataConnectors/delete""]);
// Azure Sentinel Data Connectors Update / Delete
AzureActivity
| where OperationNameValue in (opValues)
| where ActivitySubstatusValue in (""Created"", ""OK"")
| sort by TimeGenerated desc
| extend timestamp = TimeGenerated, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress"
"330af700-c3d1-4eef-af51-38ee848ef720","Azure Resources assigned Public IP Addresses","true","Hunting","none","AzureActivity","MultipleDataSources","none","none","本规则将标识何时将公共 IP 地址分配给 Azure 资源","let timeframe = 7d;
AzureActivity
| where TimeGenerated >= ago(timeframe)
// We look for any Operation that modified and then was accepted or succeeded where a publicipaddress component is referenced
| where OperationName has_any (""write"", ""Update"", ""Delete"")// Virtual Machine"" or OperationName == ""Create Deployment"" 
| where ActivityStatus has_any (""Succeeded"", ""Accepted"")
| where Properties contains ""publicipaddress""
//| extend frontendIPConfigurations = Properties.responseBody.properties.frontendIPConfigurations
// parsing the publicIPAddress from Properties. It is only available if the allocation method is Static.
| parse Properties with * ""publicIPAddress\\"" PublicIPAddressParse
| extend publicIPAddress_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).ipAddress) 
| extend publicIPAddressVersion_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAddressVersion) 
| extend publicIPAllocationMethod_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAllocationMethod) 
| extend scope_ = tostring(parse_json(Authorization).scope) 
| project TimeGenerated, OperationName, publicIPAllocationMethod_ , publicIPAddressVersion_, scope_ , Caller, CallerIpAddress, ActivityStatus, Resource 
// Join in the AzureNetworkAnalytics so that we can determine if any connections were made via the public ip address and get the currently assigned ip address when allocation method is Dynamic
| join kind= inner (
union isfuzzy=true
(AzureNetworkAnalytics_CL
| where TimeGenerated >= ago(timeframe) 
// Controlling for Schema Version and later parsing - This is Version 2 and Public IPs only
| where isnotempty(FASchemaVersion_s) and isnotempty(DestPublicIPs_s)
| extend SchemaVersion = FASchemaVersion_s
| extend PublicIPs = tostring(split(DestPublicIPs_s,""|"")[0])
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), FirstProcessedTimeUTC = min(FlowStartTime_t), LastProcessedTimeUtc = max(FlowEndTime_t), 
Regions = makeset(Region_s), AzureRegions = makeset(AzureRegion_s), VMs = makeset(VM_s), MACAddresses = makeset(MACAddress_s), PublicIPs = makeset(PublicIPs), DestPort = makeset(DestPort_d), SrcIP = makeset(SrcIP_s), 
ActivityCount = count() by NSGRule_s, NSGList_s, SubNet = Subnet1_s, FlowDirection_s, Subscription = Subscription1_g, SchemaVersion
//NSGList_s contains the subscription ID, remove that as we already have a field for this and now it will match what we get for SchemaVersion 1
| extend NSG = case(isnotempty(NSGList_s), strcat(split(NSGList_s, ""/"")[-2],""/"",split(NSGList_s, ""/"")[-1]), ""NotAvailable"")
// Depending on the SchemaVersion, we will need to provide the NSG_Name for matching against the resource identified in AzureActivity
| extend NSG_Name = tostring(split(NSG, ""/"")[-1])
),
(
AzureNetworkAnalytics_CL
| where TimeGenerated >= ago(timeframe) 
// Controlling for Schema Version and later parsing - This is Version 1
| where isempty(FASchemaVersion_s)
// Controlling for public IPs only
| where isnotempty(PublicFrontendIPs_s) or isnotempty(PublicIPAddresses_s)
| where PublicFrontendIPs_s != ""null"" or PublicIPAddresses_s != ""null""
| extend SchemaVersion = SchemaVersion_s
// The Public IP can be indicated in one of 2 locations, assigning here for easy union results
| extend PublicIPs = case(isnotempty(PublicFrontendIPs_s), PublicFrontendIPs_s,
PublicIPAddresses_s) 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), FirstProcessedTimeUTC = min(TimeProcessed_t), LastProcessedTimeUtc = max(TimeProcessed_t), 
Regions = makeset(Region_s), AzureRegions = makeset(DiscoveryRegion_s), VMs = makeset(VirtualMachine_s), MACAddresses = makeset(MACAddress_s), PublicIPs = makeset(PublicIPs), 
SrcIP = makeset(PrivateIPAddresses_s), Name = makeset(Name_s), DestPort = makeset(DestinationPortRange_s),
ActivityCount = count() by NSG = NSG_s, SubNet = Subnetwork_s, Subscription = Subscription_g, SchemaVersion
// Some events don't have an NSG listed, populating so it is clear it is not available in the datatype
| extend NSG = case(isnotempty(NSG), NSG, ""NotAvailable"")
// Depending on the SchemaVersion, we will need to provide the NSG_Name for matching against the resource identified in AzureActivity
| extend NSG_Name = tostring(split(NSG, ""/"")[-1])
)
| project StartTimeUtc, EndTimeUtc, FirstProcessedTimeUTC, LastProcessedTimeUtc, PublicIPs, NSG, NSG_Name, SrcIP, DestPort, SubNet, Name, VMs, MACAddresses, ActivityCount, Regions, AzureRegions, Subscription, SchemaVersion
) on $left.Resource == $right.NSG_Name
| extend timestamp = StartTimeUtc, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress"
"a86f1ae5-22bc-4829-ae27-dc56e2b60f66","Rare application consent","true","Detection","Medium","AzureActiveDirectory","AuditLogs","1d","7d","本规则将对AAD中同意应用程序的权限申请发出告警。请确认对应的应用程序是否是可信任的","let timeframe = 1d;
let auditLookback = 7d;
// Setting threshold to 3 as a default, change as needed.  
// Any operation that has been initiated by a user or app more than 3 times in the past 7 days will be excluded
let threshold = 3;
// Gather initial data from lookback period, excluding current, adjust current to more than a single day if no results
let AuditTrail = AuditLogs | where TimeGenerated >= ago(auditLookback) and TimeGenerated < ago(timeframe)
// 2 other operations that can be part of malicious activity in this situation are 
// ""Add OAuth2PermissionGrant"" and ""Add service principal"", extend the filter below to capture these too
| where OperationName == ""Consent to application""
| extend InitiatedBy = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), 
tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), tostring(parse_json(tostring(InitiatedBy.app)).displayName))
| extend TargetResourceName = tolower(tostring(TargetResources.[0].displayName))
| summarize max(TimeGenerated), OperationCount = count() by OperationName, InitiatedBy, TargetResourceName
// only including operations by initiated by a user or app that is above the threshold so we produce only rare and has not occurred in last 7 days
| where OperationCount > threshold
;
// Gather current period of audit data
let RecentConsent = AuditLogs | where TimeGenerated >= ago(current)
| where OperationName == ""Consent to application""
| extend IpAddress = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)), 
tostring(parse_json(tostring(InitiatedBy.user)).ipAddress), tostring(parse_json(tostring(InitiatedBy.app)).ipAddress))
| extend InitiatedBy = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), 
tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), tostring(parse_json(tostring(InitiatedBy.app)).displayName))
| extend TargetResourceName = tolower(tostring(TargetResources.[0].displayName))
| parse TargetResources.[0].modifiedProperties with * ""ConsentType: "" ConsentType ""]"" *
| project TimeGenerated, InitiatedBy, IpAddress, TargetResourceName, Category, OperationName, ConsentType , CorrelationId, Type;
// Exclude previously seen audit activity for ""Consent to application"" that was seen in the lookback period
// First for rare InitiatedBy
let RareConsentBy = RecentConsent | join kind= leftanti AuditTrail on OperationName, InitiatedBy 
| extend Reason = ""Previously unseen user consenting"";
// Second for rare TargetResourceName
let RareConsentApp = RecentConsent | join kind= leftanti AuditTrail on OperationName, TargetResourceName
| extend Reason = ""Previously unseen app granted consent"";
RareConsentBy | union RareConsentApp
| summarize Reason = makeset(Reason) by TimeGenerated, InitiatedBy, IpAddress, TargetResourceName, Category, OperationName, ConsentType, CorrelationId, Type
| extend timestamp = TimeGenerated, AccountCustomEntity = InitiatedBy, HostCustomEntity = TargetResourceName, IPCustomEntity = IpAddress"
"ab642029-2370-43b0-aff3-d4cf28acd61a","Editing Linux scheduled tasks through Crontab","true","Hunting","none","Syslog","Syslog","none","none","本规则将标识用户何时使用 crontab 编辑或替换了计划任务。回顾时间是7天","// Change startdate below if you want a different timespan
let startdate = 14d;
// Pull messages from Syslog-cron logs where the process is crontab and the severity level is ""info"". Extract the User and Action information from the SyslogMessage
Syslog 
| where TimeGenerated  >= ago(startdate)
| where Facility =~ ""cron"" 
| where ProcessName =~ ""crontab"" 
| where SeverityLevel =~ ""info"" 
| project TimeGenerated, Computer, SeverityLevel, ProcessName, SyslogMessage
| parse SyslogMessage with * ""("" user  "") "" Action "" ("" *
// Only look for messages that contain edit or replace
| where Action contains ""EDIT"" or Action contains ""REPLACE""
//| summarize all the actions into a single set based on 10 minute time intervals
| summarize makeset(Action) by bin(TimeGenerated, 10m), Computer, user  
| project EventTime10MinInterval = TimeGenerated, Computer, user, ListOfActions = set_Action 
| order by Computer asc nulls last, EventTime10MinInterval asc
| extend timestamp = EventTime10MinInterval, AccountCustomEntity = user, HostCustomEntity = Computer"
"466f1c64-94c6-457b-84ce-934f52d3e1d2","Squid data volume timeseries anomalies","true","Hunting","none","Syslog","Syslog","none","none","本规则将遍历 squid 代理进程命令行中包含的异常情况。例如包含外部网络的访问","let starttime = 14d;
let endtime = 1d;
let timeframe = 1h;
let TimeSeriesData = 
Syslog
| where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))
| where ProcessName contains ""squid""
| extend URL = extract(""(([A-Z]+ [a-z]{4,5}:\\/\\/)|[A-Z]+ )([^ :]*)"",3,SyslogMessage), 
         SourceIP = extract(""([0-9]+ )(([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3}))"",2,SyslogMessage), 
         Status = extract(""(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))"",1,SyslogMessage), 
         HTTP_Status_Code = extract(""(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))/([0-9]{3})"",8,SyslogMessage),
         User = extract(""(CONNECT |GET )([^ ]* )([^ ]+)"",3,SyslogMessage),
         RemotePort = extract(""(CONNECT |GET )([^ ]*)(:)([0-9]*)"",4,SyslogMessage),
         Domain = extract(""(([A-Z]+ [a-z]{4,5}:\\/\\/)|[A-Z]+ )([^ :\\/]*)"",3,SyslogMessage),
         Bytes = toint(extract(""([A-Z]+\\/[0-9]{3} )([0-9]+)"",2,SyslogMessage)),
         contentType = extract(""([a-z/]+$)"",1,SyslogMessage)
| extend TLD = extract(""\\.[a-z]*$"",0,Domain)
| where isnotempty(Bytes)
| make-series TotalBytesSent=sum(Bytes) on TimeGenerated from startofday(ago(starttime)) to startofday(ago(endtime)) step timeframe by ProcessName;
TimeSeriesData
| extend (anomalies, score, baseline) = series_decompose_anomalies(TotalBytesSent,3, -1, 'linefit')
| extend timestamp = TimeGenerated
| render timechart with (title=""Squid Time Series anomalies"")"
"229e586b-76b6-4a07-9c9f-109bbf4cdb38","Rare Audit activity initiated by App","true","Hunting","none","AzureActiveDirectory","AuditLogs","none","none","本规则将当前一天与过去 14 天的AAD审计日志进行比较，以识别新的APP发起的审计活动操作名称、用户主体名称、属性名称、新值。在尝试追踪与添加新APP相关的恶意活动时非常有用。","let current = 1d;
let auditLookback = 14d;
let AuditTrail = AuditLogs 
| where TimeGenerated >= ago(auditLookback) and TimeGenerated < ago(current) 
| extend InitiatedByApp = tostring(parse_json(tostring(InitiatedBy.app)).displayName)
| where isnotempty(InitiatedByApp)
| extend ModProps = TargetResources.[0].modifiedProperties
| extend IpAddress = tostring(parse_json(tostring(InitiatedBy.app)).ipAddress)
| extend UserPrincipalName = tolower(tostring(TargetResources.[0].userPrincipalName))
| extend TargetResourceName = tolower(tostring(TargetResources.[0].displayName))
| mvexpand ModProps
| extend PropertyName = tostring(ModProps.displayName), newValue = replace(""\"""","""",tostring(ModProps.newValue))
| where isnotempty(newValue) and newValue != ""\""\""""
| summarize  by OperationName, InitiatedByApp, UserPrincipalName, IpAddress, TargetResourceName, PropertyName, newValue;
let AccountMods = AuditLogs 
| where TimeGenerated >= ago(current)
| extend InitiatedByApp = tostring(parse_json(tostring(InitiatedBy.app)).displayName)
| where isnotempty(InitiatedByApp)
| extend ModProps = TargetResources.[0].modifiedProperties
| extend IpAddress = tostring(parse_json(tostring(InitiatedBy.app)).ipAddress)
| extend UserPrincipalName = tolower(tostring(TargetResources.[0].userPrincipalName))
| extend TargetResourceName = tolower(tostring(TargetResources.[0].displayName))
| mvexpand ModProps
| extend PropertyName = tostring(ModProps.displayName), newValue = replace(""\"""","""",tostring(ModProps.newValue))
| where isnotempty(newValue) and newValue != ""\""\""""
| where PropertyName != ""TargetId.UserType""
| extend ModifiedProps = pack(""PropertyName"",PropertyName,""newValue"",newValue, ""Id"", Id, ""CorrelationId"", CorrelationId) 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Activity = make_bag(ModifiedProps) by Type, InitiatedByApp, UserPrincipalName, IpAddress, TargetResourceName, Category, OperationName, PropertyName, newValue;
let RareAudits = AccountMods | join kind= leftanti (
   AuditTrail 
) on OperationName, InitiatedByApp, UserPrincipalName, PropertyName, newValue;
RareAudits
| summarize StartTimeUtc = min(StartTimeUtc), EndTimeUtc = max(EndTimeUtc),Activity = make_set(Activity) by InitiatedByApp, OperationName, UserPrincipalName, IpAddress, TargetResourceName
| order by UserPrincipalName asc, StartTimeUtc asc
| extend timestamp = StartTimeUtc, AccountCustomEntity = UserPrincipalName, HostCustomEntity = TargetResourceName, IPCustomEntity = IpAddress"
"e30f9555-7429-4bec-8583-4cc32283c333","A potentially malicious web request was executed against a web server","true","Detection","Medium","WAF","AzureDiagnostics","1d","1d","通过计算WAF access log中会话中被阻止的请求和无障碍的请求之间的比率（BlockvsSuccessRatio 指标），检测 WAF 阻止传入请求的会话中的无障碍 Web 应用程序防火墙 (WAF) 活动。 给定客户端 IP 和主机名的高比率值要求对该会话中的 WAF 数据进行进一步调查，因为被阻止的请求数量非常多，并且有一些可能是恶意但未通过 WAF 检测到的无障碍日志。 successCode 变量定义了检测认为是成功的状态代码。 ","let mode = 'Blocked'; 
let successCode = dynamic(['200', '101','204', '400','504','304','401','500']);
let minTime = ago(1d);
let maxSessionWindow = 1h;
let sessionBin = maxSessionWindow/2.0;
AzureDiagnostics
| where TimeGenerated > minTime
| where Category == 'ApplicationGatewayFirewallLog'
| where action_s == mode
| sort by hostname_s asc, clientIp_s asc, TimeGenerated asc
| extend SessionStarted = row_window_session(TimeGenerated, maxSessionWindow, 10m, ((clientIp_s != prev(clientIp_s)) or (hostname_s != prev(hostname_s))))
| summarize minTime = min(TimeGenerated), maxTime = max(TimeGenerated), SessionBlockedCount=count()  by hostname_s, clientIp_s, SessionStarted
| extend duration = maxTime - minTime
| extend TimeKey = bin(SessionStarted, sessionBin)
| join kind = inner(
AzureDiagnostics
| where TimeGenerated > minTime
| where Category == 'ApplicationGatewayAccessLog'
| where httpStatus_d in (successCode) or isempty(httpStatus_d)
| extend TimeKey = range(bin(TimeGenerated-maxSessionWindow, sessionBin), bin(TimeGenerated, sessionBin), sessionBin)
| mv-expand TimeKey to typeof(datetime)
) on $left.hostname_s == $right.host_s, $left.clientIp_s == $right.clientIP_s, TimeKey
| where (TimeGenerated - SessionStarted) between (0m .. duration)
| extend originalRequestUriWithArgs_s = column_ifexists(""originalRequestUriWithArgs_s"", """")
| extend serverStatus_s = column_ifexists(""serverStatus_s"", """")
| extend timestamp = SessionStarted, IPCustomEntity = clientIP_s
| summarize SuccessfulAccessLogCount = count(), UserAgents = make_set(userAgent_s), RequestURIs = make_set(requestUri_s) , OriginalRequestURIs = make_set(originalRequestUriWithArgs_s), 
SuccessCodes = make_set(httpStatus_d), SuccessCodes_BackendServer = make_set(serverStatus_s) by timestamp, hostname_s, IPCustomEntity, SessionBlockedCount
| extend BlockvsSuccessRatio = SessionBlockedCount/SuccessfulAccessLogCount
| sort by BlockvsSuccessRatio desc, timestamp asc
| where SessionBlockedCount > SuccessfulAccessLogCount"
"09c83cbc-bc65-48f2-b16a-10faa15097fa","Alerts related to File","true","Hunting","none","AzureSecurityCenter","SecurityAlert","none","none","本规则将返回来自给定文件名相关的任何Azure安全中的的警报,默认查询区间是过去3天","let GetAllAlertsWithFile = (suspiciousEventTime:datetime, v_File:string){
let v_StartTime = suspiciousEventTime-1d;
let v_EndTime = suspiciousEventTime+1d;
SecurityAlert
| where TimeGenerated between (v_StartTime .. v_EndTime)
| extend Extprop = parsejson(ExtendedProperties)
| where ExtendedProperties has v_File
| extend Computer = iff(isnotempty(toupper(tostring(Extprop[""Compromised Host""]))), toupper(tostring(Extprop[""Compromised Host""])), tostring(parse_json(Entities)[0].HostName))
| extend Account = iff(isnotempty(tolower(tostring(Extprop[""User Name""]))), tolower(tostring(Extprop[""User Name""])), tolower(tostring(Extprop[""user name""])))
| extend IpAddress = tostring(parse_json(ExtendedProperties).[""Client Address""]) 
| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress
};
// change datetime value and <filename> value below
GetAllAlertsWithFile(now(), ""{filename}"")"
"f935459f-72f0-4089-a7d6-a3eb3178b528","User created by unauthorized user","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","本规则将识别出由未经授权的用户创建的用户帐户","// Create DataTable with your own values, example below shows dummy usernames that are authorized and for what domain
let List = datatable(AuthorizedUser:string, Domain:string)[""Bob"", ""Domain"", ""joe"", ""domain"", ""MATT"", ""DOMAIN""];
let timeframe = 1d;
SecurityEvent
| where TimeGenerated >= ago(timeframe)
| where EventID == 4720
| where AccountType == ""User""
| join kind= leftanti (
    List
    | project SubjectUserName = tolower(AuthorizedUser), SubjectDomainName = toupper(Domain)
) on SubjectUserName, SubjectDomainName
| project TimeGenerated, Computer, Account, SubjectUserName, SubjectDomainName, TargetAccount, EventID, Activity
| extend timestamp = TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account"
"2080a944-420d-49f4-a3b3-bd6512c6b46c","Multiple explicit credential usage - 4648 events","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","Based on recent investigations related to Solorigate, adversaries were seen to obtain and abuse credentials of multiple accounts 
 to connect to multiple machines. This query uses Security Event 4648 (A logon was attempted using explicit credentials) 
 to find machines in an environment, from where different accounts were used to connect to multiple hosts. Scoring is done based on 
 protocols seen in Solorigate. While this mentions Solorigate, this hunting query can be used to identify this type of pattern for 
 any attacker.
 Reference - https://docs.microsoft.com/windows/security/threat-protection/auditing/event-4648'
","let WellKnownLocalSIDs = ""S-1-5-[0-9][0-9]$"";
let protocols = dynamic(['cifs', 'ldap', 'RPCSS', 'host' , 'HTTP', 'RestrictedKrbHost', 'TERMSRV', 'msomsdksvc', 'mssqlsvc']);
SecurityEvent
| where EventID == 4648
| where SubjectUserSid != 'S-1-0-0' // this is the Nobody SID which really means No security principal was included.
| where not(SubjectUserSid matches regex WellKnownLocalSIDs) //excluding system account/service account as this is generally normal
| where TargetInfo has '/' //looking for only items that indicate an interesting protocol is included
| where Computer !has tostring(split(TargetServerName,'$')[0])
| where TargetAccount !~ tostring(split(SubjectAccount,'$')[0])
| extend TargetInfoProtocol = tolower(split(TargetInfo, '/')[0]), TargetInfoMachine = toupper(split(TargetInfo, '/')[1])
| extend TargetAccount = tolower(TargetAccount), SubjectAccount = tolower(SubjectAccount)
| extend UncommonProtocol = case(not(TargetInfoProtocol has_any (protocols)), TargetInfoProtocol, 'NotApplicable')
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), AccountsUsedCount = dcount(TargetAccount), AccountsUsed = make_set(TargetAccount), TargetMachineCount = dcount(TargetInfoMachine), 
TargetMachines = make_set(TargetInfoMachine), TargetProtocols = dcount(TargetInfoProtocol), Protocols = make_set(TargetInfoProtocol), Processes = make_set(Process) by Computer, SubjectAccount, UncommonProtocol
| where TargetMachineCount > 1 or UncommonProtocol != 'NotApplicable'
| extend ProtocolCount = array_length(Protocols)
| extend ProtocolScore = case(
  Protocols has 'rpcss' and Protocols has 'host' and Protocols has 'cifs', 10, //observed in Solorigate and depending on which are used together the higher the score
  Protocols has 'rpcss' and Protocols has 'host', 5,
  Protocols has 'rpcss' and Protocols has 'cifs', 5,
  Protocols has 'host' and Protocols has 'cifs', 5,
  Protocols has 'ldap' or Protocols has 'rpcss' or Protocols has 'host' or Protocols has 'cifs', 1, //ldap is more commonly seen in general, this was also seen with Solorigate but not usually to the same machines as the others above
  UncommonProtocol != 'NotApplicable', 3,
  0 //other protocols may be of interest, but in relation to observations for enumeration/execution in Solorigate they receive 0
)
| extend Score = ProtocolScore + ProtocolCount + AccountsUsedCount
| where Score >= 9 or (UncommonProtocol != 'NotApplicable' and Score >= 4) // Score must be 9 or better as this will include 5 points for atleast 2 of the interesting protocols + the count of protocols (min 2) + the number of accounts used for execution (min 2) = min of 9 OR score must be 4 or greater for an uncommon protocol
| extend TimePeriod = EndTime - StartTime //This identifies the time between start and finish for the use of the explicit credentials, shorter time period may indicate scripted executions
| project-away UncommonProtocol
| extend timestamp = StartTime, AccountCustomEntity = SubjectAccount, HostCustomEntity = Computer
| order by Score desc"
"6b80b4ee-27d7-4d65-a1c5-5b76cfb682eb","Interactive STS refresh token modifications","true","Hunting","none","AzureActiveDirectory","AuditLogs","none","none","This will show Active Directory Security Token Service (STS) refresh token modifications by Service Principals and Applications other than DirectorySync. Refresh tokens are used to validate identification and obtain access tokens.
This event is not necessarily an indication of malicious activity but can also be generated when legitimate administrators manually expire token validation or keep longer refresh tokens for better login experience with less prompts.
Also an allowlist has been included to filter known accounts which can be customized after careful review of past historical activity.
Analyze the results for unusual operations performed by administrators to extend a refresh token of a compromised account in order to extend the time they can use it without the need to re-authenticate (and thus potentially lose access).
For in-depth documentation of AAD Security Tokens, see https://docs.microsoft.com/azure/active-directory/develop/security-tokens.
For further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.
For valid use cases of altering token lifetime values, refer https://docs.microsoft.com/azure/active-directory/develop/access-tokens#token-timeouts
More information about risky use-cases, refer https://docs.microsoft.com/azure/active-directory/develop/active-directory-configurable-token-lifetimes#token-lifetimes-with-public-client-refresh-tokens'
","// Include your additions to the allow list below as needed
let AllowedUserList = dynamic([""Microsoft Cloud App Security"",""ADConnectSyncAccount1"",""SyncAccount2""]);
AuditLogs
| where OperationName has 'StsRefreshTokenValidFrom'
| where TargetResources[0].modifiedProperties != '[]'
| where TargetResources[0].modifiedProperties !has 'DirectorySync'
| extend TargetResourcesModProps = TargetResources[0].modifiedProperties
| mv-expand TargetResourcesModProps
| where tostring(TargetResourcesModProps.displayName) =~ 'StsRefreshTokensValidFrom'
| extend InitiatingUserOrApp = iff(isnotempty(InitiatedBy.user.userPrincipalName),tostring(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.app.displayName))
| where InitiatingUserOrApp !in (AllowedUserList)
| extend targetUserOrApp = TargetResources[0].userPrincipalName
| extend eventName = tostring(TargetResourcesModProps.displayName)
| extend oldStsRefreshValidFrom = todatetime(parse_json(tostring(TargetResourcesModProps.oldValue))[0])
| extend newStsRefreshValidFrom = todatetime(parse_json(tostring(TargetResourcesModProps.newValue))[0])
| extend tokenMinutesAdded = datetime_diff('minute',newStsRefreshValidFrom,oldStsRefreshValidFrom)
| extend tokenMinutesRemaining = datetime_diff('minute',TimeGenerated,newStsRefreshValidFrom)
| project-reorder Result, AADOperationType
| extend InitiatingIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), tostring(InitiatedBy.user.ipAddress), tostring(InitiatedBy.app.ipAddress))
| extend timestamp = TimeGenerated, AccountCustomEntity = InitiatingUserOrApp, IPCustomEntity = InitiatingIpAddress"
"78cc835e-fe16-4ae4-9c04-01b167ceb3ac","RDP Nesting","true","Detection","Medium","SecurityEvents","SecurityEvent","1d","8d","Identifies when an RDP connection is made to a first system and then an RDP connection is made from the first system 
to another system with the same account within the 60 minutes. Additionally, if historically daily  
RDP connections are indicated by the logged EventID 4624 with LogonType = 10","let endtime = 1d;
let starttime = 8d;
// The threshold below excludes matching on RDP connection computer counts of 5 or more by a given account and IP in a given day.  Change the threshold as needed.
let threshold = 5;
SecurityEvent
| where TimeGenerated >= ago(endtime) 
| where EventID == 4624 and LogonType == 10
// Labeling the first RDP connection time, computer and ip
| extend FirstHop = TimeGenerated, FirstComputer = toupper(Computer), FirstIPAddress = IpAddress, Account = tolower(Account)  
| join kind=inner (
SecurityEvent
| where TimeGenerated >= ago(endtime) 
| where EventID == 4624 and LogonType == 10
// Labeling the second RDP connection time, computer and ip
| extend SecondHop = TimeGenerated, SecondComputer = toupper(Computer), SecondIPAddress = IpAddress, Account = tolower(Account)
) on Account
// Make sure that the first connection is after the second connection --> SecondHop > FirstHop
// Then identify only RDP to another computer from within the first RDP connection by only choosing matches where the Computer names do not match --> FirstComputer != SecondComputer
// Then make sure the IPAddresses do not match by excluding connections from the same computers with first hop RDP connections to multiple computers --> FirstIPAddress != SecondIPAddress
| where FirstComputer != SecondComputer and FirstIPAddress != SecondIPAddress and SecondHop > FirstHop
// where the second hop occurs within 30 minutes of the first hop
| where SecondHop <= FirstHop+30m
| distinct Account, FirstHop, FirstComputer, FirstIPAddress, SecondHop, SecondComputer, SecondIPAddress, AccountType, Activity, LogonTypeName, ProcessName
// use left anti to exclude anything from the previous 7 days where the Account and IP has connected 5 or more computers.
| join kind=leftanti (
SecurityEvent
| where TimeGenerated >= ago(starttime) and TimeGenerated < ago(endtime) 
| where EventID == 4624 and LogonType == 10
| summarize makeset(Computer), ComputerCount = dcount(Computer) by bin(TimeGenerated, 1d), Account = tolower(Account), IpAddress
// Connection count to computer by same account and IP to exclude counts of 5 or more on a given day
| where ComputerCount >= threshold
| mvexpand set_Computer
| extend Computer = toupper(set_Computer)
) on Account, $left.SecondComputer == $right.Computer, $left.SecondIPAddress == $right.IpAddress
| summarize FirstHopFirstSeen = min(FirstHop), FirstHopLastSeen = max(FirstHop) by Account, FirstComputer, FirstIPAddress, SecondHop, SecondComputer, 
SecondIPAddress, AccountType, Activity, LogonTypeName, ProcessName
| extend timestamp = FirstHopFirstSeen, AccountCustomEntity = Account, HostCustomEntity = FirstComputer, IPCustomEntity = FirstIPAddress"
"4d55fc35-df9c-4431-94bb-87ce5ba43c89","Azure AD Health Monitoring Agent Registry Keys Access","true","Detection","Medium","SecurityEvents","SecurityEvent","1d","1d","此检测使用 Windows 安全事件来检测对 Azure AD 运行状况监视代理的注册表项的可疑访问尝试。
此检测需要以下安全对象 HKLM\ 的系统访问控制列表 (SACL) 上的访问控制条目 (ACE) SOFTWARE\Microsoft\Microsoft Online\Reporting\MonitoringAgent。
您可以在此处找到更多信息 https://github.com/OTRF/Set-AuditRule/blob/master/rules/registry/aad_connect_health_monitoring_agent.yml","// ADHealth Monitoring Agent Registry Key
let aadHealthMonAgentRegKey = ""\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Microsoft Online\\Reporting\\MonitoringAgent"";
// Filter out known processes
let aadConnectHealthProcs = dynamic ([
    'Microsoft.Identity.Health.Adfs.DiagnosticsAgent.exe',
    'Microsoft.Identity.Health.Adfs.InsightsService.exe',
    'Microsoft.Identity.Health.Adfs.MonitoringAgent.Startup.exe',
    'Microsoft.Identity.Health.Adfs.PshSurrogate.exe',
    'Microsoft.Identity.Health.Common.Clients.ResourceMonitor.exe'
]);
(union isfuzzy=true
(
SecurityEvent
| where EventID == '4656'
| extend EventData = parse_xml(EventData).EventData.Data
| mv-expand bagexpansion=array EventData
| evaluate bag_unpack(EventData)
| extend Key = tostring(column_ifexists('@Name', """")), Value = column_ifexists('#text', """")
| evaluate pivot(Key, any(Value), TimeGenerated, Computer, EventID)
| extend SubjectUserName = column_ifexists(""SubjectUserName"", """"),
    SubjectDomainName = column_ifexists(""SubjectDomainName"", """"),
    ObjectName = column_ifexists(""ObjectName"", """"),
    ObjectType = column_ifexists(""ObjectType"", """"),
    ProcessName = column_ifexists(""ProcessName"", """")
| extend Process = split(ProcessName, '\\', -1)[-1],
    Account = strcat(SubjectDomainName, ""\\"", SubjectUserName)
| where ObjectType == 'Key'
| where ObjectName == aadHealthMonAgentRegKey
| where Process !in (aadConnectHealthProcs)
),
(
SecurityEvent
| where EventID == '4663'
| extend Process = split(ProcessName, '\\', -1)[-1]
| where ObjectType == 'Key'
| where ObjectName == aadHealthMonAgentRegKey
| where Process !in (aadConnectHealthProcs)
)
)
// You can filter out potential machine accounts
//| where AccountType != 'Machine'
| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer
| summarize count() by ProcessName"
"07d48e72-a3c1-47ea-bb2d-6336daca0281","Consent to Application discovery","true","Hunting","none","AzureActiveDirectory","AuditLogs","none","none","本规则将查询过去 14 天的AAD审计日志并找出任何“同意申请”操作。此类操作可能表明访问列出的 AzureApp 的权限被提供给恶意行为者。 同意申请，添加服务主体和
添加 OAuth2PermissionGrant 事件应该很少见。 如果可用，会添加额外的上下文来自基于 CorrleationId 的审计日志，来自执行“同意应用”。
有关审计日志的更多信息，请参阅
https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities
这可能有助于检测可由此公开可用工具发起的 Oauth2 攻击 https://github.com/fireeye/PwnAuth","let auditLookback = 14d;
// Setting threshold to 3 as a default, change as needed.  Any operation that has been initiated by a user or app more than 3 times in the past 30 days will be exluded
let threshold = 3;
// Helper function to extract relevant fields from AuditLog events
let auditLogEvents = view (startTimeSpan:timespan)  {
    AuditLogs | where TimeGenerated >= ago(auditLookback)
    | extend ModProps = TargetResources.[0].modifiedProperties
    | extend IpAddress = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)), 
    tostring(parse_json(tostring(InitiatedBy.user)).ipAddress), tostring(parse_json(tostring(InitiatedBy.app)).ipAddress))
    | extend InitiatedBy = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), 
    tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), tostring(parse_json(tostring(InitiatedBy.app)).displayName))
    | extend TargetResourceName = tolower(tostring(TargetResources.[0].displayName))
    | mvexpand ModProps
    | extend PropertyName = tostring(ModProps.displayName), newValue = replace(""\"""","""",tostring(ModProps.newValue));
};
// Get just the InitiatedBy and CorrleationId so we can look at associated audit activity
// 2 other operations that can be part of malicious activity in this situation are 
// ""Add OAuth2PermissionGrant"" and ""Add service principal"", replace the below if you are interested in those as starting points for OperationName
let HistoricalConsent = auditLogEvents(auditLookback)  
| where OperationName == ""Consent to application""
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), OperationCount = count() 
by Type, InitiatedBy, IpAddress, TargetResourceName, Category, OperationName, PropertyName, newValue, CorrelationId, Id
// Remove comment below to only include operations initiated by a user or app that is above the threshold for the last 30 days
//| where OperationCount > threshold
;
let Correlate = HistoricalConsent 
| summarize by InitiatedBy, CorrelationId;
// 2 other operations that can be part of malicious activity in this situation are 
// ""Add OAuth2PermissionGrant"" and ""Add service principal"", replace the below if you changed the starting OperationName above
let allOtherEvents = auditLogEvents(auditLookback) 
| where OperationName != ""Consent to application"";
// Gather associated activity based on audit activity for ""Consent to application"" and InitiatedBy and CorrleationId
let CorrelatedEvents = Correlate 
| join allOtherEvents on InitiatedBy, CorrelationId
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) 
by Type, InitiatedBy, IpAddress, TargetResourceName, Category, OperationName, PropertyName, newValue, CorrelationId, Id
;
// Union the results
let Results = union isfuzzy=true HistoricalConsent,CorrelatedEvents;
// newValues that are simple semi-colon separated, make those dynamic for easy viewing and Aggregate into the PropertyUpdate set based on CorrelationId and Id(DirectoryId)
Results
| extend newValue = split(newValue, "";"")
| extend PropertyUpdate = pack(PropertyName, newValue, ""Id"", Id)
| summarize StartTimeUtc = min(StartTimeUtc), EndTimeUtc = max(EndTimeUtc), PropertyUpdateSet = make_bag(PropertyUpdate) 
by InitiatedBy, IpAddress, TargetResourceName, OperationName, CorrelationId
| extend timestamp = StartTimeUtc, AccountCustomEntity = InitiatedBy, HostCustomEntity = TargetResourceName, IPCustomEntity = IpAddress"
"40c3f535-4d90-4a8e-b1dc-355d82842cb7","Sign-ins from IPs that attempt sign-ins to disabled accounts","true","Detection","Medium","AzureActiveDirectory","SigninLogs","1d","1d","本规则检查AAD 登录失败日志： 50057 - 用户帐户被禁用，该帐户已被管理员禁用。报告所有发起此类攻击的IP地址","let lookBack = 1d;
SigninLogs 
| where TimeGenerated >= ago(lookBack)
| where ResultType == ""50057"" 
| where ResultDescription contains ""User account is disabled"" 
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), disabledAccountLoginAttempts = count(), 
disabledAccountsTargeted = dcount(UserPrincipalName), applicationsTargeted = dcount(AppDisplayName), disabledAccountSet = makeset(UserPrincipalName), 
applicationSet = makeset(AppDisplayName) by IPAddress
| order by disabledAccountLoginAttempts desc
| join kind= leftouter (
    // Consider these IPs suspicious - and alert any related  successful sign-ins
    SigninLogs
    | where TimeGenerated >= ago(lookBack)
    | where ResultType == 0
    | summarize successfulAccountSigninCount = dcount(UserPrincipalName), successfulAccountSigninSet = makeset(UserPrincipalName, 15) by IPAddress
    // Assume IPs associated with sign-ins from 100+ distinct user accounts are safe
    | where successfulAccountSigninCount < 100
) on IPAddress  
// IPs from which attempts to authenticate as disabled user accounts originated, and had a non-zero success rate for some other account
| where successfulAccountSigninCount != 0
| project StartTimeUtc, EndTimeUtc, IPAddress, disabledAccountLoginAttempts, disabledAccountsTargeted, disabledAccountSet, applicationSet, 
successfulAccountSigninCount, successfulAccountSigninSet
| order by disabledAccountLoginAttempts
| extend timestamp = StartTimeUtc, IPCustomEntity = IPAddress"
"a5c30ad8-1b05-4b2a-b294-d39301f017a4","Azure Active Directory sign-in burst from multiple locations","true","Hunting","none","AzureActiveDirectory","SigninLogs","none","none","本规则将标识出所有在很短的时间内从不同的地理位置进行多次身份验证的AAD登录请求","let timeframe = ago(10d);
let signIns = SigninLogs
| where TimeGenerated >= timeframe
| extend locationString= strcat(tostring(LocationDetails[""countryOrRegion""]), ""/"",
 tostring(LocationDetails[""state""]), ""/"", tostring(LocationDetails[""city""]))
| where locationString != ""//"" 
// filter out signins associated with top 100 signin locations 
| join kind=anti (
SigninLogs
  | extend locationString= strcat(tostring(LocationDetails[""countryOrRegion""]), ""/"", 
  tostring(LocationDetails[""state""]), ""/"", tostring(LocationDetails[""city""]))
  | where locationString != ""//""
  | summarize count() by locationString
  | order by count_ desc
  | take 100) on locationString ; // TODO - make this threshold percentage-based
// We will perform a time window join to identify signins from multiple locations within a 10-minute period
let lookupWindow = 10m;
let lookupBin = lookupWindow / 2.0; // lookup bin = equal to 1/2 of the lookup window
signIns 
| project-rename Start=TimeGenerated 
| extend TimeKey = bin(Start, lookupBin)
| join kind = inner (
signIns 
| project-rename End=TimeGenerated, EndLocationString=locationString 
  // TimeKey on the right side of the join - emulates this authentication appearing several times
  | extend TimeKey = range(bin(End - lookupWindow, lookupBin),
  bin(End, lookupBin), lookupBin)
  | mvexpand TimeKey to typeof(datetime) // translate TimeKey arrange range to a column
) on Identity, TimeKey
| where End > Start
| project timeSpan = End - Start, Identity, locationString, EndLocationString,tostring(Start), tostring(End), UserPrincipalName
| where locationString != EndLocationString
| summarize by timeSpan, Identity, locationString, EndLocationString, Start, End, UserPrincipalName
| extend timestamp = Start, AccountCustomEntity = UserPrincipalName 
| order by Identity"
"ad53640f-13b7-48be-97ec-5512043ba6cd","Web shell command alert enrichment","true","Hunting","none","MicrosoftDefenderAdvancedThreatProtection","SecurityAlert","none","none","Extracts MDATP Alerts that indicate a command was executed by a web shell. Uses time window based querying to idneitfy the potential web shell location on the server, then enriches with Attacker IP and User Agent","let scriptExtensions = dynamic(["".php"", "".jsp"", "".js"", "".aspx"", "".asmx"", "".asax"", "".cfm"", "".shtml""]);
let timeframe = 3d; 
let lookupWindow = 1m;  
let lookupBin = lookupWindow / 2.0; 
let distinctIpThreshold = 3; 
let alerts = SecurityAlert  
| where TimeGenerated > ago(timeframe) 
| extend alertData = parse_json(Entities), recordGuid = new_guid(); 
let shellAlerts = alerts 
| where ProviderName =~ ""MDATP""  
| mvexpand alertData 
| where alertData.Type =~ ""file"" and alertData.Name =~ ""w3wp.exe"" 
| distinct SystemAlertId 
| join kind=inner (alerts) on SystemAlertId; 
let alldata = shellAlerts  
| mvexpand alertData 
| extend Type = alertData.Type; 
let filedata = alldata  
| extend id = tostring(alertData.$id)  
| extend ImageName = alertData.Name  
| where Type =~ ""file"" and ImageName != ""w3wp.exe"" 
| extend imagefileref = id;  
let commanddata = alldata  
| extend CommandLine = tostring(alertData.CommandLine)  
| extend creationtime = tostring(alertData.CreationTimeUtc)  
| where Type =~ ""process""  
| where isnotempty(CommandLine)  
| extend imagefileref = tostring(alertData.ImageFile.$ref); 
let hostdata = alldata 
| where Type =~ ""host"" 
| project HostName = tostring(alertData.HostName), DnsDomain = tostring(alertData.DnsDomain), SystemAlertId 
| distinct HostName, DnsDomain, SystemAlertId; 
let commandKeyedData = filedata 
| join kind=inner (  
commanddata  
) on imagefileref 
| join kind=inner (hostdata) on SystemAlertId 
| project recordGuid, TimeGenerated, ImageName, CommandLine, TimeKey = bin(TimeGenerated, lookupBin), HostName, DnsDomain 
| extend Start = TimeGenerated; 
let baseline = W3CIISLog  
| where TimeGenerated > ago(timeframe) 
| project-rename SourceIP=cIP, PageAccessed=csUriStem 
| summarize dcount(SourceIP) by PageAccessed 
| where dcount_SourceIP <= distinctIpThreshold; 
commandKeyedData 
| join kind=inner ( 
W3CIISLog  
| where TimeGenerated > ago(timeframe) 
| where csUriStem has_any(scriptExtensions)  
| extend splitUriStem = split(csUriStem, ""/"")  
| extend FileName = splitUriStem[-1] | extend firstDir = splitUriStem[-2] | extend TimeKey = range(bin(TimeGenerated-lookupWindow, lookupBin), bin(TimeGenerated, lookupBin),lookupBin)  
| mv-expand TimeKey to typeof(datetime)  
| summarize StartTime=min(TimeGenerated), EndTime=max(TimeGenerated) by Site=sSiteName, HostName=sComputerName, AttackerIP=cIP, AttackerUserAgent=csUserAgent, csUriStem, filename=tostring(FileName), tostring(firstDir), TimeKey 
) on TimeKey, HostName 
| where (StartTime - EndTime) between (0min .. lookupWindow) 
| extend IPCustomEntity = AttackerIP, timestamp = StartTime
| extend attackerP = pack(AttackerIP, AttackerUserAgent)  
| summarize Site=make_set(Site), Attacker=make_bag(attackerP) by csUriStem, filename, tostring(ImageName), CommandLine, HostName, IPCustomEntity, timestamp
| project Site, ShellLocation=csUriStem, ShellName=filename, ParentProcess=ImageName, CommandLine, Attacker, HostName, IPCustomEntity, timestamp
| join kind=inner (baseline) on $left.ShellLocation == $right.PageAccessed"
"27c515ee-0c02-410e-93b1-ac6878c31eac","Failed login attempts to Azure Portal","true","Detection","Low","AzureActiveDirectory","SigninLogs","1d","7d","本规则检查AAD登录中的登录失败记录。来自多个 IP 的尝试或一些失败的登录尝试可能表明潜在的暴力攻击。 参考资料：https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes","let timeframe = 1d;
let lookBack = 7d;
let threshold_Failed = 5;
let threshold_FailedwithSingleIP = 20;
let threshold_IPAddressCount = 2;
let isGUID = ""[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}"";
let azPortalSignins = materialize(SigninLogs
| where TimeGenerated >= ago(lookBack)
// Azure Portal only
| where AppDisplayName =~ ""Azure Portal"")
;
let successPortalSignins = azPortalSignins
| where TimeGenerated >= ago(timeframe)
// Azure Portal only and exclude non-failure Result Types
| where ResultType in (""0"", ""50125"", ""50140"")
// Tagging identities not resolved to friendly names
//| extend Unresolved = iff(Identity matches regex isGUID, true, false)
| distinct TimeGenerated, UserPrincipalName, Id, ResultType
;
let failPortalSignins = azPortalSignins
| where TimeGenerated >= ago(timeframe)
// Azure Portal only and exclude non-failure Result Types
| where ResultType !in (""0"", ""50125"", ""50140"")
// Tagging identities not resolved to friendly names
| extend Unresolved = iff(Identity matches regex isGUID, true, false)
;
// Verify there is no success for the same connection attempt after the fail
let failnoSuccess = failPortalSignins | join kind= leftouter (
   successPortalSignins 
) on UserPrincipalName, Id
| where TimeGenerated > TimeGenerated1
| project-away TimeGenerated1, UserPrincipalName1, Id1, ResultType1
;
// Lookup up resolved identities from last 7 days
let identityLookup = azPortalSignins
| where TimeGenerated >= ago(lookBack)
| where not(Identity matches regex isGUID)
| summarize by UserId, lu_UserDisplayName = UserDisplayName, lu_UserPrincipalName = UserPrincipalName;
// Join resolved names to unresolved list from portal signins
let unresolvedNames = failnoSuccess | where Unresolved == true | join kind= inner (
   identityLookup 
) on UserId
| extend UserDisplayName = lu_UserDisplayName, UserPrincipalName = lu_UserPrincipalName
| project-away lu_UserDisplayName, lu_UserPrincipalName;
// Join Signins that had resolved names with list of unresolved that now have a resolved name
let u_azPortalSignins = failnoSuccess | where Unresolved == false | union unresolvedNames;
u_azPortalSignins
| extend Status = strcat(ResultType, "": "", ResultDescription), OS = tostring(DeviceDetail.operatingSystem), Browser = tostring(DeviceDetail.browser)
| extend FullLocation = strcat(Location,'|', LocationDetails.state, '|', LocationDetails.city)
| summarize TimeGenerated = makelist(TimeGenerated), Status = makelist(Status), IPAddresses = makelist(IPAddress), IPAddressCount = dcount(IPAddress), FailedLogonCount = count()
by UserPrincipalName, UserId, UserDisplayName, AppDisplayName, Browser, OS, FullLocation
| mvexpand TimeGenerated, IPAddresses, Status
| extend TimeGenerated = todatetime(tostring(TimeGenerated)), IPAddress = tostring(IPAddresses), Status = tostring(Status)
| project-away IPAddresses
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserPrincipalName, UserId, UserDisplayName, Status, FailedLogonCount, IPAddress, IPAddressCount, AppDisplayName, Browser, OS, FullLocation
| where (IPAddressCount >= threshold_IPAddressCount and FailedLogonCount >= threshold_Failed) or FailedLogonCount >= threshold_FailedwithSingleIP
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress"
"ac35b5f1-a277-45cc-9e06-40074a06bc1c","Azure storage key enumeration","true","Hunting","none","AzureActivity","AzureActivity","none","none","本规则将查询所有发起列出存储密钥操作的IP地址和调用者，以此来帮助判断是否有机密存储泄露的可能。","let timeframe = 7d;
AzureActivity
| where TimeGenerated >= ago(timeframe)
| where OperationName == ""Microsoft.Storage/storageAccounts/listKeys/action""
| where ActivityStatus == ""Succeeded"" 
| join kind= inner (
    AzureActivity
    | where TimeGenerated >= ago(timeframe)
    | where OperationName == ""Microsoft.Storage/storageAccounts/listKeys/action""
    | where ActivityStatus == ""Succeeded"" 
    | project ExpectedIpAddress=CallerIpAddress, Caller 
    | evaluate autocluster()
) on Caller 
| where CallerIpAddress != ExpectedIpAddress
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ResourceIds = makeset(ResourceId), ResourceIdCount = dcount(ResourceId) by OperationName, Caller, CallerIpAddress
| extend timestamp = StartTimeUtc, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress"
"2fd5c063-d8fd-4fbb-8c0f-a3662fab0c5a","GitHub Signin Burst from Multiple Locations","true","Detection","Medium","AzureActiveDirectory","SigninLogs","1h","1h","本规则检查 GitHub （AAD SSO）登录。 如果存在多地登录，将发出警报","let RunTime = 1h;
SigninLogs
| where TimeGenerated > ago(RunTime)
| where AppDisplayName contains ""GitHub""
| where ResultType == 0
| summarize CountOfLocations = dcount(Location), Locations = make_set(Location) by User = Identity
| where CountOfLocations > 1
//| extend AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress"
"bba6c567-22db-448f-841e-fcebb4ccfb0f","User added to Azure Active Directory Privileged Groups","true","Detection","Medium","AzureActiveDirectory","AuditLogs","1h","1h","本规则将在用户被添加到任何特权组时发出警报。有关 Azure Active Directory 中的管理员角色权限，请参阅 https://docs.microsoft.com/azure/active-directory/users-groups-roles/directory-assign-admin-roles","let timeframe = 1h;
let OperationList = dynamic([""Add member to role"",""Add member to role in PIM requested (permanent)""]);
let PrivilegedGroups = dynamic([""UserAccountAdmins"",""PrivilegedRoleAdmins"",""TenantAdmins""]);
AuditLogs
| where TimeGenerated >= ago(timeframe)
| where LoggedByService =~ ""Core Directory""
| where Category =~ ""RoleManagement""
| where OperationName in~ (OperationList)
| mv-expand TargetResources
| extend modifiedProperties = parse_json(TargetResources).modifiedProperties
| mv-expand modifiedProperties
| extend DisplayName = tostring(parse_json(modifiedProperties).displayName), GroupName =  trim(@'""',tostring(parse_json(modifiedProperties).newValue))
| extend AppId = tostring(parse_json(parse_json(InitiatedBy).app).appId), InitiatedByDisplayName = tostring(parse_json(parse_json(InitiatedBy).app).displayName), ServicePrincipalId = tostring(parse_json(parse_json(InitiatedBy).app).servicePrincipalId), ServicePrincipalName = tostring(parse_json(parse_json(InitiatedBy).app).servicePrincipalName)
| where DisplayName =~ ""Role.WellKnownObjectName""
| where GroupName in~ (PrivilegedGroups)
// If you want to still alert for operations from PIM, remove below filtering for MS-PIM.
| where InitiatedByDisplayName != ""MS-PIM""
| project TimeGenerated, AADOperationType, Category, OperationName, AADTenantId, AppId, InitiatedByDisplayName, ServicePrincipalId, ServicePrincipalName, DisplayName, GroupName
| extend timestamp = TimeGenerated, AccountCustomEntity = ServicePrincipalName"
"3dfa9aaf-0b36-48d5-b482-4362d7fbf7bb","Login attempt by Blocked MFA user","true","Hunting","none","AzureActiveDirectory","SigninLogs","none","none","本规则将返回连续多次失败的身份验证尝试。 此搜索查询可识别设置为阻止的 MFA 用户帐户是否尝试登录 Azure AD","let timeframe = 1d;
let lookBack = 7d;
let isGUID = ""[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}"";
let MFABlocked = SigninLogs
| where TimeGenerated >= ago(timeframe)
| where ResultType != ""0"" 
| extend StatusCode = tostring(Status.errorCode), StatusDetails = tostring(Status.additionalDetails), Status = strcat(ResultType, "": "", ResultDescription)
| where StatusDetails =~ ""MFA denied; user is blocked""
| extend Unresolved = iff(Identity matches regex isGUID, true, false);
// Lookup up resolved identities from last 7 days
let identityLookup = SigninLogs
| where TimeGenerated >= ago(lookBack)
| where not(Identity matches regex isGUID)
| summarize by UserId, lu_UserDisplayName = UserDisplayName, lu_UserPrincipalName = UserPrincipalName;
// Join resolved names to unresolved list from MFABlocked signins
let unresolvedNames = MFABlocked | where Unresolved == true | join kind= inner (
 identityLookup 
) on UserId
| extend UserDisplayName = lu_UserDisplayName, UserPrincipalName = lu_UserPrincipalName
| project-away lu_UserDisplayName, lu_UserPrincipalName;
// Join Signins that had resolved names with list of unresolved that now have a resolved name
let u_MFABlocked = MFABlocked | where Unresolved == false | union unresolvedNames;
u_MFABlocked 
| extend OS = tostring(DeviceDetail.operatingSystem), Browser = tostring(DeviceDetail.browser)
| extend FullLocation = strcat(Location,'|', LocationDetails.state, '|', LocationDetails.city)
| summarize TimeGenerated = makelist(TimeGenerated), Status = makelist(Status), IPAddresses = makelist(IPAddress), IPAddressCount = dcount(IPAddress), 
  AttemptCount = count() by UserPrincipalName, UserId, UserDisplayName, AppDisplayName, Browser, OS, FullLocation , CorrelationId 
| mvexpand TimeGenerated, IPAddresses, Status
| extend TimeGenerated = todatetime(tostring(TimeGenerated)), IPAddress = tostring(IPAddresses), Status = tostring(Status)
| project-away IPAddresses
| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserPrincipalName, UserId, UserDisplayName, Status,  IPAddress, IPAddressCount, AppDisplayName, Browser, OS, FullLocation
| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress"
"ce01270d-d609-487a-bea3-34741e2276a2","New Child Process of W3WP.exe","true","Hunting","none","SecurityEvents","SecurityEvent","none","none","This Hunting Query looks for child processes of w3wp.exe that have not been seen as a child process on that host within the last 14 days.
w3wp.exe running suspicious processes such as 'cmd.exe /c echo', 'certutil.exe', or 'powershell.exe' that result in the creation of script files in web -accessible folders is a rare event and is, thus, typically a strong sign of web server compromise and web shell installation.
Ref: https://www.microsoft.com/security/blog/2021/02/11/web-shell-attacks-continue-to-rise/'
","let starttime = todatetime('{{StartTimeISO}}');
let endtime = todatetime('{{EndTimeISO}}');
let lookback = starttime - 14d;
let known_procs = (
SecurityEvent
| where TimeGenerated between(lookback..starttime)
| where EventID == 4688
| where ParentProcessName hassuffix ""w3wp.exe""
| extend ProcessHost = strcat(Process, ""-"", Computer)
| summarize by ProcessHost);
SecurityEvent
| where TimeGenerated between(starttime..endtime)
| where EventID == 4688
| where ParentProcessName hassuffix ""w3wp.exe""
| extend ProcessHost = strcat(Process, ""-"", Computer)
| where ProcessHost !in (known_procs)
| project-reorder TimeGenerated, Computer, NewProcessName, ParentProcessName, Account, NewProcessId
| extend timestamp = TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account"
"3ade1cff-0b74-447b-bd74-66d004659350","Squid commonly abused TLDs","true","Hunting","none","Syslog","Syslog","none","none","本规则将识别可能和恶意软件相关联的顶级域 (TLD), 例如'.click', '.club', '.download',  '.xxx', '.xyz'有关的进程","let suspicious_tlds = dynamic([ "".click"", "".club"", "".download"",  "".xxx"", "".xyz""]);
let timeframe = 14d;
Syslog
| where TimeGenerated >= ago(timeframe) 
| where ProcessName contains ""squid""
| extend URL = extract(""(([A-Z]+ [a-z]{4,5}:\\/\\/)|[A-Z]+ )([^ :]*)"",3,SyslogMessage), 
         SourceIP = extract(""([0-9]+ )(([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3}))"",2,SyslogMessage), 
         Status = extract(""(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))"",1,SyslogMessage), 
         HTTP_Status_Code = extract(""(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))/([0-9]{3})"",8,SyslogMessage),
         User = extract(""(CONNECT |GET )([^ ]* )([^ ]+)"",3,SyslogMessage),
         RemotePort = extract(""(CONNECT |GET )([^ ]*)(:)([0-9]*)"",4,SyslogMessage),
         Domain = extract(""(([A-Z]+ [a-z]{4,5}:\\/\\/)|[A-Z]+ )([^ :\\/]*)"",3,SyslogMessage)
| extend TLD = extract(""\\.[a-z]*$"",0,Domain)
| where TLD in (suspicious_tlds)
| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), clientCount = dcount(SourceIP) by TLD, User, URL
| order by TLD asc, clientCount desc
| extend timestamp = StartTimeUtc, AccountCustomEntity = User, URLCustomEntity = URL"
"9070bc12-c9c6-4512-96f7-9708f431a003","Azure Network Security Group NSG Administrative Operations","true","Hunting","none","AzureActivity","AzureActivity","none","none","本规则将返回Azure 网络安全组 NSG 管理操作。","let timeframe = 1d;
let opValues = dynamic([""Microsoft.Network/networkSecurityGroups/write"", ""Microsoft.Network/networkSecurityGroups/delete""]);
// Azure NSG Create / Update / Delete
AzureActivity
| where TimeGenerated >= ago(timeframe)
| where Category == ""Administrative""
| where OperationNameValue in (opValues)
| where ActivitySubstatusValue in (""Created"", ""OK"")
| sort by TimeGenerated desc
| extend AccountCustomEntity = Caller
| extend IPCustomEntity = CallerIpAddress"
